rlang::local_options(conflicts.policy = list(warn = FALSE))
library(dplyr)
library(tidyr)
library(purrr)
library(glue)
library(conflicted)
conflicts_prefer(dplyr::filter)

con <- DBI::dbConnect(duckdb::duckdb())

filter_print <- function(.data, expr) {
  quo <- rlang::enquo(expr)
  out <-
    .data |>
    filter(!!quo)

  cli::cli_inform(c(
    "{.expr {rlang::quo_text(quo)}}",
    i = "{nrow(.data)} -> {nrow(out)}"
  ))

  out
}

browse_data <- function(x) {
  print(x)
  View(x)
  browser()
  x
}

usage_and_params <- function(function_name, parameters, parameter_types) {
  if (length(parameters) == 1) {
    if (length(parameters[[1]]) == 0) {
      signature <- "()" # No parameters
    } else {
      signature <- paste0("(", paste0(tibble:::tick_if_needed(parameters[[1]]), " = ", tibble:::tick_if_needed(parameter_types[[1]]), collapse = ", "), ")")
    }
    usage_doc <- glue("#' @usage {function_name}{signature}")
  } else {
    usage_doc <- "#' @usage NULL"
  }

  params <-
    tibble(name = unlist(parameters), type = unlist(parameter_types)) |>
    summarize(.by = name, type = paste0(unique(type), collapse = " | "))

  param_doc <-
    params |>
    mutate(out = glue("#' @param {name} `{type}`")) |>
    pull() |>
    glue_collapse(sep = "\n")

  signature <- params |>
    mutate(out = glue("{tibble:::tick_if_needed(name)} = {tibble:::tick_if_needed(type)}")) |>
    pull() |>
    glue_collapse(sep = ", ")

  tibble(usage_doc, param_doc, signature, types = list(params$type))
}

funs <-
  DBI::dbGetQuery(con, "FROM duckdb_functions()") |>
  as_tibble() |>
  select(-database_name, -database_oid, -schema_name, -function_oid, -comment, -tags) |>
  filter_print(function_type == "scalar") |>
  select(-function_type) |>
  filter_print(is.na(varargs)) |>
  select(-varargs) |>
  filter_print(!has_side_effects) |>
  select(-has_side_effects) |>
  filter_print(is.na(macro_definition)) |>
  select(-macro_definition) |>
  filter_print(internal) |>
  select(-internal) |>
  filter_print(stability == "CONSISTENT") |>
  select(-stability) |>
  # FIXME: What if description is missing
  filter_print(!is.na(description)) |>
  # FIXME: Add support if return type is not given.
  filter_print(!is.na(return_type)) |>
  # FIXME: Operators
  filter_print(grepl("^[a-z]", function_name)) |>
  # FIXME: Description not unique
  mutate(.by = function_name, n_desc = length(unique(description))) |>
  filter_print(n_desc == 1) |>
  select(-n_desc) |>
  # FIXME: More than one overload
  mutate(.by = function_name, n = n()) |>
  filter_print(n == 1) |>
  select(-n) |>
  summarize(
    .by = function_name,
    alias_of = unique(alias_of),
    description = paste0(unique(description), collapse = "\n\n"),
    return_type = paste0(unique(return_type), collapse = " | "),
    usage_and_params(first(function_name), parameters, parameter_types),
    examples = paste0(unique(examples), collapse = "\n"),
    categories = list(unique(unlist(categories))),
  ) |>
  # https://github.com/duckdb/duckdb/pull/18977
  mutate(examples = gsub(r"(^variant_typeof\(\{'a': 42, 'b': \[1,2,3\]\)::VARIANT\)$)", "variant_typeof({'a': 42, 'b': [1,2,3]})", examples)) |>
  # FIXME: Irregular
  filter_print(!(function_name %in% c("struct_extract_at"))) |>
  # FIXME: Example too long
  filter_print(!(function_name %in% c("remap_struct"))) |>
  arrange(function_name)

code <-
  funs |>
  mutate(description = gsub("[.]+$", "", description), ".") |>
  mutate(roxy = glue(r"(
    #' DuckDB function {function_name}
    #'
    #' {description}.
    #'
    #' @name {function_name}
    {usage_doc}
    {param_doc}
    #' @examples
    #' \dontrun{{
    #' {examples}
    #' }}
    {function_name} <- function({signature}) {{
      stop("DuckDB function {function_name}() is not available in R.")
    }}

    )")) |>
  pull()

code <- c(
  "# Generated by do_update_duckdb_funs(), do not edit by hand",
  "",
  code
)

invisible(parse(text = code))

writeLines(code, "R/duckdb-funs.R")

dd_code <- glue(r"(
  #' DuckDB functions
  #'
  #' A list of known DuckDB functions.
  #'
  #' @export
  #' @examples
  #' dd[1:3]
  dd <- list(
  {paste0("  ", tibble:::tick_if_needed(funs$function_name), " = ", tibble:::tick_if_needed(funs$function_name), collapse = ",\n")}
  )
  )")

invisible(parse(text = dd_code))

writeLines(dd_code, "R/zzz-dd.R")

globals <-
  funs$types |>
  unlist() |>
  unique() |>
  sort()

globals_code <- paste0('utils::globalVariables("', globals, '")')

invisible(parse(text = globals_code))

writeLines(globals_code, "R/globals.R")
