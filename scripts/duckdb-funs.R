rlang::local_options(conflicts.policy = list(warn = FALSE))
library(dplyr)
library(tidyr)
library(purrr)
library(glue)
library(conflicted)
conflicts_prefer(dplyr::filter)

con <- DBI::dbConnect(duckdb::duckdb())

funs <-
  DBI::dbGetQuery(con, "FROM duckdb_functions()") |>
  as_tibble() |>
  select(-database_name, -database_oid, -schema_name, -function_oid, -comment, -tags) |>
  filter(function_type == "scalar") |>
  select(-function_type) |>
  filter(is.na(varargs)) |>
  select(-varargs) |>
  filter(!has_side_effects) |>
  select(-has_side_effects) |>
  filter(is.na(macro_definition)) |>
  select(-macro_definition) |>
  filter(internal) |>
  select(-internal) |>
  filter(stability == "CONSISTENT") |>
  select(-stability) |>
  # FIXME: What if description is missing
  filter(!is.na(description)) |>
  # FIXME: Add support if return type is not given.
  filter(!is.na(return_type)) |>
  # FIXME: Operators
  filter(grepl("^[a-z]", function_name)) |>
  # FIXME: Description not unique
  mutate(.by = function_name, n_desc = length(unique(description))) |>
  filter(n_desc == 1) |>
  select(-n_desc) |>
  # FIXME: More than one overload
  mutate(.by = function_name, n = n()) |>
  filter(n == 1) |>
  select(-n) |>
  # FIXME: Irregular
  filter(!(function_name %in% c("struct_extract_at"))) |>
  arrange(function_name)

fun_def <-
  funs |>
  mutate(
    .keep = "unused",
    name = map(parameters, trimws),
    type = map(parameter_types, trimws),
  ) |>
  mutate(param_data = map2(name, type, ~ tibble(name = .x, type = .y)))

code <-
  fun_def |>
  mutate(description = gsub("[.]+$", "", description), ".") |>
  mutate(params = map_chr(param_data, ~ glue_collapse(glue("#' @param {.x$name} `{.x$type}`"), sep = "\n"))) |>
  mutate(signature = map_chr(param_data, ~ glue_collapse(glue("{.x$name} = {tibble:::tick_if_needed(.x$type)}"), sep = ", "))) |>
  mutate(roxy = glue(r"(
    #' DuckDB function {function_name}
    #'
    #' {description}.
    #'
    #' @name {function_name}
    #' @usage NULL
    {params}
    #' @examples
    #' \dontrun{{
    #' {examples}
    #' }}
    {function_name} <- function({signature}) {{
      stop("DuckDB function {function_name}() is not available in R.")
    }}

    )")) |>
  pull()

code <- c(
  "# Generated by do_update_duckdb_funs(), do not edit by hand",
  "",
  code
)

invisible(parse(text = code))

writeLines(code, "R/duckdb-funs.R")

dd_code <- glue(r"(
  #' DuckDB functions
  #'
  #' A list of known DuckDB functions.
  #'
  #' @export
  #' @examples
  #' dd[1:3]
  dd <- list(
  {paste0("  ", tibble:::tick_if_needed(funs$function_name), " = ", tibble:::tick_if_needed(funs$function_name), collapse = ",\n")}
  )
  )")

invisible(parse(text = dd_code))

writeLines(dd_code, "R/zzz-dd.R")

globals <-
  funs$parameter_types |>
  unlist() |>
  unique() |>
  sort()

globals_code <- paste0('utils::globalVariables("', globals, '")')

invisible(parse(text = globals_code))

writeLines(globals_code, "R/globals.R")
