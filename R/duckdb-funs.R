# Generated by do_update_duckdb_funs(), do not edit by hand

#' DuckDB function acos
#'
#' Computes the arccosine of x.
#'
#' @name acos
#' @usage acos(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' acos(0.5)
#' }
acos <- function(x = DOUBLE) {
  stop("DuckDB function acos() is not available in R.")
}

#' DuckDB function acosh
#'
#' Computes the inverse hyperbolic cos of x.
#'
#' @name acosh
#' @usage acosh(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' acosh(2.3)
#' }
acosh <- function(x = DOUBLE) {
  stop("DuckDB function acosh() is not available in R.")
}

#' DuckDB function alias
#'
#' Returns the name of a given expression.
#'
#' @name alias
#' @usage alias(expr = ANY)
#' @param expr `ANY`
#' @examples
#' \dontrun{
#' alias(42 + 1)
#' }
alias <- function(expr = ANY) {
  stop("DuckDB function alias() is not available in R.")
}

#' DuckDB function apply
#'
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name apply
#' @usage apply(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' apply([1, 2, 3], lambda x : x + 1)
#' }
apply <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function apply() is not available in R.")
}

#' DuckDB function array_apply
#'
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name array_apply
#' @usage array_apply(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' array_apply([1, 2, 3], lambda x : x + 1)
#' }
array_apply <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function array_apply() is not available in R.")
}

#' DuckDB function array_contains
#'
#' Returns true if the list contains the element.
#'
#' @name array_contains
#' @usage array_contains(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' array_contains([1, 2, NULL], 1)
#' }
array_contains <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_contains() is not available in R.")
}

#' DuckDB function array_cosine_distance
#'
#' Computes the cosine distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_cosine_distance
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @examples
#' \dontrun{
#' array_cosine_distance(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_cosine_distance <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_cosine_distance() is not available in R.")
}

#' DuckDB function array_cosine_similarity
#'
#' Computes the cosine similarity between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_cosine_similarity
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @examples
#' \dontrun{
#' array_cosine_similarity(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_cosine_similarity <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_cosine_similarity() is not available in R.")
}

#' DuckDB function array_cross_product
#'
#' Computes the cross product of two arrays of size 3. The array elements can not be `NULL`.
#'
#' @name array_cross_product
#' @usage NULL
#' @param array `FLOAT[3] | DOUBLE[3]`
#' @examples
#' \dontrun{
#' array_cross_product(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_cross_product <- function(array = `FLOAT[3] | DOUBLE[3]`) {
  stop("DuckDB function array_cross_product() is not available in R.")
}

#' DuckDB function array_distance
#'
#' Computes the distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_distance
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @examples
#' \dontrun{
#' array_distance(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_distance <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_distance() is not available in R.")
}

#' DuckDB function array_distinct
#'
#' Removes all duplicates and `NULL` values from a list. Does not preserve the original order.
#'
#' @name array_distinct
#' @usage array_distinct(list = `T[]`)
#' @param list `T[]`
#' @examples
#' \dontrun{
#' array_distinct([1, 1, NULL, -3, 1, 5])
#' }
array_distinct <- function(list = `T[]`) {
  stop("DuckDB function array_distinct() is not available in R.")
}

#' DuckDB function array_dot_product
#'
#' Computes the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_dot_product
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @examples
#' \dontrun{
#' array_dot_product(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_dot_product <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_dot_product() is not available in R.")
}

#' DuckDB function array_filter
#'
#' Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.
#'
#' @name array_filter
#' @usage array_filter(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' array_filter([3, 4, 5], lambda x : x > 4)
#' }
array_filter <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function array_filter() is not available in R.")
}

#' DuckDB function array_grade_up
#'
#' Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.
#'
#' @name array_grade_up
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @param col2 `VARCHAR`
#' @examples
#' \dontrun{
#' array_grade_up([3, 6, 1, 2])
#' }
array_grade_up <- function(list = `ANY[]`, col1 = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function array_grade_up() is not available in R.")
}

#' DuckDB function array_has
#'
#' Returns true if the list contains the element.
#'
#' @name array_has
#' @usage array_has(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' array_has([1, 2, NULL], 1)
#' }
array_has <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_has() is not available in R.")
}

#' DuckDB function array_has_all
#'
#' Returns true if all elements of list2 are in list1. NULLs are ignored.
#'
#' @name array_has_all
#' @usage array_has_all(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @examples
#' \dontrun{
#' array_has_all([1, 2, 3], [2, 3])
#' }
array_has_all <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function array_has_all() is not available in R.")
}

#' DuckDB function array_has_any
#'
#' Returns true if the lists have any element in common. NULLs are ignored.
#'
#' @name array_has_any
#' @usage array_has_any(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @examples
#' \dontrun{
#' array_has_any([1, 2, 3], [2, 3, 4])
#' }
array_has_any <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function array_has_any() is not available in R.")
}

#' DuckDB function array_indexof
#'
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name array_indexof
#' @usage array_indexof(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' array_indexof([1, 2, NULL], 2)
#' }
array_indexof <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_indexof() is not available in R.")
}

#' DuckDB function array_inner_product
#'
#' Computes the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_inner_product
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @examples
#' \dontrun{
#' array_inner_product(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_inner_product <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_inner_product() is not available in R.")
}

#' DuckDB function array_negative_dot_product
#'
#' Computes the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_negative_dot_product
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @examples
#' \dontrun{
#' array_negative_dot_product(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_negative_dot_product <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_negative_dot_product() is not available in R.")
}

#' DuckDB function array_negative_inner_product
#'
#' Computes the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_negative_inner_product
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @examples
#' \dontrun{
#' array_negative_inner_product(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_negative_inner_product <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_negative_inner_product() is not available in R.")
}

#' DuckDB function array_position
#'
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name array_position
#' @usage array_position(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' array_position([1, 2, NULL], 2)
#' }
array_position <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_position() is not available in R.")
}

#' DuckDB function array_reduce
#'
#' Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.
#'
#' @name array_reduce
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x,y) `LAMBDA`
#' @param initial_value `ANY`
#' @examples
#' \dontrun{
#' array_reduce([1, 2, 3], lambda x, y : x + y)
#' }
array_reduce <- function(list = `ANY[]`, `lambda(x,y)` = LAMBDA, initial_value = ANY) {
  stop("DuckDB function array_reduce() is not available in R.")
}

#' DuckDB function array_resize
#'
#' Resizes the `list` to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set.
#'
#' @name array_resize
#' @usage NULL
#' @param list `ANY[]`
#' @param size[ `ANY`
#' @param value] `ANY`
#' @examples
#' \dontrun{
#' array_resize([1, 2, 3], 5, 0)
#' }
array_resize <- function(list = `ANY[]`, `size[` = ANY, `value]` = ANY) {
  stop("DuckDB function array_resize() is not available in R.")
}

#' DuckDB function array_reverse_sort
#'
#' Sorts the elements of the list in reverse order.
#'
#' @name array_reverse_sort
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @examples
#' \dontrun{
#' array_reverse_sort([3, 6, 1, 2])
#' }
array_reverse_sort <- function(list = `ANY[]`, col1 = VARCHAR) {
  stop("DuckDB function array_reverse_sort() is not available in R.")
}

#' DuckDB function array_select
#'
#' Returns a list based on the elements selected by the `index_list`.
#'
#' @name array_select
#' @usage array_select(value_list = `T[]`, index_list = `BIGINT[]`)
#' @param value_list `T[]`
#' @param index_list `BIGINT[]`
#' @examples
#' \dontrun{
#' array_select([10, 20, 30, 40], [1, 4])
#' }
array_select <- function(value_list = `T[]`, index_list = `BIGINT[]`) {
  stop("DuckDB function array_select() is not available in R.")
}

#' DuckDB function array_sort
#'
#' Sorts the elements of the list.
#'
#' @name array_sort
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @param col2 `VARCHAR`
#' @examples
#' \dontrun{
#' array_sort([3, 6, 1, 2])
#' }
array_sort <- function(list = `ANY[]`, col1 = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function array_sort() is not available in R.")
}

#' DuckDB function array_transform
#'
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name array_transform
#' @usage array_transform(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' array_transform([1, 2, 3], lambda x : x + 1)
#' }
array_transform <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function array_transform() is not available in R.")
}

#' DuckDB function array_unique
#'
#' Counts the unique elements of a `list`.
#'
#' @name array_unique
#' @usage array_unique(list = `ANY[]`)
#' @param list `ANY[]`
#' @examples
#' \dontrun{
#' array_unique([1, 1, NULL, -3, 1, 5])
#' }
array_unique <- function(list = `ANY[]`) {
  stop("DuckDB function array_unique() is not available in R.")
}

#' DuckDB function array_where
#'
#' Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.
#'
#' @name array_where
#' @usage array_where(value_list = `T[]`, mask_list = `BOOLEAN[]`)
#' @param value_list `T[]`
#' @param mask_list `BOOLEAN[]`
#' @examples
#' \dontrun{
#' array_where([10, 20, 30, 40], [true, false, false, true])
#' }
array_where <- function(value_list = `T[]`, mask_list = `BOOLEAN[]`) {
  stop("DuckDB function array_where() is not available in R.")
}

#' DuckDB function ascii
#'
#' Returns an integer that represents the Unicode code point of the first character of the `string`.
#'
#' @name ascii
#' @usage ascii(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' ascii('Î©')
#' }
ascii <- function(string = VARCHAR) {
  stop("DuckDB function ascii() is not available in R.")
}

#' DuckDB function asin
#'
#' Computes the arcsine of x.
#'
#' @name asin
#' @usage asin(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' asin(0.5)
#' }
asin <- function(x = DOUBLE) {
  stop("DuckDB function asin() is not available in R.")
}

#' DuckDB function asinh
#'
#' Computes the inverse hyperbolic sin of x.
#'
#' @name asinh
#' @usage asinh(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' asinh(0.5)
#' }
asinh <- function(x = DOUBLE) {
  stop("DuckDB function asinh() is not available in R.")
}

#' DuckDB function atan
#'
#' Computes the arctangent of x.
#'
#' @name atan
#' @usage atan(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' atan(0.5)
#' }
atan <- function(x = DOUBLE) {
  stop("DuckDB function atan() is not available in R.")
}

#' DuckDB function atan2
#'
#' Computes the arctangent (y, x).
#'
#' @name atan2
#' @usage atan2(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' atan2(1.0, 0.0)
#' }
atan2 <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function atan2() is not available in R.")
}

#' DuckDB function atanh
#'
#' Computes the inverse hyperbolic tan of x.
#'
#' @name atanh
#' @usage atanh(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' atanh(0.5)
#' }
atanh <- function(x = DOUBLE) {
  stop("DuckDB function atanh() is not available in R.")
}

#' DuckDB function bar
#'
#' Draws a band whose width is proportional to (`x - min`) and equal to `width` characters when `x` = `max`. `width` defaults to 80.
#'
#' @name bar
#' @usage NULL
#' @param x `DOUBLE`
#' @param min `DOUBLE`
#' @param max `DOUBLE`
#' @param width `DOUBLE`
#' @examples
#' \dontrun{
#' bar(5, 0, 20, 10)
#' }
bar <- function(x = DOUBLE, min = DOUBLE, max = DOUBLE, width = DOUBLE) {
  stop("DuckDB function bar() is not available in R.")
}

#' DuckDB function base64
#'
#' Converts a `blob` to a base64 encoded string.
#'
#' @name base64
#' @usage base64(blob = BLOB)
#' @param blob `BLOB`
#' @examples
#' \dontrun{
#' base64('A'::BLOB)
#' }
base64 <- function(blob = BLOB) {
  stop("DuckDB function base64() is not available in R.")
}

#' DuckDB function bit_position
#'
#' Returns first starting index of the specified substring within bits, or zero if it is not present. The first (leftmost) bit is indexed 1.
#'
#' @name bit_position
#' @usage bit_position(substring = BIT, bitstring = BIT)
#' @param substring `BIT`
#' @param bitstring `BIT`
#' @examples
#' \dontrun{
#' bit_position('010'::BIT, '1110101'::BIT)
#' }
bit_position <- function(substring = BIT, bitstring = BIT) {
  stop("DuckDB function bit_position() is not available in R.")
}

#' DuckDB function bitstring
#'
#' Pads the bitstring until the specified length.
#'
#' @name bitstring
#' @usage NULL
#' @param bitstring `VARCHAR | BIT`
#' @param length `INTEGER`
#' @examples
#' \dontrun{
#' bitstring('1010'::BIT, 7)
#' }
bitstring <- function(bitstring = `VARCHAR | BIT`, length = INTEGER) {
  stop("DuckDB function bitstring() is not available in R.")
}

#' DuckDB function can_cast_implicitly
#'
#' Whether or not we can implicitly cast from the source type to the other type.
#'
#' @name can_cast_implicitly
#' @usage can_cast_implicitly(source_type = ANY, target_type = ANY)
#' @param source_type `ANY`
#' @param target_type `ANY`
#' @examples
#' \dontrun{
#' can_cast_implicitly(NULL::INTEGER, NULL::BIGINT)
#' }
can_cast_implicitly <- function(source_type = ANY, target_type = ANY) {
  stop("DuckDB function can_cast_implicitly() is not available in R.")
}

#' DuckDB function cast_to_type
#'
#' Casts the first argument to the type of the second argument.
#'
#' @name cast_to_type
#' @usage cast_to_type(param = ANY, type = ANY)
#' @param param `ANY`
#' @param type `ANY`
#' @examples
#' \dontrun{
#' cast_to_type('42', NULL::INTEGER)
#' }
cast_to_type <- function(param = ANY, type = ANY) {
  stop("DuckDB function cast_to_type() is not available in R.")
}

#' DuckDB function cbrt
#'
#' Returns the cube root of x.
#'
#' @name cbrt
#' @usage cbrt(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cbrt(8)
#' }
cbrt <- function(x = DOUBLE) {
  stop("DuckDB function cbrt() is not available in R.")
}

#' DuckDB function ceil
#'
#' Rounds the number up.
#'
#' @name ceil
#' @usage NULL
#' @param x `FLOAT | DOUBLE | DECIMAL`
#' @examples
#' \dontrun{
#' ceil(17.4)
#' }
ceil <- function(x = `FLOAT | DOUBLE | DECIMAL`) {
  stop("DuckDB function ceil() is not available in R.")
}

#' DuckDB function ceiling
#'
#' Rounds the number up.
#'
#' @name ceiling
#' @usage NULL
#' @param x `FLOAT | DOUBLE | DECIMAL`
#' @examples
#' \dontrun{
#' ceiling(17.4)
#' }
ceiling <- function(x = `FLOAT | DOUBLE | DECIMAL`) {
  stop("DuckDB function ceiling() is not available in R.")
}

#' DuckDB function chr
#'
#' Returns a character which is corresponding the ASCII code value or Unicode code point.
#'
#' @name chr
#' @usage chr(code_point = INTEGER)
#' @param code_point `INTEGER`
#' @examples
#' \dontrun{
#' chr(65)
#' }
chr <- function(code_point = INTEGER) {
  stop("DuckDB function chr() is not available in R.")
}

#' DuckDB function contains
#'
#' Returns `true` if `search_string` is found within `string`.
#'
#' @name contains
#' @usage contains(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' contains('abc', 'a')
#' }
contains <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function contains() is not available in R.")
}

#' DuckDB function cos
#'
#' Computes the cos of x.
#'
#' @name cos
#' @usage cos(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cos(90)
#' }
cos <- function(x = DOUBLE) {
  stop("DuckDB function cos() is not available in R.")
}

#' DuckDB function cosh
#'
#' Computes the hyperbolic cos of x.
#'
#' @name cosh
#' @usage cosh(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cosh(1)
#' }
cosh <- function(x = DOUBLE) {
  stop("DuckDB function cosh() is not available in R.")
}

#' DuckDB function cot
#'
#' Computes the cotangent of x.
#'
#' @name cot
#' @usage cot(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cot(0.5)
#' }
cot <- function(x = DOUBLE) {
  stop("DuckDB function cot() is not available in R.")
}

#' DuckDB function current_setting
#'
#' Returns the current value of the configuration setting.
#'
#' @name current_setting
#' @usage current_setting(setting_name = VARCHAR)
#' @param setting_name `VARCHAR`
#' @examples
#' \dontrun{
#' current_setting('access_mode')
#' }
current_setting <- function(setting_name = VARCHAR) {
  stop("DuckDB function current_setting() is not available in R.")
}

#' DuckDB function damerau_levenshtein
#'
#' Extension of Levenshtein distance to also include transposition of adjacent characters as an allowed edit operation. In other words, the minimum number of edit operations (insertions, deletions, substitutions or transpositions) required to change one string to another. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name damerau_levenshtein
#' @usage damerau_levenshtein(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' damerau_levenshtein('duckdb', 'udckbd')
#' }
damerau_levenshtein <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function damerau_levenshtein() is not available in R.")
}

#' DuckDB function dayname
#'
#' The (English) name of the weekday.
#'
#' @name dayname
#' @usage NULL
#' @param ts `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @examples
#' \dontrun{
#' dayname(TIMESTAMP '1992-03-22')
#' }
dayname <- function(ts = `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function dayname() is not available in R.")
}

#' DuckDB function decode
#'
#' Converts `blob` to `VARCHAR`. Fails if `blob` is not valid UTF-8.
#'
#' @name decode
#' @usage decode(blob = BLOB)
#' @param blob `BLOB`
#' @examples
#' \dontrun{
#' decode('\xC3\xBC'::BLOB)
#' }
decode <- function(blob = BLOB) {
  stop("DuckDB function decode() is not available in R.")
}

#' DuckDB function degrees
#'
#' Converts radians to degrees.
#'
#' @name degrees
#' @usage degrees(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' degrees(pi())
#' }
degrees <- function(x = DOUBLE) {
  stop("DuckDB function degrees() is not available in R.")
}

#' DuckDB function editdist3
#'
#' The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name editdist3
#' @usage editdist3(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' editdist3('duck', 'db')
#' }
editdist3 <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function editdist3() is not available in R.")
}

#' DuckDB function element_at
#'
#' Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the mapâ€™s keys else an error is returned.
#'
#' @name element_at
#' @usage element_at(map = `MAP(K, V)`, key = K)
#' @param map `MAP(K, V)`
#' @param key `K`
#' @examples
#' \dontrun{
#' element_at(map(['key'], ['val']), 'key')
#' }
element_at <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function element_at() is not available in R.")
}

#' DuckDB function encode
#'
#' Converts the `string` to `BLOB`. Converts UTF-8 characters into literal encoding.
#'
#' @name encode
#' @usage encode(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' encode('my_string_with_Ã¼')
#' }
encode <- function(string = VARCHAR) {
  stop("DuckDB function encode() is not available in R.")
}

#' DuckDB function ends_with
#'
#' Returns `true` if `string` ends with `search_string`.
#'
#' @name ends_with
#' @usage ends_with(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' ends_with('abc', 'bc')
#' }
ends_with <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function ends_with() is not available in R.")
}

#' DuckDB function enum_code
#'
#' Returns the numeric value backing the given enum value.
#'
#' @name enum_code
#' @usage enum_code(enum = ANY)
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_code('happy'::mood)
#' }
enum_code <- function(enum = ANY) {
  stop("DuckDB function enum_code() is not available in R.")
}

#' DuckDB function enum_first
#'
#' Returns the first value of the input enum type.
#'
#' @name enum_first
#' @usage enum_first(enum = ANY)
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_first(NULL::mood)
#' }
enum_first <- function(enum = ANY) {
  stop("DuckDB function enum_first() is not available in R.")
}

#' DuckDB function enum_last
#'
#' Returns the last value of the input enum type.
#'
#' @name enum_last
#' @usage enum_last(enum = ANY)
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_last(NULL::mood)
#' }
enum_last <- function(enum = ANY) {
  stop("DuckDB function enum_last() is not available in R.")
}

#' DuckDB function enum_range
#'
#' Returns all values of the input enum type as an array.
#'
#' @name enum_range
#' @usage enum_range(enum = ANY)
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_range(NULL::mood)
#' }
enum_range <- function(enum = ANY) {
  stop("DuckDB function enum_range() is not available in R.")
}

#' DuckDB function enum_range_boundary
#'
#' Returns the range between the two given enum values as an array. The values must be of the same enum type. When the first parameter is NULL, the result starts with the first value of the enum type. When the second parameter is NULL, the result ends with the last value of the enum type.
#'
#' @name enum_range_boundary
#' @usage enum_range_boundary(start = ANY, end = ANY)
#' @param start `ANY`
#' @param end `ANY`
#' @examples
#' \dontrun{
#' enum_range_boundary(NULL, 'happy'::mood)
#' }
enum_range_boundary <- function(start = ANY, end = ANY) {
  stop("DuckDB function enum_range_boundary() is not available in R.")
}

#' DuckDB function even
#'
#' Rounds x to next even number by rounding away from zero.
#'
#' @name even
#' @usage even(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' even(2.9)
#' }
even <- function(x = DOUBLE) {
  stop("DuckDB function even() is not available in R.")
}

#' DuckDB function exp
#'
#' Computes e to the power of x.
#'
#' @name exp
#' @usage exp(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' exp(1)
#' }
exp <- function(x = DOUBLE) {
  stop("DuckDB function exp() is not available in R.")
}

#' DuckDB function factorial
#'
#' Factorial of x. Computes the product of the current integer and all integers below it.
#'
#' @name factorial
#' @usage factorial(x = INTEGER)
#' @param x `INTEGER`
#' @examples
#' \dontrun{
#' 4!
#' }
factorial <- function(x = INTEGER) {
  stop("DuckDB function factorial() is not available in R.")
}

#' DuckDB function filter
#'
#' Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.
#'
#' @name filter
#' @usage filter(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' filter([3, 4, 5], lambda x : x > 4)
#' }
filter <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function filter() is not available in R.")
}

#' DuckDB function flatten
#'
#' Flattens a nested list by one level.
#'
#' @name flatten
#' @usage flatten(nested_list = `T[][]`)
#' @param nested_list `T[][]`
#' @examples
#' \dontrun{
#' flatten([[1, 2, 3], [4, 5]])
#' }
flatten <- function(nested_list = `T[][]`) {
  stop("DuckDB function flatten() is not available in R.")
}

#' DuckDB function floor
#'
#' Rounds the number down.
#'
#' @name floor
#' @usage NULL
#' @param x `FLOAT | DOUBLE | DECIMAL`
#' @examples
#' \dontrun{
#' floor(17.4)
#' }
floor <- function(x = `FLOAT | DOUBLE | DECIMAL`) {
  stop("DuckDB function floor() is not available in R.")
}

#' DuckDB function formatReadableDecimalSize
#'
#' Converts `integer` to a human-readable representation using units based on powers of 10 (KB, MB, GB, etc.).
#'
#' @name formatReadableDecimalSize
#' @usage formatReadableDecimalSize(integer = BIGINT)
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' formatReadableDecimalSize(16_000)
#' }
formatReadableDecimalSize <- function(integer = BIGINT) {
  stop("DuckDB function formatReadableDecimalSize() is not available in R.")
}

#' DuckDB function formatReadableSize
#'
#' Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).
#'
#' @name formatReadableSize
#' @usage formatReadableSize(integer = BIGINT)
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' formatReadableSize(16_000)
#' }
formatReadableSize <- function(integer = BIGINT) {
  stop("DuckDB function formatReadableSize() is not available in R.")
}

#' DuckDB function format_bytes
#'
#' Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).
#'
#' @name format_bytes
#' @usage format_bytes(integer = BIGINT)
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' format_bytes(16_000)
#' }
format_bytes <- function(integer = BIGINT) {
  stop("DuckDB function format_bytes() is not available in R.")
}

#' DuckDB function from_base64
#'
#' Converts a base64 encoded `string` to a character string (`BLOB`).
#'
#' @name from_base64
#' @usage from_base64(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' from_base64('QQ==')
#' }
from_base64 <- function(string = VARCHAR) {
  stop("DuckDB function from_base64() is not available in R.")
}

#' DuckDB function from_binary
#'
#' Converts a `value` from binary representation to a blob.
#'
#' @name from_binary
#' @usage from_binary(value = VARCHAR)
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' from_binary('0110')
#' }
from_binary <- function(value = VARCHAR) {
  stop("DuckDB function from_binary() is not available in R.")
}

#' DuckDB function from_hex
#'
#' Converts a `value` from hexadecimal representation to a blob.
#'
#' @name from_hex
#' @usage from_hex(value = VARCHAR)
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' from_hex('2A')
#' }
from_hex <- function(value = VARCHAR) {
  stop("DuckDB function from_hex() is not available in R.")
}

#' DuckDB function gamma
#'
#' Interpolation of (x-1) factorial (so decimal inputs are allowed).
#'
#' @name gamma
#' @usage gamma(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' gamma(5.5)
#' }
gamma <- function(x = DOUBLE) {
  stop("DuckDB function gamma() is not available in R.")
}

#' DuckDB function gcd
#'
#' Computes the greatest common divisor of x and y.
#'
#' @name gcd
#' @usage NULL
#' @param x `BIGINT | HUGEINT`
#' @param y `BIGINT | HUGEINT`
#' @examples
#' \dontrun{
#' gcd(42, 57)
#' }
gcd <- function(x = `BIGINT | HUGEINT`, y = `BIGINT | HUGEINT`) {
  stop("DuckDB function gcd() is not available in R.")
}

#' DuckDB function get_bit
#'
#' Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0.
#'
#' @name get_bit
#' @usage get_bit(bitstring = BIT, index = INTEGER)
#' @param bitstring `BIT`
#' @param index `INTEGER`
#' @examples
#' \dontrun{
#' get_bit('0110010'::BIT, 2)
#' }
get_bit <- function(bitstring = BIT, index = INTEGER) {
  stop("DuckDB function get_bit() is not available in R.")
}

#' DuckDB function grade_up
#'
#' Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.
#'
#' @name grade_up
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @param col2 `VARCHAR`
#' @examples
#' \dontrun{
#' grade_up([3, 6, 1, 2])
#' }
grade_up <- function(list = `ANY[]`, col1 = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function grade_up() is not available in R.")
}

#' DuckDB function greatest_common_divisor
#'
#' Computes the greatest common divisor of x and y.
#'
#' @name greatest_common_divisor
#' @usage NULL
#' @param x `BIGINT | HUGEINT`
#' @param y `BIGINT | HUGEINT`
#' @examples
#' \dontrun{
#' greatest_common_divisor(42, 57)
#' }
greatest_common_divisor <- function(x = `BIGINT | HUGEINT`, y = `BIGINT | HUGEINT`) {
  stop("DuckDB function greatest_common_divisor() is not available in R.")
}

#' DuckDB function hamming
#'
#' The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length. Strings must be of equal length. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name hamming
#' @usage hamming(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' hamming('duck', 'luck')
#' }
hamming <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function hamming() is not available in R.")
}

#' DuckDB function ilike_escape
#'
#' Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name ilike_escape
#' @usage ilike_escape(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR)
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' ilike_escape('A%c', 'a$%C', '$')
#' }
ilike_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function ilike_escape() is not available in R.")
}

#' DuckDB function instr
#'
#' Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.
#'
#' @name instr
#' @usage instr(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' instr('test test', 'es')
#' }
instr <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function instr() is not available in R.")
}

#' DuckDB function is_histogram_other_bin
#'
#' Whether or not the provided value is the histogram "other" bin (used for values not belonging to any provided bin).
#'
#' @name is_histogram_other_bin
#' @usage is_histogram_other_bin(val = ANY)
#' @param val `ANY`
#' @examples
#' \dontrun{
#' is_histogram_other_bin(v)
#' }
is_histogram_other_bin <- function(val = ANY) {
  stop("DuckDB function is_histogram_other_bin() is not available in R.")
}

#' DuckDB function isnan
#'
#' Returns true if the floating point value is not a number, false otherwise.
#'
#' @name isnan
#' @usage NULL
#' @param x `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' isnan('NaN'::FLOAT)
#' }
isnan <- function(x = `FLOAT | DOUBLE`) {
  stop("DuckDB function isnan() is not available in R.")
}

#' DuckDB function jaccard
#'
#' The Jaccard similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1.
#'
#' @name jaccard
#' @usage jaccard(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' jaccard('duck', 'luck')
#' }
jaccard <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function jaccard() is not available in R.")
}

#' DuckDB function jaro_similarity
#'
#' The Jaro similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1. For similarity < `score_cutoff`, 0 is returned instead. `score_cutoff` defaults to 0.
#'
#' @name jaro_similarity
#' @usage NULL
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @param score_cutoff `DOUBLE`
#' @examples
#' \dontrun{
#' jaro_similarity('duck', 'duckdb')
#' }
jaro_similarity <- function(s1 = VARCHAR, s2 = VARCHAR, score_cutoff = DOUBLE) {
  stop("DuckDB function jaro_similarity() is not available in R.")
}

#' DuckDB function jaro_winkler_similarity
#'
#' The Jaro-Winkler similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1. For similarity < `score_cutoff`, 0 is returned instead. `score_cutoff` defaults to 0.
#'
#' @name jaro_winkler_similarity
#' @usage NULL
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @param score_cutoff `DOUBLE`
#' @examples
#' \dontrun{
#' jaro_winkler_similarity('duck', 'duckdb')
#' }
jaro_winkler_similarity <- function(s1 = VARCHAR, s2 = VARCHAR, score_cutoff = DOUBLE) {
  stop("DuckDB function jaro_winkler_similarity() is not available in R.")
}

#' DuckDB function julian
#'
#' Extract the Julian Day number from a date or timestamp.
#'
#' @name julian
#' @usage NULL
#' @param ts `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @examples
#' \dontrun{
#' julian(timestamp '2006-01-01 12:00')
#' }
julian <- function(ts = `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function julian() is not available in R.")
}

#' DuckDB function last_day
#'
#' Returns the last day of the month.
#'
#' @name last_day
#' @usage NULL
#' @param ts `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @examples
#' \dontrun{
#' last_day(TIMESTAMP '1992-03-22 01:02:03.1234')
#' }
last_day <- function(ts = `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function last_day() is not available in R.")
}

#' DuckDB function lcase
#'
#' Converts `string` to lower case.
#'
#' @name lcase
#' @usage lcase(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' lcase('Hello')
#' }
lcase <- function(string = VARCHAR) {
  stop("DuckDB function lcase() is not available in R.")
}

#' DuckDB function lcm
#'
#' Computes the least common multiple of x and y.
#'
#' @name lcm
#' @usage NULL
#' @param x `BIGINT | HUGEINT`
#' @param y `BIGINT | HUGEINT`
#' @examples
#' \dontrun{
#' lcm(42, 57)
#' }
lcm <- function(x = `BIGINT | HUGEINT`, y = `BIGINT | HUGEINT`) {
  stop("DuckDB function lcm() is not available in R.")
}

#' DuckDB function least_common_multiple
#'
#' Computes the least common multiple of x and y.
#'
#' @name least_common_multiple
#' @usage NULL
#' @param x `BIGINT | HUGEINT`
#' @param y `BIGINT | HUGEINT`
#' @examples
#' \dontrun{
#' least_common_multiple(42, 57)
#' }
least_common_multiple <- function(x = `BIGINT | HUGEINT`, y = `BIGINT | HUGEINT`) {
  stop("DuckDB function least_common_multiple() is not available in R.")
}

#' DuckDB function left
#'
#' Extracts the left-most count characters.
#'
#' @name left
#' @usage left(string = VARCHAR, count = BIGINT)
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' left('HelloðŸ¦†', 2)
#' }
left <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function left() is not available in R.")
}

#' DuckDB function left_grapheme
#'
#' Extracts the left-most count grapheme clusters.
#'
#' @name left_grapheme
#' @usage left_grapheme(string = VARCHAR, count = BIGINT)
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' left_grapheme('ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸', 1)
#' }
left_grapheme <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function left_grapheme() is not available in R.")
}

#' DuckDB function length_grapheme
#'
#' Number of grapheme clusters in `string`.
#'
#' @name length_grapheme
#' @usage length_grapheme(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' length_grapheme('ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸')
#' }
length_grapheme <- function(string = VARCHAR) {
  stop("DuckDB function length_grapheme() is not available in R.")
}

#' DuckDB function levenshtein
#'
#' The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name levenshtein
#' @usage levenshtein(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' levenshtein('duck', 'db')
#' }
levenshtein <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function levenshtein() is not available in R.")
}

#' DuckDB function lgamma
#'
#' Computes the log of the gamma function.
#'
#' @name lgamma
#' @usage lgamma(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' lgamma(2)
#' }
lgamma <- function(x = DOUBLE) {
  stop("DuckDB function lgamma() is not available in R.")
}

#' DuckDB function like_escape
#'
#' Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name like_escape
#' @usage like_escape(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR)
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' like_escape('a%c', 'a$%c', '$')
#' }
like_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function like_escape() is not available in R.")
}

#' DuckDB function list_apply
#'
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name list_apply
#' @usage list_apply(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' list_apply([1, 2, 3], lambda x : x + 1)
#' }
list_apply <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function list_apply() is not available in R.")
}

#' DuckDB function list_contains
#'
#' Returns true if the list contains the element.
#'
#' @name list_contains
#' @usage list_contains(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' list_contains([1, 2, NULL], 1)
#' }
list_contains <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_contains() is not available in R.")
}

#' DuckDB function list_cosine_distance
#'
#' Computes the cosine distance between two same-sized lists.
#'
#' @name list_cosine_distance
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @examples
#' \dontrun{
#' list_cosine_distance([1, 2, 3], [1, 2, 3])
#' }
list_cosine_distance <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_cosine_distance() is not available in R.")
}

#' DuckDB function list_cosine_similarity
#'
#' Computes the cosine similarity between two same-sized lists.
#'
#' @name list_cosine_similarity
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @examples
#' \dontrun{
#' list_cosine_similarity([1, 2, 3], [1, 2, 3])
#' }
list_cosine_similarity <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_cosine_similarity() is not available in R.")
}

#' DuckDB function list_distance
#'
#' Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length.
#'
#' @name list_distance
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @examples
#' \dontrun{
#' list_distance([1, 2, 3], [1, 2, 5])
#' }
list_distance <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_distance() is not available in R.")
}

#' DuckDB function list_distinct
#'
#' Removes all duplicates and `NULL` values from a list. Does not preserve the original order.
#'
#' @name list_distinct
#' @usage list_distinct(list = `T[]`)
#' @param list `T[]`
#' @examples
#' \dontrun{
#' list_distinct([1, 1, NULL, -3, 1, 5])
#' }
list_distinct <- function(list = `T[]`) {
  stop("DuckDB function list_distinct() is not available in R.")
}

#' DuckDB function list_dot_product
#'
#' Computes the inner product between two same-sized lists.
#'
#' @name list_dot_product
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @examples
#' \dontrun{
#' list_dot_product([1, 2, 3], [1, 2, 3])
#' }
list_dot_product <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_dot_product() is not available in R.")
}

#' DuckDB function list_element
#'
#' Extract the `index`th (1-based) value from the list.
#'
#' @name list_element
#' @usage NULL
#' @param list `T[] | VARCHAR`
#' @param index `BIGINT`
#' @examples
#' \dontrun{
#' list_element([4, 5, 6], 3)
#' }
list_element <- function(list = `T[] | VARCHAR`, index = BIGINT) {
  stop("DuckDB function list_element() is not available in R.")
}

#' DuckDB function list_extract
#'
#' Extract the `index`th (1-based) value from the list.
#'
#' @name list_extract
#' @usage NULL
#' @param list `T[] | VARCHAR`
#' @param index `BIGINT`
#' @examples
#' \dontrun{
#' list_extract([4, 5, 6], 3)
#' }
list_extract <- function(list = `T[] | VARCHAR`, index = BIGINT) {
  stop("DuckDB function list_extract() is not available in R.")
}

#' DuckDB function list_filter
#'
#' Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.
#'
#' @name list_filter
#' @usage list_filter(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' list_filter([3, 4, 5], lambda x : x > 4)
#' }
list_filter <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function list_filter() is not available in R.")
}

#' DuckDB function list_grade_up
#'
#' Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.
#'
#' @name list_grade_up
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @param col2 `VARCHAR`
#' @examples
#' \dontrun{
#' list_grade_up([3, 6, 1, 2])
#' }
list_grade_up <- function(list = `ANY[]`, col1 = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function list_grade_up() is not available in R.")
}

#' DuckDB function list_has
#'
#' Returns true if the list contains the element.
#'
#' @name list_has
#' @usage list_has(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' list_has([1, 2, NULL], 1)
#' }
list_has <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_has() is not available in R.")
}

#' DuckDB function list_has_all
#'
#' Returns true if all elements of list2 are in list1. NULLs are ignored.
#'
#' @name list_has_all
#' @usage list_has_all(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @examples
#' \dontrun{
#' list_has_all([1, 2, 3], [2, 3])
#' }
list_has_all <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function list_has_all() is not available in R.")
}

#' DuckDB function list_has_any
#'
#' Returns true if the lists have any element in common. NULLs are ignored.
#'
#' @name list_has_any
#' @usage list_has_any(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @examples
#' \dontrun{
#' list_has_any([1, 2, 3], [2, 3, 4])
#' }
list_has_any <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function list_has_any() is not available in R.")
}

#' DuckDB function list_indexof
#'
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name list_indexof
#' @usage list_indexof(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' list_indexof([1, 2, NULL], 2)
#' }
list_indexof <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_indexof() is not available in R.")
}

#' DuckDB function list_inner_product
#'
#' Computes the inner product between two same-sized lists.
#'
#' @name list_inner_product
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @examples
#' \dontrun{
#' list_inner_product([1, 2, 3], [1, 2, 3])
#' }
list_inner_product <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_inner_product() is not available in R.")
}

#' DuckDB function list_negative_dot_product
#'
#' Computes the negative inner product between two same-sized lists.
#'
#' @name list_negative_dot_product
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @examples
#' \dontrun{
#' list_negative_dot_product([1, 2, 3], [1, 2, 3])
#' }
list_negative_dot_product <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_negative_dot_product() is not available in R.")
}

#' DuckDB function list_negative_inner_product
#'
#' Computes the negative inner product between two same-sized lists.
#'
#' @name list_negative_inner_product
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @examples
#' \dontrun{
#' list_negative_inner_product([1, 2, 3], [1, 2, 3])
#' }
list_negative_inner_product <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_negative_inner_product() is not available in R.")
}

#' DuckDB function list_pack
#'
#' Creates a LIST containing the argument values.
#'
#' @name list_pack
#' @usage list_pack()

#' @examples
#' \dontrun{
#' list_pack(4, 5, 6)
#' }
list_pack <- function() {
  stop("DuckDB function list_pack() is not available in R.")
}

#' DuckDB function list_position
#'
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name list_position
#' @usage list_position(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' list_position([1, 2, NULL], 2)
#' }
list_position <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_position() is not available in R.")
}

#' DuckDB function list_reduce
#'
#' Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.
#'
#' @name list_reduce
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x,y) `LAMBDA`
#' @param initial_value `ANY`
#' @examples
#' \dontrun{
#' list_reduce([1, 2, 3], lambda x, y : x + y)
#' }
list_reduce <- function(list = `ANY[]`, `lambda(x,y)` = LAMBDA, initial_value = ANY) {
  stop("DuckDB function list_reduce() is not available in R.")
}

#' DuckDB function list_resize
#'
#' Resizes the `list` to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set.
#'
#' @name list_resize
#' @usage NULL
#' @param list `ANY[]`
#' @param size[ `ANY`
#' @param value] `ANY`
#' @examples
#' \dontrun{
#' list_resize([1, 2, 3], 5, 0)
#' }
list_resize <- function(list = `ANY[]`, `size[` = ANY, `value]` = ANY) {
  stop("DuckDB function list_resize() is not available in R.")
}

#' DuckDB function list_reverse_sort
#'
#' Sorts the elements of the list in reverse order.
#'
#' @name list_reverse_sort
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @examples
#' \dontrun{
#' list_reverse_sort([3, 6, 1, 2])
#' }
list_reverse_sort <- function(list = `ANY[]`, col1 = VARCHAR) {
  stop("DuckDB function list_reverse_sort() is not available in R.")
}

#' DuckDB function list_select
#'
#' Returns a list based on the elements selected by the `index_list`.
#'
#' @name list_select
#' @usage list_select(value_list = `T[]`, index_list = `BIGINT[]`)
#' @param value_list `T[]`
#' @param index_list `BIGINT[]`
#' @examples
#' \dontrun{
#' list_select([10, 20, 30, 40], [1, 4])
#' }
list_select <- function(value_list = `T[]`, index_list = `BIGINT[]`) {
  stop("DuckDB function list_select() is not available in R.")
}

#' DuckDB function list_sort
#'
#' Sorts the elements of the list.
#'
#' @name list_sort
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @param col2 `VARCHAR`
#' @examples
#' \dontrun{
#' list_sort([3, 6, 1, 2])
#' }
list_sort <- function(list = `ANY[]`, col1 = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function list_sort() is not available in R.")
}

#' DuckDB function list_transform
#'
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name list_transform
#' @usage list_transform(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' list_transform([1, 2, 3], lambda x : x + 1)
#' }
list_transform <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function list_transform() is not available in R.")
}

#' DuckDB function list_unique
#'
#' Counts the unique elements of a `list`.
#'
#' @name list_unique
#' @usage list_unique(list = `ANY[]`)
#' @param list `ANY[]`
#' @examples
#' \dontrun{
#' list_unique([1, 1, NULL, -3, 1, 5])
#' }
list_unique <- function(list = `ANY[]`) {
  stop("DuckDB function list_unique() is not available in R.")
}

#' DuckDB function list_value
#'
#' Creates a LIST containing the argument values.
#'
#' @name list_value
#' @usage list_value()

#' @examples
#' \dontrun{
#' list_value(4, 5, 6)
#' }
list_value <- function() {
  stop("DuckDB function list_value() is not available in R.")
}

#' DuckDB function list_where
#'
#' Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.
#'
#' @name list_where
#' @usage list_where(value_list = `T[]`, mask_list = `BOOLEAN[]`)
#' @param value_list `T[]`
#' @param mask_list `BOOLEAN[]`
#' @examples
#' \dontrun{
#' list_where([10, 20, 30, 40], [true, false, false, true])
#' }
list_where <- function(value_list = `T[]`, mask_list = `BOOLEAN[]`) {
  stop("DuckDB function list_where() is not available in R.")
}

#' DuckDB function ln
#'
#' Computes the natural logarithm of x.
#'
#' @name ln
#' @usage ln(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' ln(2)
#' }
ln <- function(x = DOUBLE) {
  stop("DuckDB function ln() is not available in R.")
}

#' DuckDB function log
#'
#' Computes the logarithm of x to base b. b may be omitted, in which case the default 10.
#'
#' @name log
#' @usage NULL
#' @param b `DOUBLE`
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' log(2, 64)
#' }
log <- function(b = DOUBLE, x = DOUBLE) {
  stop("DuckDB function log() is not available in R.")
}

#' DuckDB function log10
#'
#' Computes the 10-log of x.
#'
#' @name log10
#' @usage log10(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' log10(1000)
#' }
log10 <- function(x = DOUBLE) {
  stop("DuckDB function log10() is not available in R.")
}

#' DuckDB function log2
#'
#' Computes the 2-log of x.
#'
#' @name log2
#' @usage log2(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' log2(8)
#' }
log2 <- function(x = DOUBLE) {
  stop("DuckDB function log2() is not available in R.")
}

#' DuckDB function lower
#'
#' Converts `string` to lower case.
#'
#' @name lower
#' @usage lower(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' lower('Hello')
#' }
lower <- function(string = VARCHAR) {
  stop("DuckDB function lower() is not available in R.")
}

#' DuckDB function lpad
#'
#' Pads the `string` with the `character` on the left until it has `count` characters. Truncates the `string` on the right if it has more than `count` characters.
#'
#' @name lpad
#' @usage lpad(string = VARCHAR, count = INTEGER, character = VARCHAR)
#' @param string `VARCHAR`
#' @param count `INTEGER`
#' @param character `VARCHAR`
#' @examples
#' \dontrun{
#' lpad('hello', 8, '>')
#' }
lpad <- function(string = VARCHAR, count = INTEGER, character = VARCHAR) {
  stop("DuckDB function lpad() is not available in R.")
}

#' DuckDB function ltrim
#'
#' Removes any occurrences of any of the `characters` from the left side of the `string`. `characters` defaults to `space`.
#'
#' @name ltrim
#' @usage NULL
#' @param string `VARCHAR`
#' @param characters `VARCHAR`
#' @examples
#' \dontrun{
#' c("ltrim('    test  ')", "ltrim('>>>>test<<', '><')")
#' }
ltrim <- function(string = VARCHAR, characters = VARCHAR) {
  stop("DuckDB function ltrim() is not available in R.")
}

#' DuckDB function make_time
#'
#' The time for the given parts.
#'
#' @name make_time
#' @usage make_time(hour = BIGINT, minute = BIGINT, seconds = DOUBLE)
#' @param hour `BIGINT`
#' @param minute `BIGINT`
#' @param seconds `DOUBLE`
#' @examples
#' \dontrun{
#' make_time(13, 34, 27.123456)
#' }
make_time <- function(hour = BIGINT, minute = BIGINT, seconds = DOUBLE) {
  stop("DuckDB function make_time() is not available in R.")
}

#' DuckDB function make_timestamp
#'
#' The timestamp for the given parts.
#'
#' @name make_timestamp
#' @usage NULL
#' @param year `BIGINT`
#' @param month `BIGINT`
#' @param day `BIGINT`
#' @param hour `BIGINT`
#' @param minute `BIGINT`
#' @param seconds `DOUBLE`
#' @examples
#' \dontrun{
#' make_timestamp(1992, 9, 20, 13, 34, 27.123456)
#' }
make_timestamp <- function(year = BIGINT, month = BIGINT, day = BIGINT, hour = BIGINT, minute = BIGINT, seconds = DOUBLE) {
  stop("DuckDB function make_timestamp() is not available in R.")
}

#' DuckDB function make_timestamp_ms
#'
#' The timestamp for the given microseconds since the epoch.
#'
#' @name make_timestamp_ms
#' @usage make_timestamp_ms(nanos = BIGINT)
#' @param nanos `BIGINT`
#' @examples
#' \dontrun{
#' make_timestamp_ms(1732117793000000)
#' }
make_timestamp_ms <- function(nanos = BIGINT) {
  stop("DuckDB function make_timestamp_ms() is not available in R.")
}

#' DuckDB function make_timestamp_ns
#'
#' The timestamp for the given nanoseconds since epoch.
#'
#' @name make_timestamp_ns
#' @usage make_timestamp_ns(nanos = BIGINT)
#' @param nanos `BIGINT`
#' @examples
#' \dontrun{
#' make_timestamp_ns(1732117793000000000)
#' }
make_timestamp_ns <- function(nanos = BIGINT) {
  stop("DuckDB function make_timestamp_ns() is not available in R.")
}

#' DuckDB function map
#'
#' Creates a map from a set of keys and values.
#'
#' @name map
#' @usage NULL
#' @param keys `K[]`
#' @param values `V[]`
#' @examples
#' \dontrun{
#' map(['key1', 'key2'], ['val1', 'val2'])
#' }
map <- function(keys = `K[]`, values = `V[]`) {
  stop("DuckDB function map() is not available in R.")
}

#' DuckDB function map_contains
#'
#' Checks if a map contains a given key.
#'
#' @name map_contains
#' @usage map_contains(map = `MAP(K, V)`, key = K)
#' @param map `MAP(K, V)`
#' @param key `K`
#' @examples
#' \dontrun{
#' map_contains(MAP {'key1': 10, 'key2': 20, 'key3': 30}, 'key2')
#' }
map_contains <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function map_contains() is not available in R.")
}

#' DuckDB function map_entries
#'
#' Returns the map entries as a list of keys/values.
#'
#' @name map_entries
#' @usage map_entries(map = `MAP(K, V)`)
#' @param map `MAP(K, V)`
#' @examples
#' \dontrun{
#' map_entries(map(['key'], ['val']))
#' }
map_entries <- function(map = `MAP(K, V)`) {
  stop("DuckDB function map_entries() is not available in R.")
}

#' DuckDB function map_extract
#'
#' Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the mapâ€™s keys else an error is returned.
#'
#' @name map_extract
#' @usage map_extract(map = `MAP(K, V)`, key = K)
#' @param map `MAP(K, V)`
#' @param key `K`
#' @examples
#' \dontrun{
#' map_extract(map(['key'], ['val']), 'key')
#' }
map_extract <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function map_extract() is not available in R.")
}

#' DuckDB function map_extract_value
#'
#' Returns the value for a given key or NULL if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the mapâ€™s keys else an error is returned.
#'
#' @name map_extract_value
#' @usage map_extract_value(map = `MAP(K, V)`, key = K)
#' @param map `MAP(K, V)`
#' @param key `K`
#' @examples
#' \dontrun{
#' map_extract_value(map(['key'], ['val']), 'key')
#' }
map_extract_value <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function map_extract_value() is not available in R.")
}

#' DuckDB function map_from_entries
#'
#' Returns a map created from the entries of the array.
#'
#' @name map_from_entries
#' @usage map_from_entries(map = `STRUCT(K, V)[]`)
#' @param map `STRUCT(K, V)[]`
#' @examples
#' \dontrun{
#' map_from_entries([{k: 5, v: 'val1'}, {k: 3, v: 'val2'}]);
#' }
map_from_entries <- function(map = `STRUCT(K, V)[]`) {
  stop("DuckDB function map_from_entries() is not available in R.")
}

#' DuckDB function map_keys
#'
#' Returns the keys of a map as a list.
#'
#' @name map_keys
#' @usage map_keys(map = `MAP(K, V)`)
#' @param map `MAP(K, V)`
#' @examples
#' \dontrun{
#' map_keys(map(['key'], ['val']))
#' }
map_keys <- function(map = `MAP(K, V)`) {
  stop("DuckDB function map_keys() is not available in R.")
}

#' DuckDB function map_values
#'
#' Returns the values of a map as a list.
#'
#' @name map_values
#' @usage map_values(map = `MAP(K, V)`)
#' @param map `MAP(K, V)`
#' @examples
#' \dontrun{
#' map_values(map(['key'], ['val']))
#' }
map_values <- function(map = `MAP(K, V)`) {
  stop("DuckDB function map_values() is not available in R.")
}

#' DuckDB function mismatches
#'
#' The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length. Strings must be of equal length. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name mismatches
#' @usage mismatches(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' mismatches('duck', 'luck')
#' }
mismatches <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function mismatches() is not available in R.")
}

#' DuckDB function monthname
#'
#' The (English) name of the month.
#'
#' @name monthname
#' @usage NULL
#' @param ts `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @examples
#' \dontrun{
#' monthname(TIMESTAMP '1992-09-20')
#' }
monthname <- function(ts = `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function monthname() is not available in R.")
}

#' DuckDB function nextafter
#'
#' Returns the next floating point value after x in the direction of y.
#'
#' @name nextafter
#' @usage NULL
#' @param x `DOUBLE | FLOAT`
#' @param y `DOUBLE | FLOAT`
#' @examples
#' \dontrun{
#' nextafter(1::float, 2::float)
#' }
nextafter <- function(x = `DOUBLE | FLOAT`, y = `DOUBLE | FLOAT`) {
  stop("DuckDB function nextafter() is not available in R.")
}

#' DuckDB function nfc_normalize
#'
#' Converts `string` to Unicode NFC normalized string. Useful for comparisons and ordering if text data is mixed between NFC normalized and not.
#'
#' @name nfc_normalize
#' @usage nfc_normalize(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' nfc_normalize('ardeÌ€ch')
#' }
nfc_normalize <- function(string = VARCHAR) {
  stop("DuckDB function nfc_normalize() is not available in R.")
}

#' DuckDB function normalized_interval
#'
#' Normalizes an INTERVAL to an equivalent interval.
#'
#' @name normalized_interval
#' @usage normalized_interval(interval = INTERVAL)
#' @param interval `INTERVAL`
#' @examples
#' \dontrun{
#' normalized_interval(INTERVAL '30 days')
#' }
normalized_interval <- function(interval = INTERVAL) {
  stop("DuckDB function normalized_interval() is not available in R.")
}

#' DuckDB function not_ilike_escape
#'
#' Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name not_ilike_escape
#' @usage not_ilike_escape(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR)
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' not_ilike_escape('A%c', 'a$%C', '$')
#' }
not_ilike_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function not_ilike_escape() is not available in R.")
}

#' DuckDB function not_like_escape
#'
#' Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name not_like_escape
#' @usage not_like_escape(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR)
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' not_like_escape('a%c', 'a$%c', '$')
#' }
not_like_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function not_like_escape() is not available in R.")
}

#' DuckDB function ord
#'
#' Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.
#'
#' @name ord
#' @usage ord(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' [unicode('Ã¢bcd'), unicode('Ã¢'), unicode(''), unicode(NULL)]
#' }
ord <- function(string = VARCHAR) {
  stop("DuckDB function ord() is not available in R.")
}

#' DuckDB function parse_dirname
#'
#' Returns the top-level directory name from the given `path`. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.
#'
#' @name parse_dirname
#' @usage NULL
#' @param path `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' parse_dirname('path/to/file.csv', 'system')
#' }
parse_dirname <- function(path = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function parse_dirname() is not available in R.")
}

#' DuckDB function parse_dirpath
#'
#' Returns the head of the `path` (the pathname until the last slash) similarly to Python's `os.path.dirname`. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.
#'
#' @name parse_dirpath
#' @usage NULL
#' @param path `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' parse_dirpath('path/to/file.csv', 'forward_slash')
#' }
parse_dirpath <- function(path = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function parse_dirpath() is not available in R.")
}

#' DuckDB function parse_duckdb_log_message
#'
#' Parse the message into the expected logical type.
#'
#' @name parse_duckdb_log_message
#' @usage parse_duckdb_log_message(type = VARCHAR, message = VARCHAR)
#' @param type `VARCHAR`
#' @param message `VARCHAR`
#' @examples
#' \dontrun{
#' parse_duckdb_log_message('FileSystem', log_message)
#' }
parse_duckdb_log_message <- function(type = VARCHAR, message = VARCHAR) {
  stop("DuckDB function parse_duckdb_log_message() is not available in R.")
}

#' DuckDB function parse_path
#'
#' Returns a list of the components (directories and filename) in the `path` similarly to Python's `pathlib.parts` function. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.
#'
#' @name parse_path
#' @usage NULL
#' @param path `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' parse_path('path/to/file.csv', 'system')
#' }
parse_path <- function(path = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function parse_path() is not available in R.")
}

#' DuckDB function pi
#'
#' Returns the value of pi.
#'
#' @name pi
#' @usage pi()

#' @examples
#' \dontrun{
#' pi()
#' }
pi <- function() {
  stop("DuckDB function pi() is not available in R.")
}

#' DuckDB function position
#'
#' Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.
#'
#' @name position
#' @usage position(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' position('b' IN 'abc')
#' }
position <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function position() is not available in R.")
}

#' DuckDB function pow
#'
#' Computes x to the power of y.
#'
#' @name pow
#' @usage pow(x = DOUBLE, y = DOUBLE)
#' @param x `DOUBLE`
#' @param y `DOUBLE`
#' @examples
#' \dontrun{
#' c("pow(2, 3)", "power(2, 3)")
#' }
pow <- function(x = DOUBLE, y = DOUBLE) {
  stop("DuckDB function pow() is not available in R.")
}

#' DuckDB function power
#'
#' Computes x to the power of y.
#'
#' @name power
#' @usage power(x = DOUBLE, y = DOUBLE)
#' @param x `DOUBLE`
#' @param y `DOUBLE`
#' @examples
#' \dontrun{
#' power(2, 3)
#' }
power <- function(x = DOUBLE, y = DOUBLE) {
  stop("DuckDB function power() is not available in R.")
}

#' DuckDB function prefix
#'
#' Returns `true` if `string` starts with `search_string`.
#'
#' @name prefix
#' @usage prefix(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' prefix('abc', 'ab')
#' }
prefix <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function prefix() is not available in R.")
}

#' DuckDB function radians
#'
#' Converts degrees to radians.
#'
#' @name radians
#' @usage radians(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' radians(90)
#' }
radians <- function(x = DOUBLE) {
  stop("DuckDB function radians() is not available in R.")
}

#' DuckDB function reduce
#'
#' Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.
#'
#' @name reduce
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x,y) `LAMBDA`
#' @param initial_value `ANY`
#' @examples
#' \dontrun{
#' reduce([1, 2, 3], lambda x, y : x + y)
#' }
reduce <- function(list = `ANY[]`, `lambda(x,y)` = LAMBDA, initial_value = ANY) {
  stop("DuckDB function reduce() is not available in R.")
}

#' DuckDB function regexp_escape
#'
#' Escapes special patterns to turn `string` into a regular expression similarly to Python's `re.escape` function.
#'
#' @name regexp_escape
#' @usage regexp_escape(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_escape('https://duckdb.org')
#' }
regexp_escape <- function(string = VARCHAR) {
  stop("DuckDB function regexp_escape() is not available in R.")
}

#' DuckDB function regexp_extract_all
#'
#' Finds non-overlapping occurrences of the `regex` in the `string` and returns the corresponding values of the capturing `group`. A set of optional regex `options` can be set.
#'
#' @name regexp_extract_all
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param group `INTEGER`
#' @param options `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_extract_all('Peter: 33, Paul:14', '(\w+):\s*(\d+)', 2)
#' }
regexp_extract_all <- function(string = VARCHAR, regex = VARCHAR, group = INTEGER, options = VARCHAR) {
  stop("DuckDB function regexp_extract_all() is not available in R.")
}

#' DuckDB function regexp_full_match
#'
#' Returns `true` if the entire `string` matches the `regex`. A set of optional regex `options` can be set.
#'
#' @name regexp_full_match
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param col2 `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_full_match('anabanana', '(an)*')
#' }
regexp_full_match <- function(string = VARCHAR, regex = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function regexp_full_match() is not available in R.")
}

#' DuckDB function regexp_matches
#'
#' Returns `true` if `string` contains the `regex`, `false` otherwise. A set of optional regex `options` can be set.
#'
#' @name regexp_matches
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param options `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_matches('anabanana', '(an)*')
#' }
regexp_matches <- function(string = VARCHAR, regex = VARCHAR, options = VARCHAR) {
  stop("DuckDB function regexp_matches() is not available in R.")
}

#' DuckDB function regexp_replace
#'
#' If `string` contains the `regex`, replaces the matching part with `replacement`. A set of optional regex `options` can be set.
#'
#' @name regexp_replace
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param replacement `VARCHAR`
#' @param options `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_replace('hello', '[lo]', '-')
#' }
regexp_replace <- function(string = VARCHAR, regex = VARCHAR, replacement = VARCHAR, options = VARCHAR) {
  stop("DuckDB function regexp_replace() is not available in R.")
}

#' DuckDB function regexp_split_to_array
#'
#' Splits the `string` along the `regex`. A set of optional regex `options` can be set.
#'
#' @name regexp_split_to_array
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param options `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_split_to_array('hello world; 42', ';? ')
#' }
regexp_split_to_array <- function(string = VARCHAR, regex = VARCHAR, options = VARCHAR) {
  stop("DuckDB function regexp_split_to_array() is not available in R.")
}

#' DuckDB function replace
#'
#' Replaces any occurrences of the `source` with `target` in `string`.
#'
#' @name replace
#' @usage replace(string = VARCHAR, source = VARCHAR, target = VARCHAR)
#' @param string `VARCHAR`
#' @param source `VARCHAR`
#' @param target `VARCHAR`
#' @examples
#' \dontrun{
#' replace('hello', 'l', '-')
#' }
replace <- function(string = VARCHAR, source = VARCHAR, target = VARCHAR) {
  stop("DuckDB function replace() is not available in R.")
}

#' DuckDB function replace_type
#'
#' Casts all fields of type1 to type2.
#'
#' @name replace_type
#' @usage replace_type(param = ANY, type1 = ANY, type2 = ANY)
#' @param param `ANY`
#' @param type1 `ANY`
#' @param type2 `ANY`
#' @examples
#' \dontrun{
#' replace_type({duck: 3.141592653589793::DOUBLE}, NULL::DOUBLE, NULL::DECIMAL(15,2))
#' }
replace_type <- function(param = ANY, type1 = ANY, type2 = ANY) {
  stop("DuckDB function replace_type() is not available in R.")
}

#' DuckDB function reverse
#'
#' Reverses the `string`.
#'
#' @name reverse
#' @usage reverse(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' reverse('hello')
#' }
reverse <- function(string = VARCHAR) {
  stop("DuckDB function reverse() is not available in R.")
}

#' DuckDB function right
#'
#' Extract the right-most `count` characters.
#'
#' @name right
#' @usage right(string = VARCHAR, count = BIGINT)
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' right('HelloðŸ¦†', 3)
#' }
right <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function right() is not available in R.")
}

#' DuckDB function right_grapheme
#'
#' Extracts the right-most `count` grapheme clusters.
#'
#' @name right_grapheme
#' @usage right_grapheme(string = VARCHAR, count = BIGINT)
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' right_grapheme('ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸', 1)
#' }
right_grapheme <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function right_grapheme() is not available in R.")
}

#' DuckDB function rpad
#'
#' Pads the `string` with the `character` on the right until it has `count` characters. Truncates the `string` on the right if it has more than `count` characters.
#'
#' @name rpad
#' @usage rpad(string = VARCHAR, count = INTEGER, character = VARCHAR)
#' @param string `VARCHAR`
#' @param count `INTEGER`
#' @param character `VARCHAR`
#' @examples
#' \dontrun{
#' rpad('hello', 10, '<')
#' }
rpad <- function(string = VARCHAR, count = INTEGER, character = VARCHAR) {
  stop("DuckDB function rpad() is not available in R.")
}

#' DuckDB function rtrim
#'
#' Removes any occurrences of any of the `characters` from the right side of the `string`. `characters` defaults to `space`.
#'
#' @name rtrim
#' @usage NULL
#' @param string `VARCHAR`
#' @param characters `VARCHAR`
#' @examples
#' \dontrun{
#' c("rtrim('    test  ')", "rtrim('>>>>test<<', '><')")
#' }
rtrim <- function(string = VARCHAR, characters = VARCHAR) {
  stop("DuckDB function rtrim() is not available in R.")
}

#' DuckDB function set_bit
#'
#' Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0. Returns a new bitstring.
#'
#' @name set_bit
#' @usage set_bit(bitstring = BIT, index = INTEGER, new_value = INTEGER)
#' @param bitstring `BIT`
#' @param index `INTEGER`
#' @param new_value `INTEGER`
#' @examples
#' \dontrun{
#' set_bit('0110010'::BIT, 2, 0)
#' }
set_bit <- function(bitstring = BIT, index = INTEGER, new_value = INTEGER) {
  stop("DuckDB function set_bit() is not available in R.")
}

#' DuckDB function signbit
#'
#' Returns whether the signbit is set or not.
#'
#' @name signbit
#' @usage NULL
#' @param x `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' signbit(-0.0)
#' }
signbit <- function(x = `FLOAT | DOUBLE`) {
  stop("DuckDB function signbit() is not available in R.")
}

#' DuckDB function sin
#'
#' Computes the sin of x.
#'
#' @name sin
#' @usage sin(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' sin(90)
#' }
sin <- function(x = DOUBLE) {
  stop("DuckDB function sin() is not available in R.")
}

#' DuckDB function sinh
#'
#' Computes the hyperbolic sin of x.
#'
#' @name sinh
#' @usage sinh(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' sinh(1)
#' }
sinh <- function(x = DOUBLE) {
  stop("DuckDB function sinh() is not available in R.")
}

#' DuckDB function split
#'
#' Splits the `string` along the `separator`.
#'
#' @name split
#' @usage split(string = VARCHAR, separator = VARCHAR)
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' split('hello-world', '-')
#' }
split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function split() is not available in R.")
}

#' DuckDB function sqrt
#'
#' Returns the square root of x.
#'
#' @name sqrt
#' @usage sqrt(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' sqrt(4)
#' }
sqrt <- function(x = DOUBLE) {
  stop("DuckDB function sqrt() is not available in R.")
}

#' DuckDB function starts_with
#'
#' Returns `true` if `string` begins with `search_string`.
#'
#' @name starts_with
#' @usage starts_with(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' starts_with('abc', 'a')
#' }
starts_with <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function starts_with() is not available in R.")
}

#' DuckDB function str_split
#'
#' Splits the `string` along the `separator`.
#'
#' @name str_split
#' @usage str_split(string = VARCHAR, separator = VARCHAR)
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' str_split('hello-world', '-')
#' }
str_split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function str_split() is not available in R.")
}

#' DuckDB function str_split_regex
#'
#' Splits the `string` along the `regex`. A set of optional regex `options` can be set.
#'
#' @name str_split_regex
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param options `VARCHAR`
#' @examples
#' \dontrun{
#' str_split_regex('hello world; 42', ';? ')
#' }
str_split_regex <- function(string = VARCHAR, regex = VARCHAR, options = VARCHAR) {
  stop("DuckDB function str_split_regex() is not available in R.")
}

#' DuckDB function string_split
#'
#' Splits the `string` along the `separator`.
#'
#' @name string_split
#' @usage string_split(string = VARCHAR, separator = VARCHAR)
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' string_split('hello-world', '-')
#' }
string_split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function string_split() is not available in R.")
}

#' DuckDB function string_split_regex
#'
#' Splits the `string` along the `regex`. A set of optional regex `options` can be set.
#'
#' @name string_split_regex
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param options `VARCHAR`
#' @examples
#' \dontrun{
#' string_split_regex('hello world; 42', ';? ')
#' }
string_split_regex <- function(string = VARCHAR, regex = VARCHAR, options = VARCHAR) {
  stop("DuckDB function string_split_regex() is not available in R.")
}

#' DuckDB function string_to_array
#'
#' Splits the `string` along the `separator`.
#'
#' @name string_to_array
#' @usage string_to_array(string = VARCHAR, separator = VARCHAR)
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' string_to_array('hello-world', '-')
#' }
string_to_array <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function string_to_array() is not available in R.")
}

#' DuckDB function strip_accents
#'
#' Strips accents from `string`.
#'
#' @name strip_accents
#' @usage strip_accents(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' strip_accents('mÃ¼hleisen')
#' }
strip_accents <- function(string = VARCHAR) {
  stop("DuckDB function strip_accents() is not available in R.")
}

#' DuckDB function strlen
#'
#' Number of bytes in `string`.
#'
#' @name strlen
#' @usage strlen(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' strlen('ðŸ¦†')
#' }
strlen <- function(string = VARCHAR) {
  stop("DuckDB function strlen() is not available in R.")
}

#' DuckDB function strpos
#'
#' Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.
#'
#' @name strpos
#' @usage strpos(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' strpos('test test', 'es')
#' }
strpos <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function strpos() is not available in R.")
}

#' DuckDB function struct_contains
#'
#' Check if an unnamed STRUCT contains the value.
#'
#' @name struct_contains
#' @usage struct_contains(struct = STRUCT, `'entry'` = ANY)
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @examples
#' \dontrun{
#' struct_contains(ROW(3, 3, 0), 3)
#' }
struct_contains <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_contains() is not available in R.")
}

#' DuckDB function struct_extract
#'
#' Extract the named entry from the STRUCT.
#'
#' @name struct_extract
#' @usage NULL
#' @param struct `STRUCT`
#' @param 'entry' `VARCHAR | BIGINT`
#' @examples
#' \dontrun{
#' struct_extract({'i': 3, 'v2': 3, 'v3': 0}, 'i')
#' }
struct_extract <- function(struct = STRUCT, `'entry'` = `VARCHAR | BIGINT`) {
  stop("DuckDB function struct_extract() is not available in R.")
}

#' DuckDB function struct_has
#'
#' Check if an unnamed STRUCT contains the value.
#'
#' @name struct_has
#' @usage struct_has(struct = STRUCT, `'entry'` = ANY)
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @examples
#' \dontrun{
#' struct_has(ROW(3, 3, 0), 3)
#' }
struct_has <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_has() is not available in R.")
}

#' DuckDB function struct_indexof
#'
#' Get the position of the entry in an unnamed STRUCT, starting at 1.
#'
#' @name struct_indexof
#' @usage struct_indexof(struct = STRUCT, `'entry'` = ANY)
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @examples
#' \dontrun{
#' struct_indexof(ROW(3, 3, 0), 3)
#' }
struct_indexof <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_indexof() is not available in R.")
}

#' DuckDB function struct_position
#'
#' Get the position of the entry in an unnamed STRUCT, starting at 1.
#'
#' @name struct_position
#' @usage struct_position(struct = STRUCT, `'entry'` = ANY)
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @examples
#' \dontrun{
#' struct_position(ROW(3, 3, 0), 3)
#' }
struct_position <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_position() is not available in R.")
}

#' DuckDB function substr
#'
#' Extracts substring starting from character `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` characters instead. Note that a `start` value of `1` refers to the first character of the `string`.
#'
#' @name substr
#' @usage NULL
#' @param string `VARCHAR`
#' @param start `BIGINT`
#' @param length `BIGINT`
#' @examples
#' \dontrun{
#' c("substring('Hello', 2)", "substring('Hello', 2, 2)")
#' }
substr <- function(string = VARCHAR, start = BIGINT, length = BIGINT) {
  stop("DuckDB function substr() is not available in R.")
}

#' DuckDB function substring
#'
#' Extracts substring starting from character `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` characters instead. Note that a `start` value of `1` refers to the first character of the `string`.
#'
#' @name substring
#' @usage NULL
#' @param string `VARCHAR`
#' @param start `BIGINT`
#' @param length `BIGINT`
#' @examples
#' \dontrun{
#' c("substring('Hello', 2)", "substring('Hello', 2, 2)")
#' }
substring <- function(string = VARCHAR, start = BIGINT, length = BIGINT) {
  stop("DuckDB function substring() is not available in R.")
}

#' DuckDB function substring_grapheme
#'
#' Extracts substring starting from grapheme clusters `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` grapheme clusters instead. Note that a `start` value of `1` refers to the `first` character of the `string`.
#'
#' @name substring_grapheme
#' @usage NULL
#' @param string `VARCHAR`
#' @param start `BIGINT`
#' @param length `BIGINT`
#' @examples
#' \dontrun{
#' c("substring_grapheme('ðŸ¦†ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸ðŸ¦†', 3)", "substring_grapheme('ðŸ¦†ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸ðŸ¦†', 3, 2)")
#' }
substring_grapheme <- function(string = VARCHAR, start = BIGINT, length = BIGINT) {
  stop("DuckDB function substring_grapheme() is not available in R.")
}

#' DuckDB function suffix
#'
#' Returns `true` if `string` ends with `search_string`.
#'
#' @name suffix
#' @usage suffix(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' suffix('abc', 'bc')
#' }
suffix <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function suffix() is not available in R.")
}

#' DuckDB function tan
#'
#' Computes the tan of x.
#'
#' @name tan
#' @usage tan(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' tan(90)
#' }
tan <- function(x = DOUBLE) {
  stop("DuckDB function tan() is not available in R.")
}

#' DuckDB function tanh
#'
#' Computes the hyperbolic tan of x.
#'
#' @name tanh
#' @usage tanh(x = DOUBLE)
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' tanh(1)
#' }
tanh <- function(x = DOUBLE) {
  stop("DuckDB function tanh() is not available in R.")
}

#' DuckDB function timetz_byte_comparable
#'
#' Converts a TIME WITH TIME ZONE to an integer sort key.
#'
#' @name timetz_byte_comparable
#' @usage timetz_byte_comparable(time_tz = `TIME WITH TIME ZONE`)
#' @param time_tz `TIME WITH TIME ZONE`
#' @examples
#' \dontrun{
#' timetz_byte_comparable('18:18:16.21-07:00'::TIMETZ)
#' }
timetz_byte_comparable <- function(time_tz = `TIME WITH TIME ZONE`) {
  stop("DuckDB function timetz_byte_comparable() is not available in R.")
}

#' DuckDB function to_base
#'
#' Converts `number` to a string in the given base `radix`, optionally padding with leading zeros to `min_length`.
#'
#' @name to_base
#' @usage NULL
#' @param number `BIGINT`
#' @param radix `INTEGER`
#' @param min_length `INTEGER`
#' @examples
#' \dontrun{
#' to_base(42, 16, 5)
#' }
to_base <- function(number = BIGINT, radix = INTEGER, min_length = INTEGER) {
  stop("DuckDB function to_base() is not available in R.")
}

#' DuckDB function to_base64
#'
#' Converts a `blob` to a base64 encoded string.
#'
#' @name to_base64
#' @usage to_base64(blob = BLOB)
#' @param blob `BLOB`
#' @examples
#' \dontrun{
#' to_base64('A'::BLOB)
#' }
to_base64 <- function(blob = BLOB) {
  stop("DuckDB function to_base64() is not available in R.")
}

#' DuckDB function to_centuries
#'
#' Construct a century interval.
#'
#' @name to_centuries
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @examples
#' \dontrun{
#' to_centuries(5)
#' }
to_centuries <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_centuries() is not available in R.")
}

#' DuckDB function to_days
#'
#' Construct a day interval.
#'
#' @name to_days
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @examples
#' \dontrun{
#' to_days(5)
#' }
to_days <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_days() is not available in R.")
}

#' DuckDB function to_decades
#'
#' Construct a decade interval.
#'
#' @name to_decades
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @examples
#' \dontrun{
#' to_decades(5)
#' }
to_decades <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_decades() is not available in R.")
}

#' DuckDB function to_hours
#'
#' Construct a hour interval.
#'
#' @name to_hours
#' @usage to_hours(integer = BIGINT)
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' to_hours(5)
#' }
to_hours <- function(integer = BIGINT) {
  stop("DuckDB function to_hours() is not available in R.")
}

#' DuckDB function to_microseconds
#'
#' Construct a microsecond interval.
#'
#' @name to_microseconds
#' @usage to_microseconds(integer = BIGINT)
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' to_microseconds(5)
#' }
to_microseconds <- function(integer = BIGINT) {
  stop("DuckDB function to_microseconds() is not available in R.")
}

#' DuckDB function to_millennia
#'
#' Construct a millenium interval.
#'
#' @name to_millennia
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @examples
#' \dontrun{
#' to_millennia(1)
#' }
to_millennia <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_millennia() is not available in R.")
}

#' DuckDB function to_milliseconds
#'
#' Construct a millisecond interval.
#'
#' @name to_milliseconds
#' @usage to_milliseconds(double = DOUBLE)
#' @param double `DOUBLE`
#' @examples
#' \dontrun{
#' to_milliseconds(5.5)
#' }
to_milliseconds <- function(double = DOUBLE) {
  stop("DuckDB function to_milliseconds() is not available in R.")
}

#' DuckDB function to_minutes
#'
#' Construct a minute interval.
#'
#' @name to_minutes
#' @usage to_minutes(integer = BIGINT)
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' to_minutes(5)
#' }
to_minutes <- function(integer = BIGINT) {
  stop("DuckDB function to_minutes() is not available in R.")
}

#' DuckDB function to_months
#'
#' Construct a month interval.
#'
#' @name to_months
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @examples
#' \dontrun{
#' to_months(5)
#' }
to_months <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_months() is not available in R.")
}

#' DuckDB function to_quarters
#'
#' Construct a quarter interval.
#'
#' @name to_quarters
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @examples
#' \dontrun{
#' to_quarters(5)
#' }
to_quarters <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_quarters() is not available in R.")
}

#' DuckDB function to_seconds
#'
#' Construct a second interval.
#'
#' @name to_seconds
#' @usage to_seconds(double = DOUBLE)
#' @param double `DOUBLE`
#' @examples
#' \dontrun{
#' to_seconds(5.5)
#' }
to_seconds <- function(double = DOUBLE) {
  stop("DuckDB function to_seconds() is not available in R.")
}

#' DuckDB function to_timestamp
#'
#' Converts secs since epoch to a timestamp with time zone.
#'
#' @name to_timestamp
#' @usage to_timestamp(sec = DOUBLE)
#' @param sec `DOUBLE`
#' @examples
#' \dontrun{
#' to_timestamp(1284352323.5)
#' }
to_timestamp <- function(sec = DOUBLE) {
  stop("DuckDB function to_timestamp() is not available in R.")
}

#' DuckDB function to_weeks
#'
#' Construct a week interval.
#'
#' @name to_weeks
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @examples
#' \dontrun{
#' to_weeks(5)
#' }
to_weeks <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_weeks() is not available in R.")
}

#' DuckDB function to_years
#'
#' Construct a year interval.
#'
#' @name to_years
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @examples
#' \dontrun{
#' to_years(5)
#' }
to_years <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_years() is not available in R.")
}

#' DuckDB function translate
#'
#' Replaces each character in `string` that matches a character in the `from` set with the corresponding character in the `to` set. If `from` is longer than `to`, occurrences of the extra characters in `from` are deleted.
#'
#' @name translate
#' @usage translate(string = VARCHAR, from = VARCHAR, to = VARCHAR)
#' @param string `VARCHAR`
#' @param from `VARCHAR`
#' @param to `VARCHAR`
#' @examples
#' \dontrun{
#' translate('12345', '143', 'ax')
#' }
translate <- function(string = VARCHAR, from = VARCHAR, to = VARCHAR) {
  stop("DuckDB function translate() is not available in R.")
}

#' DuckDB function trim
#'
#' Removes any occurrences of any of the `characters` from either side of the `string`. `characters` defaults to `space`.
#'
#' @name trim
#' @usage NULL
#' @param string `VARCHAR`
#' @param characters `VARCHAR`
#' @examples
#' \dontrun{
#' c("trim('    test  ')", "trim('>>>>test<<', '><')")
#' }
trim <- function(string = VARCHAR, characters = VARCHAR) {
  stop("DuckDB function trim() is not available in R.")
}

#' DuckDB function try_strptime
#'
#' Converts the `string` text to timestamp according to the format string. Returns `NULL` on failure.
#'
#' @name try_strptime
#' @usage NULL
#' @param text `VARCHAR`
#' @param format `VARCHAR | VARCHAR[]`
#' @examples
#' \dontrun{
#' try_strptime('Wed, 1 January 1992 - 08:38:40 PM', '%a, %-d %B %Y - %I:%M:%S %p')
#' }
try_strptime <- function(text = VARCHAR, format = `VARCHAR | VARCHAR[]`) {
  stop("DuckDB function try_strptime() is not available in R.")
}

#' DuckDB function typeof
#'
#' Returns the name of the data type of the result of the expression.
#'
#' @name typeof
#' @usage typeof(expression = ANY)
#' @param expression `ANY`
#' @examples
#' \dontrun{
#' typeof('abc')
#' }
typeof <- function(expression = ANY) {
  stop("DuckDB function typeof() is not available in R.")
}

#' DuckDB function ucase
#'
#' Converts `string` to upper case.
#'
#' @name ucase
#' @usage ucase(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' ucase('Hello')
#' }
ucase <- function(string = VARCHAR) {
  stop("DuckDB function ucase() is not available in R.")
}

#' DuckDB function unbin
#'
#' Converts a `value` from binary representation to a blob.
#'
#' @name unbin
#' @usage unbin(value = VARCHAR)
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' unbin('0110')
#' }
unbin <- function(value = VARCHAR) {
  stop("DuckDB function unbin() is not available in R.")
}

#' DuckDB function unhex
#'
#' Converts a `value` from hexadecimal representation to a blob.
#'
#' @name unhex
#' @usage unhex(value = VARCHAR)
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' unhex('2A')
#' }
unhex <- function(value = VARCHAR) {
  stop("DuckDB function unhex() is not available in R.")
}

#' DuckDB function unicode
#'
#' Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.
#'
#' @name unicode
#' @usage unicode(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' [unicode('Ã¢bcd'), unicode('Ã¢'), unicode(''), unicode(NULL)]
#' }
unicode <- function(string = VARCHAR) {
  stop("DuckDB function unicode() is not available in R.")
}

#' DuckDB function union_extract
#'
#' Extract the value with the named tags from the union. NULL if the tag is not currently selected.
#'
#' @name union_extract
#' @usage union_extract(union = UNION, tag = VARCHAR)
#' @param union `UNION`
#' @param tag `VARCHAR`
#' @examples
#' \dontrun{
#' union_extract(s, 'k')
#' }
union_extract <- function(union = UNION, tag = VARCHAR) {
  stop("DuckDB function union_extract() is not available in R.")
}

#' DuckDB function union_tag
#'
#' Retrieve the currently selected tag of the union as an ENUM.
#'
#' @name union_tag
#' @usage union_tag(union = UNION)
#' @param union `UNION`
#' @examples
#' \dontrun{
#' union_tag(union_value(k := 'foo'))
#' }
union_tag <- function(union = UNION) {
  stop("DuckDB function union_tag() is not available in R.")
}

#' DuckDB function upper
#'
#' Converts `string` to upper case.
#'
#' @name upper
#' @usage upper(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' upper('Hello')
#' }
upper <- function(string = VARCHAR) {
  stop("DuckDB function upper() is not available in R.")
}

#' DuckDB function url_decode
#'
#' Decodes a URL from a representation using Percent-Encoding.
#'
#' @name url_decode
#' @usage url_decode(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' url_decode('https%3A%2F%2Fduckdb.org%2Fwhy_duckdb%23portable')
#' }
url_decode <- function(string = VARCHAR) {
  stop("DuckDB function url_decode() is not available in R.")
}

#' DuckDB function url_encode
#'
#' Encodes a URL to a representation using Percent-Encoding.
#'
#' @name url_encode
#' @usage url_encode(string = VARCHAR)
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' url_encode('this string has/ special+ characters>')
#' }
url_encode <- function(string = VARCHAR) {
  stop("DuckDB function url_encode() is not available in R.")
}

#' DuckDB function uuid_extract_timestamp
#'
#' Extract the timestamp for the given UUID v7.
#'
#' @name uuid_extract_timestamp
#' @usage uuid_extract_timestamp(uuid = UUID)
#' @param uuid `UUID`
#' @examples
#' \dontrun{
#' uuid_extract_timestamp('019482e4-1441-7aad-8127-eec99573b0a0')
#' }
uuid_extract_timestamp <- function(uuid = UUID) {
  stop("DuckDB function uuid_extract_timestamp() is not available in R.")
}

#' DuckDB function uuid_extract_version
#'
#' Extract a version for the given UUID.
#'
#' @name uuid_extract_version
#' @usage uuid_extract_version(uuid = UUID)
#' @param uuid `UUID`
#' @examples
#' \dontrun{
#' uuid_extract_version('019482e4-1441-7aad-8127-eec99573b0a0')
#' }
uuid_extract_version <- function(uuid = UUID) {
  stop("DuckDB function uuid_extract_version() is not available in R.")
}

#' DuckDB function variant_typeof
#'
#' Returns the internal type of the `input_variant`.
#'
#' @name variant_typeof
#' @usage variant_typeof(input_variant = VARIANT)
#' @param input_variant `VARIANT`
#' @examples
#' \dontrun{
#' variant_typeof({'a': 42, 'b': [1,2,3]})
#' }
variant_typeof <- function(input_variant = VARIANT) {
  stop("DuckDB function variant_typeof() is not available in R.")
}

#' DuckDB function vector_type
#'
#' Returns the VectorType of a given column.
#'
#' @name vector_type
#' @usage vector_type(col = ANY)
#' @param col `ANY`
#' @examples
#' \dontrun{
#' vector_type(col)
#' }
vector_type <- function(col = ANY) {
  stop("DuckDB function vector_type() is not available in R.")
}

#' DuckDB function version
#'
#' Returns the currently active version of DuckDB in this format: v0.3.2	.
#'
#' @name version
#' @usage version()

#' @examples
#' \dontrun{
#' version()
#' }
version <- function() {
  stop("DuckDB function version() is not available in R.")
}

