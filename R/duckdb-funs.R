# Generated by do_update_duckdb_funs(), do not edit by hand

#' DuckDB function !__postfix
#'
#' @description
#' Factorial of x. Computes the product of the current integer and all integers below it.
#'
#' @name not-__postfix
#' @usage `!__postfix`(x = INTEGER)
#' @param x `INTEGER`
#' @return `HUGEINT`
#' @examples
#' \dontrun{
#' 4!
#' }
`!__postfix` <- function(x = INTEGER) {
  stop("DuckDB function !__postfix() is not available in R.")
}

#' DuckDB function !~~
#'
#' @description
#' DuckDB function `!~~()`.
#'
#' @name not-~~
#' @usage `!~~`(col0 = VARCHAR, col1 = VARCHAR)
#' @param col0 `VARCHAR`
#' @param col1 `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' character(0)
#' }
`!~~` <- function(col0 = VARCHAR, col1 = VARCHAR) {
  stop("DuckDB function !~~() is not available in R.")
}

#' DuckDB function !~~*
#'
#' @description
#' DuckDB function `!~~*()`.
#'
#' @name not-~~*
#' @usage `!~~*`(col0 = VARCHAR, col1 = VARCHAR)
#' @param col0 `VARCHAR`
#' @param col1 `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' character(0)
#' }
`!~~*` <- function(col0 = VARCHAR, col1 = VARCHAR) {
  stop("DuckDB function !~~*() is not available in R.")
}

#' DuckDB function %
#'
#' @description
#' DuckDB function `%()`.
#'
#' @name %
#' @usage NULL
#' @param col0 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`%` <- function(col0 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function %() is not available in R.")
}

#' DuckDB function &
#'
#' @description
#' Bitwise AND.
#'
#' @name &
#' @usage NULL
#' @param left `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @param right `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @examples
#' \dontrun{
#' 91 & 15
#' }
`&` <- function(left = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`, right = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`) {
  stop("DuckDB function &() is not available in R.")
}

#' DuckDB function &&
#'
#' @description
#' Returns true if the lists have any element in common. NULLs are ignored.
#'
#' @name &&
#' @usage `&&`(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' list_has_any([1, 2, 3], [2, 3, 4])
#' }
`&&` <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function &&() is not available in R.")
}

#' DuckDB function *
#'
#' @description
#' DuckDB function `*()`.
#'
#' @name *
#' @usage NULL
#' @param col0 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | INTERVAL`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | INTERVAL`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | INTERVAL`
#' @examples
#' \dontrun{
#' character(0)
#' }
`*` <- function(col0 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | INTERVAL`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | INTERVAL`) {
  stop("DuckDB function *() is not available in R.")
}

#' DuckDB function **
#'
#' @description
#' Computes x to the power of y.
#'
#' @name **
#' @usage `**`(x = DOUBLE, y = DOUBLE)
#' @param x `DOUBLE`
#' @param y `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' 2 ** 3
#' }
`**` <- function(x = DOUBLE, y = DOUBLE) {
  stop("DuckDB function **() is not available in R.")
}

#' DuckDB function +
#'
#' @description
#' DuckDB function `+()`.
#'
#' @name +
#' @usage NULL
#' @param col0 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | BIGNUM`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | BIGNUM`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | DATE | INTERVAL | TIMESTAMP | TIME | TIME WITH TIME ZONE | TIMESTAMP WITH TIME ZONE | ANY[] | BIGNUM`
#' @examples
#' \dontrun{
#' character(0)
#' }
`+` <- function(col0 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | BIGNUM`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | BIGNUM`) {
  stop("DuckDB function +() is not available in R.")
}

#' DuckDB function -
#'
#' @description
#' DuckDB function `-()`.
#'
#' @name -
#' @usage NULL
#' @param col0 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIGNUM | DATE | TIMESTAMP | INTERVAL | TIME | TIME WITH TIME ZONE`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIGNUM | DATE | TIMESTAMP | INTERVAL`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIGNUM | DATE | INTERVAL | TIMESTAMP | TIME | TIME WITH TIME ZONE`
#' @examples
#' \dontrun{
#' character(0)
#' }
`-` <- function(col0 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIGNUM | DATE | TIMESTAMP | INTERVAL | TIME | TIME WITH TIME ZONE`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIGNUM | DATE | TIMESTAMP | INTERVAL`) {
  stop("DuckDB function -() is not available in R.")
}

#' DuckDB function /
#'
#' @description
#' DuckDB function `/()`.
#'
#' @name /
#' @usage NULL
#' @param col0 `FLOAT | DOUBLE | INTERVAL`
#' @param col1 `FLOAT | DOUBLE`
#' @return `FLOAT | DOUBLE | INTERVAL`
#' @examples
#' \dontrun{
#' character(0)
#' }
`/` <- function(col0 = `FLOAT | DOUBLE | INTERVAL`, col1 = `FLOAT | DOUBLE`) {
  stop("DuckDB function /() is not available in R.")
}

#' DuckDB function //
#'
#' @description
#' DuckDB function `//()`.
#'
#' @name //
#' @usage NULL
#' @param col0 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`//` <- function(col0 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function //() is not available in R.")
}

#' DuckDB function <<
#'
#' @description
#' Bitwise shift left.
#'
#' @name <<
#' @usage NULL
#' @param input `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @examples
#' \dontrun{
#' 1 << 4
#' }
`<<` <- function(input = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function <<() is not available in R.")
}

#' DuckDB function <=>
#'
#' @description
#' Computes the cosine distance between two same-sized lists.
#'
#' @name <=>
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' list_cosine_distance([1, 2, 3], [1, 2, 3])
#' }
`<=>` <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function <=>() is not available in R.")
}

#' DuckDB function <@
#'
#' @description
#' Returns true if all elements of list2 are in list1. NULLs are ignored.
#'
#' @name <-at
#' @usage `<@`(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' list_has_all([1, 2, 3], [2, 3])
#' }
`<@` <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function <@() is not available in R.")
}

#' DuckDB function >>
#'
#' @description
#' Bitwise shift right.
#'
#' @name >>
#' @usage NULL
#' @param input `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @examples
#' \dontrun{
#' 8 >> 2
#' }
`>>` <- function(input = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function >>() is not available in R.")
}

#' DuckDB function @
#'
#' @description
#' Absolute value.
#'
#' @name at-
#' @usage NULL
#' @param x `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @examples
#' \dontrun{
#' abs(-17.4)
#' }
`@` <- function(x = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function @() is not available in R.")
}

#' DuckDB function @>
#'
#' @description
#' Returns true if all elements of list2 are in list1. NULLs are ignored.
#'
#' @name at->
#' @usage `@>`(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' list_has_all([1, 2, 3], [2, 3])
#' }
`@>` <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function @>() is not available in R.")
}

#' DuckDB function ^
#'
#' @description
#' Computes x to the power of y.
#'
#' @name ^
#' @usage `^`(x = DOUBLE, y = DOUBLE)
#' @param x `DOUBLE`
#' @param y `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' 2 ^ 3
#' }
`^` <- function(x = DOUBLE, y = DOUBLE) {
  stop("DuckDB function ^() is not available in R.")
}

#' DuckDB function ^@
#'
#' @description
#' Returns `true` if `string` begins with `search_string`.
#'
#' @name ^-at
#' @usage `^@`(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' starts_with('abc', 'a')
#' }
`^@` <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function ^@() is not available in R.")
}

#' DuckDB function __internal_compress_integral_ubigint
#'
#' @description
#' DuckDB function `__internal_compress_integral_ubigint()`.
#'
#' @name __internal_compress_integral_ubigint
#' @usage NULL
#' @param col0 `HUGEINT | UHUGEINT`
#' @param col1 `HUGEINT | UHUGEINT`
#' @return `UBIGINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_compress_integral_ubigint` <- function(col0 = `HUGEINT | UHUGEINT`, col1 = `HUGEINT | UHUGEINT`) {
  stop("DuckDB function __internal_compress_integral_ubigint() is not available in R.")
}

#' DuckDB function __internal_compress_integral_uinteger
#'
#' @description
#' DuckDB function `__internal_compress_integral_uinteger()`.
#'
#' @name __internal_compress_integral_uinteger
#' @usage NULL
#' @param col0 `BIGINT | HUGEINT | UBIGINT | UHUGEINT`
#' @param col1 `BIGINT | HUGEINT | UBIGINT | UHUGEINT`
#' @return `UINTEGER`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_compress_integral_uinteger` <- function(col0 = `BIGINT | HUGEINT | UBIGINT | UHUGEINT`, col1 = `BIGINT | HUGEINT | UBIGINT | UHUGEINT`) {
  stop("DuckDB function __internal_compress_integral_uinteger() is not available in R.")
}

#' DuckDB function __internal_compress_integral_usmallint
#'
#' @description
#' DuckDB function `__internal_compress_integral_usmallint()`.
#'
#' @name __internal_compress_integral_usmallint
#' @usage NULL
#' @param col0 `INTEGER | BIGINT | HUGEINT | UINTEGER | UBIGINT | UHUGEINT`
#' @param col1 `INTEGER | BIGINT | HUGEINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `USMALLINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_compress_integral_usmallint` <- function(col0 = `INTEGER | BIGINT | HUGEINT | UINTEGER | UBIGINT | UHUGEINT`, col1 = `INTEGER | BIGINT | HUGEINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function __internal_compress_integral_usmallint() is not available in R.")
}

#' DuckDB function __internal_compress_integral_utinyint
#'
#' @description
#' DuckDB function `__internal_compress_integral_utinyint()`.
#'
#' @name __internal_compress_integral_utinyint
#' @usage NULL
#' @param col0 `SMALLINT | INTEGER | BIGINT | HUGEINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @param col1 `SMALLINT | INTEGER | BIGINT | HUGEINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `UTINYINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_compress_integral_utinyint` <- function(col0 = `SMALLINT | INTEGER | BIGINT | HUGEINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`, col1 = `SMALLINT | INTEGER | BIGINT | HUGEINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function __internal_compress_integral_utinyint() is not available in R.")
}

#' DuckDB function __internal_compress_string_hugeint
#'
#' @description
#' DuckDB function `__internal_compress_string_hugeint()`.
#'
#' @name __internal_compress_string_hugeint
#' @usage `__internal_compress_string_hugeint`(col0 = VARCHAR)
#' @param col0 `VARCHAR`
#' @return `HUGEINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_compress_string_hugeint` <- function(col0 = VARCHAR) {
  stop("DuckDB function __internal_compress_string_hugeint() is not available in R.")
}

#' DuckDB function __internal_compress_string_ubigint
#'
#' @description
#' DuckDB function `__internal_compress_string_ubigint()`.
#'
#' @name __internal_compress_string_ubigint
#' @usage `__internal_compress_string_ubigint`(col0 = VARCHAR)
#' @param col0 `VARCHAR`
#' @return `UBIGINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_compress_string_ubigint` <- function(col0 = VARCHAR) {
  stop("DuckDB function __internal_compress_string_ubigint() is not available in R.")
}

#' DuckDB function __internal_compress_string_uhugeint
#'
#' @description
#' DuckDB function `__internal_compress_string_uhugeint()`.
#'
#' @name __internal_compress_string_uhugeint
#' @usage `__internal_compress_string_uhugeint`(col0 = VARCHAR)
#' @param col0 `VARCHAR`
#' @return `UHUGEINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_compress_string_uhugeint` <- function(col0 = VARCHAR) {
  stop("DuckDB function __internal_compress_string_uhugeint() is not available in R.")
}

#' DuckDB function __internal_compress_string_uinteger
#'
#' @description
#' DuckDB function `__internal_compress_string_uinteger()`.
#'
#' @name __internal_compress_string_uinteger
#' @usage `__internal_compress_string_uinteger`(col0 = VARCHAR)
#' @param col0 `VARCHAR`
#' @return `UINTEGER`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_compress_string_uinteger` <- function(col0 = VARCHAR) {
  stop("DuckDB function __internal_compress_string_uinteger() is not available in R.")
}

#' DuckDB function __internal_compress_string_usmallint
#'
#' @description
#' DuckDB function `__internal_compress_string_usmallint()`.
#'
#' @name __internal_compress_string_usmallint
#' @usage `__internal_compress_string_usmallint`(col0 = VARCHAR)
#' @param col0 `VARCHAR`
#' @return `USMALLINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_compress_string_usmallint` <- function(col0 = VARCHAR) {
  stop("DuckDB function __internal_compress_string_usmallint() is not available in R.")
}

#' DuckDB function __internal_compress_string_utinyint
#'
#' @description
#' DuckDB function `__internal_compress_string_utinyint()`.
#'
#' @name __internal_compress_string_utinyint
#' @usage `__internal_compress_string_utinyint`(col0 = VARCHAR)
#' @param col0 `VARCHAR`
#' @return `UTINYINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_compress_string_utinyint` <- function(col0 = VARCHAR) {
  stop("DuckDB function __internal_compress_string_utinyint() is not available in R.")
}

#' DuckDB function __internal_decompress_integral_bigint
#'
#' @description
#' DuckDB function `__internal_decompress_integral_bigint()`.
#'
#' @name __internal_decompress_integral_bigint
#' @usage NULL
#' @param col0 `UTINYINT | USMALLINT | UINTEGER`
#' @param col1 `BIGINT`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_decompress_integral_bigint` <- function(col0 = `UTINYINT | USMALLINT | UINTEGER`, col1 = BIGINT) {
  stop("DuckDB function __internal_decompress_integral_bigint() is not available in R.")
}

#' DuckDB function __internal_decompress_integral_hugeint
#'
#' @description
#' DuckDB function `__internal_decompress_integral_hugeint()`.
#'
#' @name __internal_decompress_integral_hugeint
#' @usage NULL
#' @param col0 `UTINYINT | USMALLINT | UINTEGER | UBIGINT`
#' @param col1 `HUGEINT`
#' @return `HUGEINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_decompress_integral_hugeint` <- function(col0 = `UTINYINT | USMALLINT | UINTEGER | UBIGINT`, col1 = HUGEINT) {
  stop("DuckDB function __internal_decompress_integral_hugeint() is not available in R.")
}

#' DuckDB function __internal_decompress_integral_integer
#'
#' @description
#' DuckDB function `__internal_decompress_integral_integer()`.
#'
#' @name __internal_decompress_integral_integer
#' @usage NULL
#' @param col0 `UTINYINT | USMALLINT`
#' @param col1 `INTEGER`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_decompress_integral_integer` <- function(col0 = `UTINYINT | USMALLINT`, col1 = INTEGER) {
  stop("DuckDB function __internal_decompress_integral_integer() is not available in R.")
}

#' DuckDB function __internal_decompress_integral_smallint
#'
#' @description
#' DuckDB function `__internal_decompress_integral_smallint()`.
#'
#' @name __internal_decompress_integral_smallint
#' @usage `__internal_decompress_integral_smallint`(col0 = UTINYINT, col1 = SMALLINT)
#' @param col0 `UTINYINT`
#' @param col1 `SMALLINT`
#' @return `SMALLINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_decompress_integral_smallint` <- function(col0 = UTINYINT, col1 = SMALLINT) {
  stop("DuckDB function __internal_decompress_integral_smallint() is not available in R.")
}

#' DuckDB function __internal_decompress_integral_ubigint
#'
#' @description
#' DuckDB function `__internal_decompress_integral_ubigint()`.
#'
#' @name __internal_decompress_integral_ubigint
#' @usage NULL
#' @param col0 `UTINYINT | USMALLINT | UINTEGER`
#' @param col1 `UBIGINT`
#' @return `UBIGINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_decompress_integral_ubigint` <- function(col0 = `UTINYINT | USMALLINT | UINTEGER`, col1 = UBIGINT) {
  stop("DuckDB function __internal_decompress_integral_ubigint() is not available in R.")
}

#' DuckDB function __internal_decompress_integral_uhugeint
#'
#' @description
#' DuckDB function `__internal_decompress_integral_uhugeint()`.
#'
#' @name __internal_decompress_integral_uhugeint
#' @usage NULL
#' @param col0 `UTINYINT | USMALLINT | UINTEGER | UBIGINT`
#' @param col1 `UHUGEINT`
#' @return `UHUGEINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_decompress_integral_uhugeint` <- function(col0 = `UTINYINT | USMALLINT | UINTEGER | UBIGINT`, col1 = UHUGEINT) {
  stop("DuckDB function __internal_decompress_integral_uhugeint() is not available in R.")
}

#' DuckDB function __internal_decompress_integral_uinteger
#'
#' @description
#' DuckDB function `__internal_decompress_integral_uinteger()`.
#'
#' @name __internal_decompress_integral_uinteger
#' @usage NULL
#' @param col0 `UTINYINT | USMALLINT`
#' @param col1 `UINTEGER`
#' @return `UINTEGER`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_decompress_integral_uinteger` <- function(col0 = `UTINYINT | USMALLINT`, col1 = UINTEGER) {
  stop("DuckDB function __internal_decompress_integral_uinteger() is not available in R.")
}

#' DuckDB function __internal_decompress_integral_usmallint
#'
#' @description
#' DuckDB function `__internal_decompress_integral_usmallint()`.
#'
#' @name __internal_decompress_integral_usmallint
#' @usage `__internal_decompress_integral_usmallint`(col0 = UTINYINT, col1 = USMALLINT)
#' @param col0 `UTINYINT`
#' @param col1 `USMALLINT`
#' @return `USMALLINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_decompress_integral_usmallint` <- function(col0 = UTINYINT, col1 = USMALLINT) {
  stop("DuckDB function __internal_decompress_integral_usmallint() is not available in R.")
}

#' DuckDB function __internal_decompress_string
#'
#' @description
#' DuckDB function `__internal_decompress_string()`.
#'
#' @name __internal_decompress_string
#' @usage NULL
#' @param col0 `UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | HUGEINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' character(0)
#' }
`__internal_decompress_string` <- function(col0 = `UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | HUGEINT`) {
  stop("DuckDB function __internal_decompress_string() is not available in R.")
}

#' DuckDB function abs
#'
#' @description
#' Absolute value.
#'
#' @name abs
#' @usage NULL
#' @param x `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @examples
#' \dontrun{
#' abs(-17.4)
#' }
abs <- function(x = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function abs() is not available in R.")
}

#' DuckDB function acos
#'
#' @description
#' Computes the arccosine of x.
#'
#' @name acos
#' @usage acos(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' acos(0.5)
#' }
acos <- function(x = DOUBLE) {
  stop("DuckDB function acos() is not available in R.")
}

#' DuckDB function acosh
#'
#' @description
#' Computes the inverse hyperbolic cos of x.
#'
#' @name acosh
#' @usage acosh(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' acosh(2.3)
#' }
acosh <- function(x = DOUBLE) {
  stop("DuckDB function acosh() is not available in R.")
}

#' DuckDB function add
#'
#' @description
#' DuckDB function `add()`.
#'
#' @name add
#' @usage NULL
#' @param col0 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | BIGNUM`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | BIGNUM`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | DATE | INTERVAL | TIMESTAMP | TIME | TIME WITH TIME ZONE | TIMESTAMP WITH TIME ZONE | ANY[] | BIGNUM`
#' @examples
#' \dontrun{
#' character(0)
#' }
add <- function(col0 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | BIGNUM`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | BIGNUM`) {
  stop("DuckDB function add() is not available in R.")
}

#' DuckDB function age
#'
#' @description
#' Subtract arguments, resulting in the time difference between the two timestamps.
#'
#' @name age
#' @usage NULL
#' @param timestamp `TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' age(TIMESTAMP '2001-04-10', TIMESTAMP '1992-09-20')
#' }
age <- function(timestamp = `TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function age() is not available in R.")
}

#' DuckDB function aggregate
#'
#' @description
#' Executes the aggregate function `function_name` on the elements of `list`.
#'
#' @name aggregate
#' @usage aggregate(list = `ANY[]`, function_name = VARCHAR)
#' @param list `ANY[]`
#' @param function_name `VARCHAR`
#' @return `ANY`
#' @examples
#' \dontrun{
#' aggregate([1, 2, NULL], 'min')
#' }
aggregate <- function(list = `ANY[]`, function_name = VARCHAR) {
  stop("DuckDB function aggregate() is not available in R.")
}

#' DuckDB function alias
#'
#' @description
#' Returns the name of a given expression.
#'
#' @name alias
#' @usage alias(expr = ANY)
#' @param expr `ANY`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' alias(42 + 1)
#' }
alias <- function(expr = ANY) {
  stop("DuckDB function alias() is not available in R.")
}

#' DuckDB function any_value
#'
#' @description
#' Returns the first non-NULL value from arg. This function is affected by ordering.
#'
#' @name any_value
#' @usage NULL
#' @param arg `DECIMAL | ANY`
#' @return `DECIMAL | ANY`
#' @examples
#' \dontrun{
#' character(0)
#' }
any_value <- function(arg = `DECIMAL | ANY`) {
  stop("DuckDB function any_value() is not available in R.")
}

#' DuckDB function apply
#'
#' @description
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name apply
#' @usage apply(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' apply([1, 2, 3], lambda x : x + 1)
#' }
apply <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function apply() is not available in R.")
}

#' DuckDB function approx_count_distinct
#'
#' @description
#' Computes the approximate count of distinct elements using HyperLogLog.
#'
#' @name approx_count_distinct
#' @usage approx_count_distinct(any = ANY)
#' @param any `ANY`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' approx_count_distinct(A)
#' }
approx_count_distinct <- function(any = ANY) {
  stop("DuckDB function approx_count_distinct() is not available in R.")
}

#' DuckDB function approx_quantile
#'
#' @description
#' Computes the approximate quantile using T-Digest.
#'
#' @name approx_quantile
#' @usage NULL
#' @param x `DECIMAL | SMALLINT | INTEGER | BIGINT | HUGEINT | DOUBLE | DATE | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TINYINT | FLOAT`
#' @param pos `FLOAT | FLOAT[]`
#' @return `DECIMAL | SMALLINT | INTEGER | BIGINT | HUGEINT | DOUBLE | DATE | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | DECIMAL[] | TINYINT[] | SMALLINT[] | INTEGER[] | BIGINT[] | HUGEINT[] | FLOAT[] | DOUBLE[] | DATE[] | TIME[] | TIME WITH TIME ZONE[] | TIMESTAMP[] | TIMESTAMP WITH TIME ZONE[]`
#' @examples
#' \dontrun{
#' approx_quantile(x, 0.5)
#' }
approx_quantile <- function(x = `DECIMAL | SMALLINT | INTEGER | BIGINT | HUGEINT | DOUBLE | DATE | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TINYINT | FLOAT`, pos = `FLOAT | FLOAT[]`) {
  stop("DuckDB function approx_quantile() is not available in R.")
}

#' DuckDB function approx_top_k
#'
#' @description
#' Finds the k approximately most occurring values in the data set.
#'
#' @name approx_top_k
#' @usage approx_top_k(val = ANY, k = BIGINT)
#' @param val `ANY`
#' @param k `BIGINT`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' approx_top_k(x, 5)
#' }
approx_top_k <- function(val = ANY, k = BIGINT) {
  stop("DuckDB function approx_top_k() is not available in R.")
}

#' DuckDB function arbitrary
#'
#' @description
#' Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.
#'
#' @name arbitrary
#' @usage NULL
#' @param arg `DECIMAL | ANY`
#' @return `DECIMAL | ANY`
#' @examples
#' \dontrun{
#' arbitrary(A)
#' }
arbitrary <- function(arg = `DECIMAL | ANY`) {
  stop("DuckDB function arbitrary() is not available in R.")
}

#' DuckDB function arg_max
#'
#' @description
#' Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.
#'
#' @name arg_max
#' @usage NULL
#' @param arg `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`
#' @param val `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`
#' @param col2 `BIGINT`
#' @return `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY | ANY[]`
#' @examples
#' \dontrun{
#' arg_max(A, B)
#' }
arg_max <- function(arg = `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`, val = `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`, col2 = BIGINT) {
  stop("DuckDB function arg_max() is not available in R.")
}

#' DuckDB function arg_max_null
#'
#' @description
#' Finds the row with the maximum val. Calculates the arg expression at that row.
#'
#' @name arg_max_null
#' @usage NULL
#' @param arg `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`
#' @param val `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`
#' @return `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`
#' @examples
#' \dontrun{
#' arg_max_null(A, B)
#' }
arg_max_null <- function(arg = `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`, val = `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`) {
  stop("DuckDB function arg_max_null() is not available in R.")
}

#' DuckDB function arg_min
#'
#' @description
#' Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.
#'
#' @name arg_min
#' @usage NULL
#' @param arg `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`
#' @param val `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`
#' @param col2 `BIGINT`
#' @return `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY | ANY[]`
#' @examples
#' \dontrun{
#' arg_min(A, B)
#' }
arg_min <- function(arg = `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`, val = `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`, col2 = BIGINT) {
  stop("DuckDB function arg_min() is not available in R.")
}

#' DuckDB function arg_min_null
#'
#' @description
#' Finds the row with the minimum val. Calculates the arg expression at that row.
#'
#' @name arg_min_null
#' @usage NULL
#' @param arg `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`
#' @param val `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`
#' @return `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`
#' @examples
#' \dontrun{
#' arg_min_null(A, B)
#' }
arg_min_null <- function(arg = `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`, val = `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`) {
  stop("DuckDB function arg_min_null() is not available in R.")
}

#' DuckDB function argmax
#'
#' @description
#' Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.
#'
#' @name argmax
#' @usage NULL
#' @param arg `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`
#' @param val `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`
#' @param col2 `BIGINT`
#' @return `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY | ANY[]`
#' @examples
#' \dontrun{
#' argmax(A, B)
#' }
argmax <- function(arg = `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`, val = `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`, col2 = BIGINT) {
  stop("DuckDB function argmax() is not available in R.")
}

#' DuckDB function argmin
#'
#' @description
#' Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.
#'
#' @name argmin
#' @usage NULL
#' @param arg `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`
#' @param val `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`
#' @param col2 `BIGINT`
#' @return `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY | ANY[]`
#' @examples
#' \dontrun{
#' argmin(A, B)
#' }
argmin <- function(arg = `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`, val = `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`, col2 = BIGINT) {
  stop("DuckDB function argmin() is not available in R.")
}

#' DuckDB function array_agg
#'
#' @description
#' Returns a LIST containing all the values of a column.
#'
#' @name array_agg
#' @usage array_agg(arg = T)
#' @param arg `T`
#' @return `T[]`
#' @examples
#' \dontrun{
#' array_agg(A)
#' }
array_agg <- function(arg = T) {
  stop("DuckDB function array_agg() is not available in R.")
}

#' DuckDB function array_aggr
#'
#' @description
#' Executes the aggregate function `function_name` on the elements of `list`.
#'
#' @name array_aggr
#' @usage array_aggr(list = `ANY[]`, function_name = VARCHAR)
#' @param list `ANY[]`
#' @param function_name `VARCHAR`
#' @return `ANY`
#' @examples
#' \dontrun{
#' array_aggr([1, 2, NULL], 'min')
#' }
array_aggr <- function(list = `ANY[]`, function_name = VARCHAR) {
  stop("DuckDB function array_aggr() is not available in R.")
}

#' DuckDB function array_aggregate
#'
#' @description
#' Executes the aggregate function `function_name` on the elements of `list`.
#'
#' @name array_aggregate
#' @usage array_aggregate(list = `ANY[]`, function_name = VARCHAR)
#' @param list `ANY[]`
#' @param function_name `VARCHAR`
#' @return `ANY`
#' @examples
#' \dontrun{
#' array_aggregate([1, 2, NULL], 'min')
#' }
array_aggregate <- function(list = `ANY[]`, function_name = VARCHAR) {
  stop("DuckDB function array_aggregate() is not available in R.")
}

#' DuckDB function array_apply
#'
#' @description
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name array_apply
#' @usage array_apply(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' array_apply([1, 2, 3], lambda x : x + 1)
#' }
array_apply <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function array_apply() is not available in R.")
}

#' DuckDB function array_cat
#'
#' @description
#' Concatenates lists. `NULL` inputs are skipped. See also operator `||`.
#'
#' @name array_cat
#' @usage array_cat()

#' @return `ANY[]`
#' @examples
#' \dontrun{
#' array_cat([2, 3], [4, 5, 6], [7])
#' }
array_cat <- function() {
  stop("DuckDB function array_cat() is not available in R.")
}

#' DuckDB function array_concat
#'
#' @description
#' Concatenates lists. `NULL` inputs are skipped. See also operator `||`.
#'
#' @name array_concat
#' @usage array_concat()

#' @return `ANY[]`
#' @examples
#' \dontrun{
#' array_concat([2, 3], [4, 5, 6], [7])
#' }
array_concat <- function() {
  stop("DuckDB function array_concat() is not available in R.")
}

#' DuckDB function array_contains
#'
#' @description
#' Returns true if the list contains the element.
#'
#' @name array_contains
#' @usage array_contains(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' array_contains([1, 2, NULL], 1)
#' }
array_contains <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_contains() is not available in R.")
}

#' DuckDB function array_cosine_distance
#'
#' @description
#' Computes the cosine distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_cosine_distance
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' array_cosine_distance(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_cosine_distance <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_cosine_distance() is not available in R.")
}

#' DuckDB function array_cosine_similarity
#'
#' @description
#' Computes the cosine similarity between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_cosine_similarity
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' array_cosine_similarity(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_cosine_similarity <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_cosine_similarity() is not available in R.")
}

#' DuckDB function array_cross_product
#'
#' @description
#' Computes the cross product of two arrays of size 3. The array elements can not be `NULL`.
#'
#' @name array_cross_product
#' @usage NULL
#' @param array `FLOAT[3] | DOUBLE[3]`
#' @return `FLOAT[3] | DOUBLE[3]`
#' @examples
#' \dontrun{
#' array_cross_product(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_cross_product <- function(array = `FLOAT[3] | DOUBLE[3]`) {
  stop("DuckDB function array_cross_product() is not available in R.")
}

#' DuckDB function array_distance
#'
#' @description
#' Computes the distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_distance
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' array_distance(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_distance <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_distance() is not available in R.")
}

#' DuckDB function array_distinct
#'
#' @description
#' Removes all duplicates and `NULL` values from a list. Does not preserve the original order.
#'
#' @name array_distinct
#' @usage array_distinct(list = `T[]`)
#' @param list `T[]`
#' @return `T[]`
#' @examples
#' \dontrun{
#' array_distinct([1, 1, NULL, -3, 1, 5])
#' }
array_distinct <- function(list = `T[]`) {
  stop("DuckDB function array_distinct() is not available in R.")
}

#' DuckDB function array_dot_product
#'
#' @description
#' Computes the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_dot_product
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' array_dot_product(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_dot_product <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_dot_product() is not available in R.")
}

#' DuckDB function array_extract
#'
#' @description
#' Extracts a single character from a `string` using a (1-based) `index`.
#'
#' Extracts the named `entry` from the `STRUCT`.
#'
#' Extracts the entry from an unnamed `STRUCT` (tuple) using an index (1-based).
#'
#' @name array_extract
#' @usage NULL
#' @param col0 `T[]`
#' @param col1 `BIGINT`
#' @param string `VARCHAR`
#' @param index `BIGINT`
#' @param struct `STRUCT`
#' @param entry `VARCHAR`
#' @return `T | VARCHAR | ANY`
#' @examples
#' \dontrun{
#' character(0)
#' array_extract('DuckDB', 2)
#' array_extract({'i': 3, 'v2': 3, 'v3': 0}, 'i')
#' array_extract(row(42, 84), 1)
#' }
array_extract <- function(col0 = `T[]`, col1 = BIGINT, string = VARCHAR, index = BIGINT, struct = STRUCT, entry = VARCHAR) {
  stop("DuckDB function array_extract() is not available in R.")
}

#' DuckDB function array_filter
#'
#' @description
#' Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.
#'
#' @name array_filter
#' @usage array_filter(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' array_filter([3, 4, 5], lambda x : x > 4)
#' }
array_filter <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function array_filter() is not available in R.")
}

#' DuckDB function array_grade_up
#'
#' @description
#' Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.
#'
#' @name array_grade_up
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @param col2 `VARCHAR`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' array_grade_up([3, 6, 1, 2])
#' }
array_grade_up <- function(list = `ANY[]`, col1 = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function array_grade_up() is not available in R.")
}

#' DuckDB function array_has
#'
#' @description
#' Returns true if the list contains the element.
#'
#' @name array_has
#' @usage array_has(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' array_has([1, 2, NULL], 1)
#' }
array_has <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_has() is not available in R.")
}

#' DuckDB function array_has_all
#'
#' @description
#' Returns true if all elements of list2 are in list1. NULLs are ignored.
#'
#' @name array_has_all
#' @usage array_has_all(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' array_has_all([1, 2, 3], [2, 3])
#' }
array_has_all <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function array_has_all() is not available in R.")
}

#' DuckDB function array_has_any
#'
#' @description
#' Returns true if the lists have any element in common. NULLs are ignored.
#'
#' @name array_has_any
#' @usage array_has_any(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' array_has_any([1, 2, 3], [2, 3, 4])
#' }
array_has_any <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function array_has_any() is not available in R.")
}

#' DuckDB function array_indexof
#'
#' @description
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name array_indexof
#' @usage array_indexof(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' array_indexof([1, 2, NULL], 2)
#' }
array_indexof <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_indexof() is not available in R.")
}

#' DuckDB function array_inner_product
#'
#' @description
#' Computes the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_inner_product
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' array_inner_product(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_inner_product <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_inner_product() is not available in R.")
}

#' DuckDB function array_length
#'
#' @description
#' Returns the length of the `list`.
#'
#' `array_length` for lists with dimensions other than 1 not implemented.
#'
#' @name array_length
#' @usage NULL
#' @param list `ANY[]`
#' @param dimension `BIGINT`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' array_length([1, 2, 3])
#' }
array_length <- function(list = `ANY[]`, dimension = BIGINT) {
  stop("DuckDB function array_length() is not available in R.")
}

#' DuckDB function array_negative_dot_product
#'
#' @description
#' Computes the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_negative_dot_product
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' array_negative_dot_product(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_negative_dot_product <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_negative_dot_product() is not available in R.")
}

#' DuckDB function array_negative_inner_product
#'
#' @description
#' Computes the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.
#'
#' @name array_negative_inner_product
#' @usage NULL
#' @param array1 `FLOAT[ANY] | DOUBLE[ANY]`
#' @param array2 `FLOAT[ANY] | DOUBLE[ANY]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' array_negative_inner_product(array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT), array_value(2.0::FLOAT, 3.0::FLOAT, 4.0::FLOAT))
#' }
array_negative_inner_product <- function(array1 = `FLOAT[ANY] | DOUBLE[ANY]`, array2 = `FLOAT[ANY] | DOUBLE[ANY]`) {
  stop("DuckDB function array_negative_inner_product() is not available in R.")
}

#' DuckDB function array_position
#'
#' @description
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name array_position
#' @usage array_position(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' array_position([1, 2, NULL], 2)
#' }
array_position <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_position() is not available in R.")
}

#' DuckDB function array_reduce
#'
#' @description
#' Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.
#'
#' @name array_reduce
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x,y) `LAMBDA`
#' @param initial_value `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' array_reduce([1, 2, 3], lambda x, y : x + y)
#' }
array_reduce <- function(list = `ANY[]`, `lambda(x,y)` = LAMBDA, initial_value = ANY) {
  stop("DuckDB function array_reduce() is not available in R.")
}

#' DuckDB function array_resize
#'
#' @description
#' Resizes the `list` to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set.
#'
#' @name array_resize
#' @usage NULL
#' @param list `ANY[]`
#' @param size[ `ANY`
#' @param value] `ANY`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' array_resize([1, 2, 3], 5, 0)
#' }
array_resize <- function(list = `ANY[]`, `size[` = ANY, `value]` = ANY) {
  stop("DuckDB function array_resize() is not available in R.")
}

#' DuckDB function array_reverse_sort
#'
#' @description
#' Sorts the elements of the list in reverse order.
#'
#' @name array_reverse_sort
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' array_reverse_sort([3, 6, 1, 2])
#' }
array_reverse_sort <- function(list = `ANY[]`, col1 = VARCHAR) {
  stop("DuckDB function array_reverse_sort() is not available in R.")
}

#' DuckDB function array_select
#'
#' @description
#' Returns a list based on the elements selected by the `index_list`.
#'
#' @name array_select
#' @usage array_select(value_list = `T[]`, index_list = `BIGINT[]`)
#' @param value_list `T[]`
#' @param index_list `BIGINT[]`
#' @return `T[]`
#' @examples
#' \dontrun{
#' array_select([10, 20, 30, 40], [1, 4])
#' }
array_select <- function(value_list = `T[]`, index_list = `BIGINT[]`) {
  stop("DuckDB function array_select() is not available in R.")
}

#' DuckDB function array_slice
#'
#' @description
#' Extracts a sublist or substring using slice conventions. Negative values are accepted.
#'
#' list_slice with added step feature.
#'
#' @name array_slice
#' @usage NULL
#' @param list `ANY`
#' @param begin `ANY`
#' @param end `ANY`
#' @param step `BIGINT`
#' @return `ANY`
#' @examples
#' \dontrun{
#' c("array_slice('DuckDB', 3, 4)", "array_slice('DuckDB', 3, NULL)", "array_slice('DuckDB', 0, -3)")
#' array_slice([4, 5, 6], 1, 3, 2)
#' }
array_slice <- function(list = ANY, begin = ANY, end = ANY, step = BIGINT) {
  stop("DuckDB function array_slice() is not available in R.")
}

#' DuckDB function array_sort
#'
#' @description
#' Sorts the elements of the list.
#'
#' @name array_sort
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @param col2 `VARCHAR`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' array_sort([3, 6, 1, 2])
#' }
array_sort <- function(list = `ANY[]`, col1 = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function array_sort() is not available in R.")
}

#' DuckDB function array_transform
#'
#' @description
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name array_transform
#' @usage array_transform(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' array_transform([1, 2, 3], lambda x : x + 1)
#' }
array_transform <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function array_transform() is not available in R.")
}

#' DuckDB function array_unique
#'
#' @description
#' Counts the unique elements of a `list`.
#'
#' @name array_unique
#' @usage array_unique(list = `ANY[]`)
#' @param list `ANY[]`
#' @return `UBIGINT`
#' @examples
#' \dontrun{
#' array_unique([1, 1, NULL, -3, 1, 5])
#' }
array_unique <- function(list = `ANY[]`) {
  stop("DuckDB function array_unique() is not available in R.")
}

#' DuckDB function array_value
#'
#' @description
#' Creates an `ARRAY` containing the argument values.
#'
#' @name array_value
#' @usage array_value()

#' @return `ARRAY`
#' @examples
#' \dontrun{
#' array_value(1.0::FLOAT, 2.0::FLOAT, 3.0::FLOAT)
#' }
array_value <- function() {
  stop("DuckDB function array_value() is not available in R.")
}

#' DuckDB function array_where
#'
#' @description
#' Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.
#'
#' @name array_where
#' @usage array_where(value_list = `T[]`, mask_list = `BOOLEAN[]`)
#' @param value_list `T[]`
#' @param mask_list `BOOLEAN[]`
#' @return `T[]`
#' @examples
#' \dontrun{
#' array_where([10, 20, 30, 40], [true, false, false, true])
#' }
array_where <- function(value_list = `T[]`, mask_list = `BOOLEAN[]`) {
  stop("DuckDB function array_where() is not available in R.")
}

#' DuckDB function array_zip
#'
#' @description
#' Zips n `LIST`s to a new `LIST` whose length will be that of the longest list. Its elements are structs of n elements from each list `list_1`, …, `list_n`, missing elements are replaced with `NULL`. If `truncate` is set, all lists are truncated to the smallest list length.
#'
#' @name array_zip
#' @usage array_zip()

#' @return `STRUCT[]`
#' @examples
#' \dontrun{
#' c("array_zip([1, 2], [3, 4], [5, 6])", "array_zip([1, 2], [3, 4], [5, 6, 7])", "array_zip([1, 2], [3, 4], [5, 6, 7], true)")
#' }
array_zip <- function() {
  stop("DuckDB function array_zip() is not available in R.")
}

#' DuckDB function ascii
#'
#' @description
#' Returns an integer that represents the Unicode code point of the first character of the `string`.
#'
#' @name ascii
#' @usage ascii(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' ascii('Ω')
#' }
ascii <- function(string = VARCHAR) {
  stop("DuckDB function ascii() is not available in R.")
}

#' DuckDB function asin
#'
#' @description
#' Computes the arcsine of x.
#'
#' @name asin
#' @usage asin(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' asin(0.5)
#' }
asin <- function(x = DOUBLE) {
  stop("DuckDB function asin() is not available in R.")
}

#' DuckDB function asinh
#'
#' @description
#' Computes the inverse hyperbolic sin of x.
#'
#' @name asinh
#' @usage asinh(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' asinh(0.5)
#' }
asinh <- function(x = DOUBLE) {
  stop("DuckDB function asinh() is not available in R.")
}

#' DuckDB function atan
#'
#' @description
#' Computes the arctangent of x.
#'
#' @name atan
#' @usage atan(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' atan(0.5)
#' }
atan <- function(x = DOUBLE) {
  stop("DuckDB function atan() is not available in R.")
}

#' DuckDB function atan2
#'
#' @description
#' Computes the arctangent (y, x).
#'
#' @name atan2
#' @usage atan2(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' atan2(1.0, 0.0)
#' }
atan2 <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function atan2() is not available in R.")
}

#' DuckDB function atanh
#'
#' @description
#' Computes the inverse hyperbolic tan of x.
#'
#' @name atanh
#' @usage atanh(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' atanh(0.5)
#' }
atanh <- function(x = DOUBLE) {
  stop("DuckDB function atanh() is not available in R.")
}

#' DuckDB function avg
#'
#' @description
#' Calculates the average value for all tuples in x.
#'
#' @name avg
#' @usage NULL
#' @param x `DECIMAL | SMALLINT | INTEGER | BIGINT | HUGEINT | INTERVAL | DOUBLE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME | TIME WITH TIME ZONE`
#' @return `DECIMAL | DOUBLE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME | TIME WITH TIME ZONE`
#' @examples
#' \dontrun{
#' SUM(x) / COUNT(*)
#' }
avg <- function(x = `DECIMAL | SMALLINT | INTEGER | BIGINT | HUGEINT | INTERVAL | DOUBLE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME | TIME WITH TIME ZONE`) {
  stop("DuckDB function avg() is not available in R.")
}

#' DuckDB function bar
#'
#' @description
#' Draws a band whose width is proportional to (`x - min`) and equal to `width` characters when `x` = `max`. `width` defaults to 80.
#'
#' @name bar
#' @usage NULL
#' @param x `DOUBLE`
#' @param min `DOUBLE`
#' @param max `DOUBLE`
#' @param width `DOUBLE`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' bar(5, 0, 20, 10)
#' }
bar <- function(x = DOUBLE, min = DOUBLE, max = DOUBLE, width = DOUBLE) {
  stop("DuckDB function bar() is not available in R.")
}

#' DuckDB function base64
#'
#' @description
#' Converts a `blob` to a base64 encoded string.
#'
#' @name base64
#' @usage base64(blob = BLOB)
#' @param blob `BLOB`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' base64('A'::BLOB)
#' }
base64 <- function(blob = BLOB) {
  stop("DuckDB function base64() is not available in R.")
}

#' DuckDB function bin
#'
#' @description
#' Converts the `string` to binary representation.
#'
#' Converts the `value` to binary representation.
#'
#' @name bin
#' @usage NULL
#' @param string `VARCHAR`
#' @param value `BIGNUM | UBIGINT | BIGINT | HUGEINT | UHUGEINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' bin('Aa')
#' bin(42)
#' }
bin <- function(string = VARCHAR, value = `BIGNUM | UBIGINT | BIGINT | HUGEINT | UHUGEINT`) {
  stop("DuckDB function bin() is not available in R.")
}

#' DuckDB function bit_and
#'
#' @description
#' Returns the bitwise AND of all bits in a given expression.
#'
#' @name bit_and
#' @usage NULL
#' @param arg `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @examples
#' \dontrun{
#' bit_and(A)
#' }
bit_and <- function(arg = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`) {
  stop("DuckDB function bit_and() is not available in R.")
}

#' DuckDB function bit_count
#'
#' @description
#' Returns the number of bits that are set.
#'
#' @name bit_count
#' @usage NULL
#' @param x `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | BIT`
#' @return `TINYINT | BIGINT`
#' @examples
#' \dontrun{
#' bit_count(31)
#' }
bit_count <- function(x = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | BIT`) {
  stop("DuckDB function bit_count() is not available in R.")
}

#' DuckDB function bit_length
#'
#' @description
#' Number of bits in a `string`.
#'
#' Returns the bit-length of the `bit` argument.
#'
#' @name bit_length
#' @usage NULL
#' @param string `VARCHAR`
#' @param bit `BIT`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' bit_length('abc')
#' bit_length(42::TINYINT::BIT)
#' }
bit_length <- function(string = VARCHAR, bit = BIT) {
  stop("DuckDB function bit_length() is not available in R.")
}

#' DuckDB function bit_or
#'
#' @description
#' Returns the bitwise OR of all bits in a given expression.
#'
#' @name bit_or
#' @usage NULL
#' @param arg `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @examples
#' \dontrun{
#' bit_or(A)
#' }
bit_or <- function(arg = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`) {
  stop("DuckDB function bit_or() is not available in R.")
}

#' DuckDB function bit_position
#'
#' @description
#' Returns first starting index of the specified substring within bits, or zero if it is not present. The first (leftmost) bit is indexed 1.
#'
#' @name bit_position
#' @usage bit_position(substring = BIT, bitstring = BIT)
#' @param substring `BIT`
#' @param bitstring `BIT`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' bit_position('010'::BIT, '1110101'::BIT)
#' }
bit_position <- function(substring = BIT, bitstring = BIT) {
  stop("DuckDB function bit_position() is not available in R.")
}

#' DuckDB function bit_xor
#'
#' @description
#' Returns the bitwise XOR of all bits in a given expression.
#'
#' @name bit_xor
#' @usage NULL
#' @param arg `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @examples
#' \dontrun{
#' bit_xor(A)
#' }
bit_xor <- function(arg = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`) {
  stop("DuckDB function bit_xor() is not available in R.")
}

#' DuckDB function bitstring
#'
#' @description
#' Pads the bitstring until the specified length.
#'
#' @name bitstring
#' @usage NULL
#' @param bitstring `VARCHAR | BIT`
#' @param length `INTEGER`
#' @return `BIT`
#' @examples
#' \dontrun{
#' bitstring('1010'::BIT, 7)
#' }
bitstring <- function(bitstring = `VARCHAR | BIT`, length = INTEGER) {
  stop("DuckDB function bitstring() is not available in R.")
}

#' DuckDB function bitstring_agg
#'
#' @description
#' Returns a bitstring with bits set for each distinct value.
#'
#' @name bitstring_agg
#' @usage NULL
#' @param arg `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @param col2 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `BIT`
#' @examples
#' \dontrun{
#' bitstring_agg(A)
#' }
bitstring_agg <- function(arg = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`, col2 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function bitstring_agg() is not available in R.")
}

#' DuckDB function bool_and
#'
#' @description
#' Returns TRUE if every input value is TRUE, otherwise FALSE.
#'
#' @name bool_and
#' @usage bool_and(arg = BOOLEAN)
#' @param arg `BOOLEAN`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' bool_and(A)
#' }
bool_and <- function(arg = BOOLEAN) {
  stop("DuckDB function bool_and() is not available in R.")
}

#' DuckDB function bool_or
#'
#' @description
#' Returns TRUE if any input value is TRUE, otherwise FALSE.
#'
#' @name bool_or
#' @usage bool_or(arg = BOOLEAN)
#' @param arg `BOOLEAN`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' bool_or(A)
#' }
bool_or <- function(arg = BOOLEAN) {
  stop("DuckDB function bool_or() is not available in R.")
}

#' DuckDB function can_cast_implicitly
#'
#' @description
#' Whether or not we can implicitly cast from the source type to the other type.
#'
#' @name can_cast_implicitly
#' @usage can_cast_implicitly(source_type = ANY, target_type = ANY)
#' @param source_type `ANY`
#' @param target_type `ANY`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' can_cast_implicitly(NULL::INTEGER, NULL::BIGINT)
#' }
can_cast_implicitly <- function(source_type = ANY, target_type = ANY) {
  stop("DuckDB function can_cast_implicitly() is not available in R.")
}

#' DuckDB function cardinality
#'
#' @description
#' Returns the size of the map (or the number of entries in the map).
#'
#' @name cardinality
#' @usage cardinality(map = ANY)
#' @param map `ANY`
#' @return `UBIGINT`
#' @examples
#' \dontrun{
#' cardinality( map([4, 2], ['a', 'b']) );
#' }
cardinality <- function(map = ANY) {
  stop("DuckDB function cardinality() is not available in R.")
}

#' DuckDB function cast_to_type
#'
#' @description
#' Casts the first argument to the type of the second argument.
#'
#' @name cast_to_type
#' @usage cast_to_type(param = ANY, type = ANY)
#' @param param `ANY`
#' @param type `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' cast_to_type('42', NULL::INTEGER)
#' }
cast_to_type <- function(param = ANY, type = ANY) {
  stop("DuckDB function cast_to_type() is not available in R.")
}

#' DuckDB function cbrt
#'
#' @description
#' Returns the cube root of x.
#'
#' @name cbrt
#' @usage cbrt(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' cbrt(8)
#' }
cbrt <- function(x = DOUBLE) {
  stop("DuckDB function cbrt() is not available in R.")
}

#' DuckDB function ceil
#'
#' @description
#' Rounds the number up.
#'
#' @name ceil
#' @usage NULL
#' @param x `FLOAT | DOUBLE | DECIMAL`
#' @return `FLOAT | DOUBLE | DECIMAL`
#' @examples
#' \dontrun{
#' ceil(17.4)
#' }
ceil <- function(x = `FLOAT | DOUBLE | DECIMAL`) {
  stop("DuckDB function ceil() is not available in R.")
}

#' DuckDB function ceiling
#'
#' @description
#' Rounds the number up.
#'
#' @name ceiling
#' @usage NULL
#' @param x `FLOAT | DOUBLE | DECIMAL`
#' @return `FLOAT | DOUBLE | DECIMAL`
#' @examples
#' \dontrun{
#' ceiling(17.4)
#' }
ceiling <- function(x = `FLOAT | DOUBLE | DECIMAL`) {
  stop("DuckDB function ceiling() is not available in R.")
}

#' DuckDB function century
#'
#' @description
#' Extract the century component from a date or timestamp.
#'
#' @name century
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' century(timestamp '2021-08-03 11:59:44.123456')
#' }
century <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function century() is not available in R.")
}

#' DuckDB function char_length
#'
#' @description
#' Number of characters in `string`.
#'
#' Returns the bit-length of the `bit` argument.
#'
#' Returns the length of the `list`.
#'
#' @name char_length
#' @usage NULL
#' @param string `VARCHAR`
#' @param bit `BIT`
#' @param list `ANY[]`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' char_length('Hello🦆')
#' char_length(42::TINYINT::BIT)
#' char_length([1,2,3])
#' }
char_length <- function(string = VARCHAR, bit = BIT, list = `ANY[]`) {
  stop("DuckDB function char_length() is not available in R.")
}

#' DuckDB function character_length
#'
#' @description
#' Number of characters in `string`.
#'
#' Returns the bit-length of the `bit` argument.
#'
#' Returns the length of the `list`.
#'
#' @name character_length
#' @usage NULL
#' @param string `VARCHAR`
#' @param bit `BIT`
#' @param list `ANY[]`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' character_length('Hello🦆')
#' character_length(42::TINYINT::BIT)
#' character_length([1,2,3])
#' }
character_length <- function(string = VARCHAR, bit = BIT, list = `ANY[]`) {
  stop("DuckDB function character_length() is not available in R.")
}

#' DuckDB function chr
#'
#' @description
#' Returns a character which is corresponding the ASCII code value or Unicode code point.
#'
#' @name chr
#' @usage chr(code_point = INTEGER)
#' @param code_point `INTEGER`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' chr(65)
#' }
chr <- function(code_point = INTEGER) {
  stop("DuckDB function chr() is not available in R.")
}

#' DuckDB function combine
#'
#' @description
#' DuckDB function `combine()`.
#'
#' @name combine
#' @usage combine(col0 = `AGGREGATE_STATE<?>`, col1 = ANY)
#' @param col0 `AGGREGATE_STATE<?>`
#' @param col1 `ANY`
#' @return `AGGREGATE_STATE<?>`
#' @examples
#' \dontrun{
#' character(0)
#' }
combine <- function(col0 = `AGGREGATE_STATE<?>`, col1 = ANY) {
  stop("DuckDB function combine() is not available in R.")
}

#' DuckDB function concat
#'
#' @description
#' Concatenates multiple strings or lists. `NULL` inputs are skipped. See also operator `||`.
#'
#' @name concat
#' @usage concat(value = ANY)
#' @param value `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' c("concat('Hello', ' ', 'World')", "concat([1, 2, 3], NULL, [4, 5, 6])")
#' }
concat <- function(value = ANY) {
  stop("DuckDB function concat() is not available in R.")
}

#' DuckDB function concat_ws
#'
#' @description
#' Concatenates many strings, separated by `separator`. `NULL` inputs are skipped.
#'
#' @name concat_ws
#' @usage concat_ws(separator = VARCHAR, string = ANY)
#' @param separator `VARCHAR`
#' @param string `ANY`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' concat_ws(', ', 'Banana', 'Apple', 'Melon')
#' }
concat_ws <- function(separator = VARCHAR, string = ANY) {
  stop("DuckDB function concat_ws() is not available in R.")
}

#' DuckDB function constant_or_null
#'
#' @description
#' If arg2 is NULL, return NULL. Otherwise, return arg1.
#'
#' @name constant_or_null
#' @usage constant_or_null(arg1 = ANY, arg2 = ANY)
#' @param arg1 `ANY`
#' @param arg2 `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' constant_or_null(42, NULL)
#' }
constant_or_null <- function(arg1 = ANY, arg2 = ANY) {
  stop("DuckDB function constant_or_null() is not available in R.")
}

#' DuckDB function contains
#'
#' @description
#' Returns `true` if `search_string` is found within `string`.
#'
#' @name contains
#' @usage NULL
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @param col0 `T[] | MAP(K, V) | STRUCT`
#' @param col1 `T | K | ANY`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' contains('abc', 'a')
#' character(0)
#' }
contains <- function(string = VARCHAR, search_string = VARCHAR, col0 = `T[] | MAP(K, V) | STRUCT`, col1 = `T | K | ANY`) {
  stop("DuckDB function contains() is not available in R.")
}

#' DuckDB function corr
#'
#' @description
#' Returns the correlation coefficient for non-NULL pairs in a group.
#'
#' @name corr
#' @usage corr(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' COVAR_POP(y, x) / (STDDEV_POP(x) * STDDEV_POP(y))
#' }
corr <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function corr() is not available in R.")
}

#' DuckDB function cos
#'
#' @description
#' Computes the cos of x.
#'
#' @name cos
#' @usage cos(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' cos(90)
#' }
cos <- function(x = DOUBLE) {
  stop("DuckDB function cos() is not available in R.")
}

#' DuckDB function cosh
#'
#' @description
#' Computes the hyperbolic cos of x.
#'
#' @name cosh
#' @usage cosh(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' cosh(1)
#' }
cosh <- function(x = DOUBLE) {
  stop("DuckDB function cosh() is not available in R.")
}

#' DuckDB function cot
#'
#' @description
#' Computes the cotangent of x.
#'
#' @name cot
#' @usage cot(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' cot(0.5)
#' }
cot <- function(x = DOUBLE) {
  stop("DuckDB function cot() is not available in R.")
}

#' DuckDB function count
#'
#' @description
#' Returns the number of non-NULL values in arg.
#'
#' @name count
#' @usage NULL
#' @param arg `ANY`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' count(A)
#' }
count <- function(arg = ANY) {
  stop("DuckDB function count() is not available in R.")
}

#' DuckDB function count_if
#'
#' @description
#' Counts the total number of TRUE values for a boolean column.
#'
#' @name count_if
#' @usage count_if(arg = BOOLEAN)
#' @param arg `BOOLEAN`
#' @return `HUGEINT`
#' @examples
#' \dontrun{
#' count_if(A)
#' }
count_if <- function(arg = BOOLEAN) {
  stop("DuckDB function count_if() is not available in R.")
}

#' DuckDB function count_star
#'
#' @description
#' DuckDB function `count_star()`.
#'
#' @name count_star
#' @usage count_star()

#' @return `BIGINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
count_star <- function() {
  stop("DuckDB function count_star() is not available in R.")
}

#' DuckDB function countif
#'
#' @description
#' Counts the total number of TRUE values for a boolean column.
#'
#' @name countif
#' @usage countif(arg = BOOLEAN)
#' @param arg `BOOLEAN`
#' @return `HUGEINT`
#' @examples
#' \dontrun{
#' countif(A)
#' }
countif <- function(arg = BOOLEAN) {
  stop("DuckDB function countif() is not available in R.")
}

#' DuckDB function covar_pop
#'
#' @description
#' Returns the population covariance of input values.
#'
#' @name covar_pop
#' @usage covar_pop(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' (SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / COUNT(*)
#' }
covar_pop <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function covar_pop() is not available in R.")
}

#' DuckDB function covar_samp
#'
#' @description
#' Returns the sample covariance for non-NULL pairs in a group.
#'
#' @name covar_samp
#' @usage covar_samp(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' (SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / (COUNT(*) - 1)
#' }
covar_samp <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function covar_samp() is not available in R.")
}

#' DuckDB function create_sort_key
#'
#' @description
#' Constructs a binary-comparable sort key based on a set of input parameters and sort qualifiers.
#'
#' @name create_sort_key
#' @usage create_sort_key(parameters... = ANY)
#' @param parameters... `ANY`
#' @return `BLOB`
#' @examples
#' \dontrun{
#' create_sort_key('A', 'DESC')
#' }
create_sort_key <- function(parameters... = ANY) {
  stop("DuckDB function create_sort_key() is not available in R.")
}

#' DuckDB function current_setting
#'
#' @description
#' Returns the current value of the configuration setting.
#'
#' @name current_setting
#' @usage current_setting(setting_name = VARCHAR)
#' @param setting_name `VARCHAR`
#' @return `ANY`
#' @examples
#' \dontrun{
#' current_setting('access_mode')
#' }
current_setting <- function(setting_name = VARCHAR) {
  stop("DuckDB function current_setting() is not available in R.")
}

#' DuckDB function damerau_levenshtein
#'
#' @description
#' Extension of Levenshtein distance to also include transposition of adjacent characters as an allowed edit operation. In other words, the minimum number of edit operations (insertions, deletions, substitutions or transpositions) required to change one string to another. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name damerau_levenshtein
#' @usage damerau_levenshtein(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' damerau_levenshtein('duckdb', 'udckbd')
#' }
damerau_levenshtein <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function damerau_levenshtein() is not available in R.")
}

#' DuckDB function date_diff
#'
#' @description
#' The number of partition boundaries between the timestamps.
#'
#' @name date_diff
#' @usage NULL
#' @param part `VARCHAR`
#' @param startdate `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @param enddate `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' date_diff('hour', TIMESTAMPTZ '1992-09-30 23:59:59', TIMESTAMPTZ '1992-10-01 01:58:00')
#' }
date_diff <- function(part = VARCHAR, startdate = `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`, enddate = `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function date_diff() is not available in R.")
}

#' DuckDB function date_part
#'
#' @description
#' Get subfield (equivalent to extract).
#'
#' @name date_part
#' @usage NULL
#' @param ts `VARCHAR[] | VARCHAR`
#' @param col1 `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`
#' @return `STRUCT() | BIGINT`
#' @examples
#' \dontrun{
#' date_part('minute', TIMESTAMP '1992-09-20 20:38:40')
#' }
date_part <- function(ts = `VARCHAR[] | VARCHAR`, col1 = `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function date_part() is not available in R.")
}

#' DuckDB function date_sub
#'
#' @description
#' The number of complete partitions between the timestamps.
#'
#' @name date_sub
#' @usage NULL
#' @param part `VARCHAR`
#' @param startdate `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @param enddate `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' date_sub('hour', TIMESTAMPTZ '1992-09-30 23:59:59', TIMESTAMPTZ '1992-10-01 01:58:00')
#' }
date_sub <- function(part = VARCHAR, startdate = `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`, enddate = `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function date_sub() is not available in R.")
}

#' DuckDB function date_trunc
#'
#' @description
#' Truncate to specified precision.
#'
#' @name date_trunc
#' @usage NULL
#' @param part `VARCHAR`
#' @param timestamp `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `TIMESTAMP | INTERVAL | TIMESTAMP WITH TIME ZONE`
#' @examples
#' \dontrun{
#' date_trunc('hour', TIMESTAMPTZ '1992-09-20 20:38:40')
#' }
date_trunc <- function(part = VARCHAR, timestamp = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function date_trunc() is not available in R.")
}

#' DuckDB function datediff
#'
#' @description
#' The number of partition boundaries between the timestamps.
#'
#' @name datediff
#' @usage NULL
#' @param part `VARCHAR`
#' @param startdate `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @param enddate `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' datediff('hour', TIMESTAMPTZ '1992-09-30 23:59:59', TIMESTAMPTZ '1992-10-01 01:58:00')
#' }
datediff <- function(part = VARCHAR, startdate = `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`, enddate = `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function datediff() is not available in R.")
}

#' DuckDB function datepart
#'
#' @description
#' Get subfield (equivalent to extract).
#'
#' @name datepart
#' @usage NULL
#' @param ts `VARCHAR[] | VARCHAR`
#' @param col1 `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`
#' @return `STRUCT() | BIGINT`
#' @examples
#' \dontrun{
#' datepart('minute', TIMESTAMP '1992-09-20 20:38:40')
#' }
datepart <- function(ts = `VARCHAR[] | VARCHAR`, col1 = `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function datepart() is not available in R.")
}

#' DuckDB function datesub
#'
#' @description
#' The number of complete partitions between the timestamps.
#'
#' @name datesub
#' @usage NULL
#' @param part `VARCHAR`
#' @param startdate `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @param enddate `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' datesub('hour', TIMESTAMPTZ '1992-09-30 23:59:59', TIMESTAMPTZ '1992-10-01 01:58:00')
#' }
datesub <- function(part = VARCHAR, startdate = `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`, enddate = `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function datesub() is not available in R.")
}

#' DuckDB function datetrunc
#'
#' @description
#' Truncate to specified precision.
#'
#' @name datetrunc
#' @usage NULL
#' @param part `VARCHAR`
#' @param timestamp `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `TIMESTAMP | INTERVAL | TIMESTAMP WITH TIME ZONE`
#' @examples
#' \dontrun{
#' datetrunc('hour', TIMESTAMPTZ '1992-09-20 20:38:40')
#' }
datetrunc <- function(part = VARCHAR, timestamp = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function datetrunc() is not available in R.")
}

#' DuckDB function day
#'
#' @description
#' Extract the day component from a date or timestamp.
#'
#' @name day
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' day(timestamp '2021-08-03 11:59:44.123456')
#' }
day <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function day() is not available in R.")
}

#' DuckDB function dayname
#'
#' @description
#' The (English) name of the weekday.
#'
#' @name dayname
#' @usage NULL
#' @param ts `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' dayname(TIMESTAMP '1992-03-22')
#' }
dayname <- function(ts = `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function dayname() is not available in R.")
}

#' DuckDB function dayofmonth
#'
#' @description
#' Extract the dayofmonth component from a date or timestamp.
#'
#' @name dayofmonth
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' dayofmonth(timestamp '2021-08-03 11:59:44.123456')
#' }
dayofmonth <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function dayofmonth() is not available in R.")
}

#' DuckDB function dayofweek
#'
#' @description
#' Extract the dayofweek component from a date or timestamp.
#'
#' @name dayofweek
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' dayofweek(timestamp '2021-08-03 11:59:44.123456')
#' }
dayofweek <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function dayofweek() is not available in R.")
}

#' DuckDB function dayofyear
#'
#' @description
#' Extract the dayofyear component from a date or timestamp.
#'
#' @name dayofyear
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' dayofyear(timestamp '2021-08-03 11:59:44.123456')
#' }
dayofyear <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function dayofyear() is not available in R.")
}

#' DuckDB function decade
#'
#' @description
#' Extract the decade component from a date or timestamp.
#'
#' @name decade
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' decade(timestamp '2021-08-03 11:59:44.123456')
#' }
decade <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function decade() is not available in R.")
}

#' DuckDB function decode
#'
#' @description
#' Converts `blob` to `VARCHAR`. Fails if `blob` is not valid UTF-8.
#'
#' @name decode
#' @usage decode(blob = BLOB)
#' @param blob `BLOB`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' decode('\xC3\xBC'::BLOB)
#' }
decode <- function(blob = BLOB) {
  stop("DuckDB function decode() is not available in R.")
}

#' DuckDB function degrees
#'
#' @description
#' Converts radians to degrees.
#'
#' @name degrees
#' @usage degrees(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' degrees(pi())
#' }
degrees <- function(x = DOUBLE) {
  stop("DuckDB function degrees() is not available in R.")
}

#' DuckDB function divide
#'
#' @description
#' DuckDB function `divide()`.
#'
#' @name divide
#' @usage NULL
#' @param col0 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
divide <- function(col0 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function divide() is not available in R.")
}

#' DuckDB function editdist3
#'
#' @description
#' The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name editdist3
#' @usage editdist3(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' editdist3('duck', 'db')
#' }
editdist3 <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function editdist3() is not available in R.")
}

#' DuckDB function element_at
#'
#' @description
#' Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the map’s keys else an error is returned.
#'
#' @name element_at
#' @usage element_at(map = `MAP(K, V)`, key = K)
#' @param map `MAP(K, V)`
#' @param key `K`
#' @return `V[]`
#' @examples
#' \dontrun{
#' element_at(map(['key'], ['val']), 'key')
#' }
element_at <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function element_at() is not available in R.")
}

#' DuckDB function encode
#'
#' @description
#' Converts the `string` to `BLOB`. Converts UTF-8 characters into literal encoding.
#'
#' @name encode
#' @usage encode(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `BLOB`
#' @examples
#' \dontrun{
#' encode('my_string_with_ü')
#' }
encode <- function(string = VARCHAR) {
  stop("DuckDB function encode() is not available in R.")
}

#' DuckDB function ends_with
#'
#' @description
#' Returns `true` if `string` ends with `search_string`.
#'
#' @name ends_with
#' @usage ends_with(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' ends_with('abc', 'bc')
#' }
ends_with <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function ends_with() is not available in R.")
}

#' DuckDB function entropy
#'
#' @description
#' Returns the log-2 entropy of count input-values.
#'
#' @name entropy
#' @usage entropy(x = ANY)
#' @param x `ANY`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' character(0)
#' }
entropy <- function(x = ANY) {
  stop("DuckDB function entropy() is not available in R.")
}

#' DuckDB function enum_code
#'
#' @description
#' Returns the numeric value backing the given enum value.
#'
#' @name enum_code
#' @usage enum_code(enum = ANY)
#' @param enum `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' enum_code('happy'::mood)
#' }
enum_code <- function(enum = ANY) {
  stop("DuckDB function enum_code() is not available in R.")
}

#' DuckDB function enum_first
#'
#' @description
#' Returns the first value of the input enum type.
#'
#' @name enum_first
#' @usage enum_first(enum = ANY)
#' @param enum `ANY`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' enum_first(NULL::mood)
#' }
enum_first <- function(enum = ANY) {
  stop("DuckDB function enum_first() is not available in R.")
}

#' DuckDB function enum_last
#'
#' @description
#' Returns the last value of the input enum type.
#'
#' @name enum_last
#' @usage enum_last(enum = ANY)
#' @param enum `ANY`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' enum_last(NULL::mood)
#' }
enum_last <- function(enum = ANY) {
  stop("DuckDB function enum_last() is not available in R.")
}

#' DuckDB function enum_range
#'
#' @description
#' Returns all values of the input enum type as an array.
#'
#' @name enum_range
#' @usage enum_range(enum = ANY)
#' @param enum `ANY`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' enum_range(NULL::mood)
#' }
enum_range <- function(enum = ANY) {
  stop("DuckDB function enum_range() is not available in R.")
}

#' DuckDB function enum_range_boundary
#'
#' @description
#' Returns the range between the two given enum values as an array. The values must be of the same enum type. When the first parameter is NULL, the result starts with the first value of the enum type. When the second parameter is NULL, the result ends with the last value of the enum type.
#'
#' @name enum_range_boundary
#' @usage enum_range_boundary(start = ANY, end = ANY)
#' @param start `ANY`
#' @param end `ANY`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' enum_range_boundary(NULL, 'happy'::mood)
#' }
enum_range_boundary <- function(start = ANY, end = ANY) {
  stop("DuckDB function enum_range_boundary() is not available in R.")
}

#' DuckDB function epoch
#'
#' @description
#' Extract the epoch component from a temporal type.
#'
#' @name epoch
#' @usage NULL
#' @param temporal `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' epoch(timestamp '2021-08-03 11:59:44.123456')
#' }
epoch <- function(temporal = `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function epoch() is not available in R.")
}

#' DuckDB function epoch_ms
#'
#' @description
#' Extract the epoch component in milliseconds from a temporal type.
#'
#' @name epoch_ms
#' @usage NULL
#' @param temporal `DATE | TIMESTAMP | INTERVAL | TIME | TIME_NS | TIME WITH TIME ZONE | TIMESTAMP WITH TIME ZONE | BIGINT`
#' @return `BIGINT | TIMESTAMP`
#' @examples
#' \dontrun{
#' epoch_ms(timestamp '2021-08-03 11:59:44.123456')
#' }
epoch_ms <- function(temporal = `DATE | TIMESTAMP | INTERVAL | TIME | TIME_NS | TIME WITH TIME ZONE | TIMESTAMP WITH TIME ZONE | BIGINT`) {
  stop("DuckDB function epoch_ms() is not available in R.")
}

#' DuckDB function epoch_ns
#'
#' @description
#' Extract the epoch component in nanoseconds from a temporal type.
#'
#' @name epoch_ns
#' @usage NULL
#' @param temporal `DATE | TIMESTAMP | INTERVAL | TIME | TIME_NS | TIME WITH TIME ZONE | TIMESTAMP WITH TIME ZONE | TIMESTAMP_NS`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' epoch_ns(timestamp '2021-08-03 11:59:44.123456')
#' }
epoch_ns <- function(temporal = `DATE | TIMESTAMP | INTERVAL | TIME | TIME_NS | TIME WITH TIME ZONE | TIMESTAMP WITH TIME ZONE | TIMESTAMP_NS`) {
  stop("DuckDB function epoch_ns() is not available in R.")
}

#' DuckDB function epoch_us
#'
#' @description
#' Extract the epoch component in microseconds from a temporal type.
#'
#' @name epoch_us
#' @usage NULL
#' @param temporal `DATE | TIMESTAMP | INTERVAL | TIME | TIME_NS | TIME WITH TIME ZONE | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' epoch_us(timestamp '2021-08-03 11:59:44.123456')
#' }
epoch_us <- function(temporal = `DATE | TIMESTAMP | INTERVAL | TIME | TIME_NS | TIME WITH TIME ZONE | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function epoch_us() is not available in R.")
}

#' DuckDB function equi_width_bins
#'
#' @description
#' Generates bin_count equi-width bins between the min and max. If enabled nice_rounding makes the numbers more readable/less jagged.
#'
#' @name equi_width_bins
#' @usage NULL
#' @param min `BIGINT | DOUBLE | TIMESTAMP | ANY`
#' @param max `BIGINT | DOUBLE | TIMESTAMP | ANY`
#' @param bin_count `BIGINT`
#' @param nice_rounding `BOOLEAN`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' equi_width_bins(0, 10, 2, true)
#' }
equi_width_bins <- function(min = `BIGINT | DOUBLE | TIMESTAMP | ANY`, max = `BIGINT | DOUBLE | TIMESTAMP | ANY`, bin_count = BIGINT, nice_rounding = BOOLEAN) {
  stop("DuckDB function equi_width_bins() is not available in R.")
}

#' DuckDB function era
#'
#' @description
#' Extract the era component from a date or timestamp.
#'
#' @name era
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' era(timestamp '2021-08-03 11:59:44.123456')
#' }
era <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function era() is not available in R.")
}

#' DuckDB function even
#'
#' @description
#' Rounds x to next even number by rounding away from zero.
#'
#' @name even
#' @usage even(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' even(2.9)
#' }
even <- function(x = DOUBLE) {
  stop("DuckDB function even() is not available in R.")
}

#' DuckDB function exp
#'
#' @description
#' Computes e to the power of x.
#'
#' @name exp
#' @usage exp(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' exp(1)
#' }
exp <- function(x = DOUBLE) {
  stop("DuckDB function exp() is not available in R.")
}

#' DuckDB function factorial
#'
#' @description
#' Factorial of x. Computes the product of the current integer and all integers below it.
#'
#' @name factorial
#' @usage factorial(x = INTEGER)
#' @param x `INTEGER`
#' @return `HUGEINT`
#' @examples
#' \dontrun{
#' 4!
#' }
factorial <- function(x = INTEGER) {
  stop("DuckDB function factorial() is not available in R.")
}

#' DuckDB function favg
#'
#' @description
#' Calculates the average using a more accurate floating point summation (Kahan Sum).
#'
#' @name favg
#' @usage favg(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' favg(A)
#' }
favg <- function(x = DOUBLE) {
  stop("DuckDB function favg() is not available in R.")
}

#' DuckDB function filter
#'
#' @description
#' Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.
#'
#' @name filter
#' @usage filter(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' filter([3, 4, 5], lambda x : x > 4)
#' }
filter <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function filter() is not available in R.")
}

#' DuckDB function finalize
#'
#' @description
#' DuckDB function `finalize()`.
#'
#' @name finalize
#' @usage finalize(col0 = `AGGREGATE_STATE<?>`)
#' @param col0 `AGGREGATE_STATE<?>`
#' @return `INVALID`
#' @examples
#' \dontrun{
#' character(0)
#' }
finalize <- function(col0 = `AGGREGATE_STATE<?>`) {
  stop("DuckDB function finalize() is not available in R.")
}

#' DuckDB function first
#'
#' @description
#' Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.
#'
#' @name first
#' @usage NULL
#' @param arg `DECIMAL | ANY`
#' @return `DECIMAL | ANY`
#' @examples
#' \dontrun{
#' first(A)
#' }
first <- function(arg = `DECIMAL | ANY`) {
  stop("DuckDB function first() is not available in R.")
}

#' DuckDB function flatten
#'
#' @description
#' Flattens a nested list by one level.
#'
#' @name flatten
#' @usage flatten(nested_list = `T[][]`)
#' @param nested_list `T[][]`
#' @return `T[]`
#' @examples
#' \dontrun{
#' flatten([[1, 2, 3], [4, 5]])
#' }
flatten <- function(nested_list = `T[][]`) {
  stop("DuckDB function flatten() is not available in R.")
}

#' DuckDB function floor
#'
#' @description
#' Rounds the number down.
#'
#' @name floor
#' @usage NULL
#' @param x `FLOAT | DOUBLE | DECIMAL`
#' @return `FLOAT | DOUBLE | DECIMAL`
#' @examples
#' \dontrun{
#' floor(17.4)
#' }
floor <- function(x = `FLOAT | DOUBLE | DECIMAL`) {
  stop("DuckDB function floor() is not available in R.")
}

#' DuckDB function format
#'
#' @description
#' Formats a string using the fmt syntax.
#'
#' @name format
#' @usage format(format = VARCHAR)
#' @param format `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' format('Benchmark "{}" took {} seconds', 'CSV', 42)
#' }
format <- function(format = VARCHAR) {
  stop("DuckDB function format() is not available in R.")
}

#' DuckDB function formatReadableDecimalSize
#'
#' @description
#' Converts `integer` to a human-readable representation using units based on powers of 10 (KB, MB, GB, etc.).
#'
#' @name formatReadableDecimalSize
#' @usage formatReadableDecimalSize(integer = BIGINT)
#' @param integer `BIGINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' formatReadableDecimalSize(16_000)
#' }
formatReadableDecimalSize <- function(integer = BIGINT) {
  stop("DuckDB function formatReadableDecimalSize() is not available in R.")
}

#' DuckDB function formatReadableSize
#'
#' @description
#' Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).
#'
#' @name formatReadableSize
#' @usage formatReadableSize(integer = BIGINT)
#' @param integer `BIGINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' formatReadableSize(16_000)
#' }
formatReadableSize <- function(integer = BIGINT) {
  stop("DuckDB function formatReadableSize() is not available in R.")
}

#' DuckDB function format_bytes
#'
#' @description
#' Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).
#'
#' @name format_bytes
#' @usage format_bytes(integer = BIGINT)
#' @param integer `BIGINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' format_bytes(16_000)
#' }
format_bytes <- function(integer = BIGINT) {
  stop("DuckDB function format_bytes() is not available in R.")
}

#' DuckDB function from_base64
#'
#' @description
#' Converts a base64 encoded `string` to a character string (`BLOB`).
#'
#' @name from_base64
#' @usage from_base64(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `BLOB`
#' @examples
#' \dontrun{
#' from_base64('QQ==')
#' }
from_base64 <- function(string = VARCHAR) {
  stop("DuckDB function from_base64() is not available in R.")
}

#' DuckDB function from_binary
#'
#' @description
#' Converts a `value` from binary representation to a blob.
#'
#' @name from_binary
#' @usage from_binary(value = VARCHAR)
#' @param value `VARCHAR`
#' @return `BLOB`
#' @examples
#' \dontrun{
#' from_binary('0110')
#' }
from_binary <- function(value = VARCHAR) {
  stop("DuckDB function from_binary() is not available in R.")
}

#' DuckDB function from_hex
#'
#' @description
#' Converts a `value` from hexadecimal representation to a blob.
#'
#' @name from_hex
#' @usage from_hex(value = VARCHAR)
#' @param value `VARCHAR`
#' @return `BLOB`
#' @examples
#' \dontrun{
#' from_hex('2A')
#' }
from_hex <- function(value = VARCHAR) {
  stop("DuckDB function from_hex() is not available in R.")
}

#' DuckDB function fsum
#'
#' @description
#' Calculates the sum using a more accurate floating point summation (Kahan Sum).
#'
#' @name fsum
#' @usage fsum(arg = DOUBLE)
#' @param arg `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' fsum(A)
#' }
fsum <- function(arg = DOUBLE) {
  stop("DuckDB function fsum() is not available in R.")
}

#' DuckDB function gamma
#'
#' @description
#' Interpolation of (x-1) factorial (so decimal inputs are allowed).
#'
#' @name gamma
#' @usage gamma(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' gamma(5.5)
#' }
gamma <- function(x = DOUBLE) {
  stop("DuckDB function gamma() is not available in R.")
}

#' DuckDB function gcd
#'
#' @description
#' Computes the greatest common divisor of x and y.
#'
#' @name gcd
#' @usage NULL
#' @param x `BIGINT | HUGEINT`
#' @param y `BIGINT | HUGEINT`
#' @return `BIGINT | HUGEINT`
#' @examples
#' \dontrun{
#' gcd(42, 57)
#' }
gcd <- function(x = `BIGINT | HUGEINT`, y = `BIGINT | HUGEINT`) {
  stop("DuckDB function gcd() is not available in R.")
}

#' DuckDB function generate_series
#'
#' @description
#' Creates a list of values between `start` and `stop` - the stop parameter is inclusive.
#'
#' @name generate_series
#' @usage NULL
#' @param start `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @param stop `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @param step `BIGINT | INTERVAL`
#' @return `BIGINT[] | TIMESTAMP[] | TIMESTAMP WITH TIME ZONE[]`
#' @examples
#' \dontrun{
#' generate_series(2, 5, 3)
#' }
generate_series <- function(start = `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE`, stop = `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE`, step = `BIGINT | INTERVAL`) {
  stop("DuckDB function generate_series() is not available in R.")
}

#' DuckDB function get_bit
#'
#' @description
#' Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0.
#'
#' @name get_bit
#' @usage get_bit(bitstring = BIT, index = INTEGER)
#' @param bitstring `BIT`
#' @param index `INTEGER`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' get_bit('0110010'::BIT, 2)
#' }
get_bit <- function(bitstring = BIT, index = INTEGER) {
  stop("DuckDB function get_bit() is not available in R.")
}

#' DuckDB function getvariable
#'
#' @description
#' DuckDB function `getvariable()`.
#'
#' @name getvariable
#' @usage getvariable(col0 = VARCHAR)
#' @param col0 `VARCHAR`
#' @return `ANY`
#' @examples
#' \dontrun{
#' character(0)
#' }
getvariable <- function(col0 = VARCHAR) {
  stop("DuckDB function getvariable() is not available in R.")
}

#' DuckDB function grade_up
#'
#' @description
#' Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.
#'
#' @name grade_up
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @param col2 `VARCHAR`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' grade_up([3, 6, 1, 2])
#' }
grade_up <- function(list = `ANY[]`, col1 = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function grade_up() is not available in R.")
}

#' DuckDB function greatest
#'
#' @description
#' Returns the largest value. For strings lexicographical ordering is used. Note that lowercase characters are considered “larger” than uppercase characters and collations are not supported.
#'
#' @name greatest
#' @usage greatest(arg1 = ANY)
#' @param arg1 `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' c("greatest(42, 84)", "greatest('abc', 'bcd', 'cde', 'EFG')")
#' }
greatest <- function(arg1 = ANY) {
  stop("DuckDB function greatest() is not available in R.")
}

#' DuckDB function greatest_common_divisor
#'
#' @description
#' Computes the greatest common divisor of x and y.
#'
#' @name greatest_common_divisor
#' @usage NULL
#' @param x `BIGINT | HUGEINT`
#' @param y `BIGINT | HUGEINT`
#' @return `BIGINT | HUGEINT`
#' @examples
#' \dontrun{
#' greatest_common_divisor(42, 57)
#' }
greatest_common_divisor <- function(x = `BIGINT | HUGEINT`, y = `BIGINT | HUGEINT`) {
  stop("DuckDB function greatest_common_divisor() is not available in R.")
}

#' DuckDB function group_concat
#'
#' @description
#' Concatenates the column string values with an optional separator.
#'
#' @name group_concat
#' @usage NULL
#' @param str `ANY`
#' @param arg `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' group_concat(A, '-')
#' }
group_concat <- function(str = ANY, arg = VARCHAR) {
  stop("DuckDB function group_concat() is not available in R.")
}

#' DuckDB function hamming
#'
#' @description
#' The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length. Strings must be of equal length. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name hamming
#' @usage hamming(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' hamming('duck', 'luck')
#' }
hamming <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function hamming() is not available in R.")
}

#' DuckDB function hash
#'
#' @description
#' Returns a `UBIGINT` with the hash of the `value`. Note that this is not a cryptographic hash.
#'
#' @name hash
#' @usage hash(value = ANY)
#' @param value `ANY`
#' @return `UBIGINT`
#' @examples
#' \dontrun{
#' hash('🦆')
#' }
hash <- function(value = ANY) {
  stop("DuckDB function hash() is not available in R.")
}

#' DuckDB function hex
#'
#' @description
#' Converts the `string` to hexadecimal representation.
#'
#' Converts the `value` to `VARCHAR` using hexadecimal representation.
#'
#' Converts `blob` to `VARCHAR` using hexadecimal encoding.
#'
#' @name hex
#' @usage NULL
#' @param string `VARCHAR`
#' @param value `BIGNUM | BIGINT | UBIGINT | HUGEINT | UHUGEINT`
#' @param blob `BLOB`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' hex('Hello')
#' hex(42)
#' hex('\xAA\xBB'::BLOB)
#' }
hex <- function(string = VARCHAR, value = `BIGNUM | BIGINT | UBIGINT | HUGEINT | UHUGEINT`, blob = BLOB) {
  stop("DuckDB function hex() is not available in R.")
}

#' DuckDB function histogram
#'
#' @description
#' Returns a LIST of STRUCTs with the fields bucket and count.
#'
#' @name histogram
#' @usage NULL
#' @param arg `ANY`
#' @param col1 `ANY[]`
#' @return `MAP`
#' @examples
#' \dontrun{
#' histogram(A)
#' }
histogram <- function(arg = ANY, col1 = `ANY[]`) {
  stop("DuckDB function histogram() is not available in R.")
}

#' DuckDB function histogram_exact
#'
#' @description
#' Returns a LIST of STRUCTs with the fields bucket and count matching the buckets exactly.
#'
#' @name histogram_exact
#' @usage histogram_exact(arg = ANY, bins = `ANY[]`)
#' @param arg `ANY`
#' @param bins `ANY[]`
#' @return `MAP`
#' @examples
#' \dontrun{
#' histogram_exact(A, [0, 1, 2])
#' }
histogram_exact <- function(arg = ANY, bins = `ANY[]`) {
  stop("DuckDB function histogram_exact() is not available in R.")
}

#' DuckDB function hour
#'
#' @description
#' Extract the hour component from a date or timestamp.
#'
#' @name hour
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' hour(timestamp '2021-08-03 11:59:44.123456')
#' }
hour <- function(ts = `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function hour() is not available in R.")
}

#' DuckDB function ilike_escape
#'
#' @description
#' Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name ilike_escape
#' @usage ilike_escape(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR)
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' ilike_escape('A%c', 'a$%C', '$')
#' }
ilike_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function ilike_escape() is not available in R.")
}

#' DuckDB function instr
#'
#' @description
#' Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.
#'
#' @name instr
#' @usage instr(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' instr('test test', 'es')
#' }
instr <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function instr() is not available in R.")
}

#' DuckDB function is_histogram_other_bin
#'
#' @description
#' Whether or not the provided value is the histogram "other" bin (used for values not belonging to any provided bin).
#'
#' @name is_histogram_other_bin
#' @usage is_histogram_other_bin(val = ANY)
#' @param val `ANY`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' is_histogram_other_bin(v)
#' }
is_histogram_other_bin <- function(val = ANY) {
  stop("DuckDB function is_histogram_other_bin() is not available in R.")
}

#' DuckDB function isfinite
#'
#' @description
#' Returns true if the floating point value is finite, false otherwise.
#'
#' @name isfinite
#' @usage NULL
#' @param x `FLOAT | DOUBLE | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' isfinite(5.5)
#' }
isfinite <- function(x = `FLOAT | DOUBLE | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function isfinite() is not available in R.")
}

#' DuckDB function isinf
#'
#' @description
#' Returns true if the floating point value is infinite, false otherwise.
#'
#' @name isinf
#' @usage NULL
#' @param x `FLOAT | DOUBLE | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' isinf('Infinity'::float)
#' }
isinf <- function(x = `FLOAT | DOUBLE | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function isinf() is not available in R.")
}

#' DuckDB function isnan
#'
#' @description
#' Returns true if the floating point value is not a number, false otherwise.
#'
#' @name isnan
#' @usage NULL
#' @param x `FLOAT | DOUBLE`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' isnan('NaN'::FLOAT)
#' }
isnan <- function(x = `FLOAT | DOUBLE`) {
  stop("DuckDB function isnan() is not available in R.")
}

#' DuckDB function isodow
#'
#' @description
#' Extract the isodow component from a date or timestamp.
#'
#' @name isodow
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' isodow(timestamp '2021-08-03 11:59:44.123456')
#' }
isodow <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function isodow() is not available in R.")
}

#' DuckDB function isoyear
#'
#' @description
#' Extract the isoyear component from a date or timestamp.
#'
#' @name isoyear
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' isoyear(timestamp '2021-08-03 11:59:44.123456')
#' }
isoyear <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function isoyear() is not available in R.")
}

#' DuckDB function jaccard
#'
#' @description
#' The Jaccard similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1.
#'
#' @name jaccard
#' @usage jaccard(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' jaccard('duck', 'luck')
#' }
jaccard <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function jaccard() is not available in R.")
}

#' DuckDB function jaro_similarity
#'
#' @description
#' The Jaro similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1. For similarity < `score_cutoff`, 0 is returned instead. `score_cutoff` defaults to 0.
#'
#' @name jaro_similarity
#' @usage NULL
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @param score_cutoff `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' jaro_similarity('duck', 'duckdb')
#' }
jaro_similarity <- function(s1 = VARCHAR, s2 = VARCHAR, score_cutoff = DOUBLE) {
  stop("DuckDB function jaro_similarity() is not available in R.")
}

#' DuckDB function jaro_winkler_similarity
#'
#' @description
#' The Jaro-Winkler similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1. For similarity < `score_cutoff`, 0 is returned instead. `score_cutoff` defaults to 0.
#'
#' @name jaro_winkler_similarity
#' @usage NULL
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @param score_cutoff `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' jaro_winkler_similarity('duck', 'duckdb')
#' }
jaro_winkler_similarity <- function(s1 = VARCHAR, s2 = VARCHAR, score_cutoff = DOUBLE) {
  stop("DuckDB function jaro_winkler_similarity() is not available in R.")
}

#' DuckDB function julian
#'
#' @description
#' Extract the Julian Day number from a date or timestamp.
#'
#' @name julian
#' @usage NULL
#' @param ts `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' julian(timestamp '2006-01-01 12:00')
#' }
julian <- function(ts = `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function julian() is not available in R.")
}

#' DuckDB function kahan_sum
#'
#' @description
#' Calculates the sum using a more accurate floating point summation (Kahan Sum).
#'
#' @name kahan_sum
#' @usage kahan_sum(arg = DOUBLE)
#' @param arg `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' kahan_sum(A)
#' }
kahan_sum <- function(arg = DOUBLE) {
  stop("DuckDB function kahan_sum() is not available in R.")
}

#' DuckDB function kurtosis
#'
#' @description
#' Returns the excess kurtosis (Fisher’s definition) of all input values, with a bias correction according to the sample size.
#'
#' @name kurtosis
#' @usage kurtosis(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' character(0)
#' }
kurtosis <- function(x = DOUBLE) {
  stop("DuckDB function kurtosis() is not available in R.")
}

#' DuckDB function kurtosis_pop
#'
#' @description
#' Returns the excess kurtosis (Fisher’s definition) of all input values, without bias correction.
#'
#' @name kurtosis_pop
#' @usage kurtosis_pop(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' character(0)
#' }
kurtosis_pop <- function(x = DOUBLE) {
  stop("DuckDB function kurtosis_pop() is not available in R.")
}

#' DuckDB function last
#'
#' @description
#' Returns the last value of a column. This function is affected by ordering.
#'
#' @name last
#' @usage NULL
#' @param arg `DECIMAL | ANY`
#' @return `DECIMAL | ANY`
#' @examples
#' \dontrun{
#' last(A)
#' }
last <- function(arg = `DECIMAL | ANY`) {
  stop("DuckDB function last() is not available in R.")
}

#' DuckDB function last_day
#'
#' @description
#' Returns the last day of the month.
#'
#' @name last_day
#' @usage NULL
#' @param ts `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `DATE`
#' @examples
#' \dontrun{
#' last_day(TIMESTAMP '1992-03-22 01:02:03.1234')
#' }
last_day <- function(ts = `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function last_day() is not available in R.")
}

#' DuckDB function lcase
#'
#' @description
#' Converts `string` to lower case.
#'
#' @name lcase
#' @usage lcase(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' lcase('Hello')
#' }
lcase <- function(string = VARCHAR) {
  stop("DuckDB function lcase() is not available in R.")
}

#' DuckDB function lcm
#'
#' @description
#' Computes the least common multiple of x and y.
#'
#' @name lcm
#' @usage NULL
#' @param x `BIGINT | HUGEINT`
#' @param y `BIGINT | HUGEINT`
#' @return `BIGINT | HUGEINT`
#' @examples
#' \dontrun{
#' lcm(42, 57)
#' }
lcm <- function(x = `BIGINT | HUGEINT`, y = `BIGINT | HUGEINT`) {
  stop("DuckDB function lcm() is not available in R.")
}

#' DuckDB function least
#'
#' @description
#' Returns the smallest value. For strings lexicographical ordering is used. Note that uppercase characters are considered “smaller” than lowercase characters, and collations are not supported.
#'
#' @name least
#' @usage least(arg1 = ANY)
#' @param arg1 `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' c("least(42, 84)", "least('abc', 'bcd', 'cde', 'EFG')")
#' }
least <- function(arg1 = ANY) {
  stop("DuckDB function least() is not available in R.")
}

#' DuckDB function least_common_multiple
#'
#' @description
#' Computes the least common multiple of x and y.
#'
#' @name least_common_multiple
#' @usage NULL
#' @param x `BIGINT | HUGEINT`
#' @param y `BIGINT | HUGEINT`
#' @return `BIGINT | HUGEINT`
#' @examples
#' \dontrun{
#' least_common_multiple(42, 57)
#' }
least_common_multiple <- function(x = `BIGINT | HUGEINT`, y = `BIGINT | HUGEINT`) {
  stop("DuckDB function least_common_multiple() is not available in R.")
}

#' DuckDB function left
#'
#' @description
#' Extracts the left-most count characters.
#'
#' @name left
#' @usage left(string = VARCHAR, count = BIGINT)
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' left('Hello🦆', 2)
#' }
left <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function left() is not available in R.")
}

#' DuckDB function left_grapheme
#'
#' @description
#' Extracts the left-most count grapheme clusters.
#'
#' @name left_grapheme
#' @usage left_grapheme(string = VARCHAR, count = BIGINT)
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' left_grapheme('🤦🏼‍♂️🤦🏽‍♀️', 1)
#' }
left_grapheme <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function left_grapheme() is not available in R.")
}

#' DuckDB function len
#'
#' @description
#' Number of characters in `string`.
#'
#' Returns the bit-length of the `bit` argument.
#'
#' Returns the length of the `list`.
#'
#' @name len
#' @usage NULL
#' @param string `VARCHAR`
#' @param bit `BIT`
#' @param list `ANY[]`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' length('Hello🦆')
#' length(42::TINYINT::BIT)
#' length([1,2,3])
#' }
len <- function(string = VARCHAR, bit = BIT, list = `ANY[]`) {
  stop("DuckDB function len() is not available in R.")
}

#' DuckDB function length_grapheme
#'
#' @description
#' Number of grapheme clusters in `string`.
#'
#' @name length_grapheme
#' @usage length_grapheme(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' length_grapheme('🤦🏼‍♂️🤦🏽‍♀️')
#' }
length_grapheme <- function(string = VARCHAR) {
  stop("DuckDB function length_grapheme() is not available in R.")
}

#' DuckDB function levenshtein
#'
#' @description
#' The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name levenshtein
#' @usage levenshtein(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' levenshtein('duck', 'db')
#' }
levenshtein <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function levenshtein() is not available in R.")
}

#' DuckDB function lgamma
#'
#' @description
#' Computes the log of the gamma function.
#'
#' @name lgamma
#' @usage lgamma(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' lgamma(2)
#' }
lgamma <- function(x = DOUBLE) {
  stop("DuckDB function lgamma() is not available in R.")
}

#' DuckDB function like_escape
#'
#' @description
#' Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name like_escape
#' @usage like_escape(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR)
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' like_escape('a%c', 'a$%c', '$')
#' }
like_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function like_escape() is not available in R.")
}

#' DuckDB function list
#'
#' @description
#' Returns a LIST containing all the values of a column.
#'
#' @name list
#' @usage list(arg = T)
#' @param arg `T`
#' @return `T[]`
#' @examples
#' \dontrun{
#' list(A)
#' }
list <- function(arg = T) {
  stop("DuckDB function list() is not available in R.")
}

#' DuckDB function list_aggr
#'
#' @description
#' Executes the aggregate function `function_name` on the elements of `list`.
#'
#' @name list_aggr
#' @usage list_aggr(list = `ANY[]`, function_name = VARCHAR)
#' @param list `ANY[]`
#' @param function_name `VARCHAR`
#' @return `ANY`
#' @examples
#' \dontrun{
#' list_aggregate([1, 2, NULL], 'min')
#' }
list_aggr <- function(list = `ANY[]`, function_name = VARCHAR) {
  stop("DuckDB function list_aggr() is not available in R.")
}

#' DuckDB function list_aggregate
#'
#' @description
#' Executes the aggregate function `function_name` on the elements of `list`.
#'
#' @name list_aggregate
#' @usage list_aggregate(list = `ANY[]`, function_name = VARCHAR)
#' @param list `ANY[]`
#' @param function_name `VARCHAR`
#' @return `ANY`
#' @examples
#' \dontrun{
#' list_aggregate([1, 2, NULL], 'min')
#' }
list_aggregate <- function(list = `ANY[]`, function_name = VARCHAR) {
  stop("DuckDB function list_aggregate() is not available in R.")
}

#' DuckDB function list_apply
#'
#' @description
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name list_apply
#' @usage list_apply(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' list_apply([1, 2, 3], lambda x : x + 1)
#' }
list_apply <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function list_apply() is not available in R.")
}

#' DuckDB function list_cat
#'
#' @description
#' Concatenates lists. `NULL` inputs are skipped. See also operator `||`.
#'
#' @name list_cat
#' @usage list_cat()

#' @return `ANY[]`
#' @examples
#' \dontrun{
#' list_cat([2, 3], [4, 5, 6], [7])
#' }
list_cat <- function() {
  stop("DuckDB function list_cat() is not available in R.")
}

#' DuckDB function list_concat
#'
#' @description
#' Concatenates lists. `NULL` inputs are skipped. See also operator `||`.
#'
#' @name list_concat
#' @usage list_concat()

#' @return `ANY[]`
#' @examples
#' \dontrun{
#' list_concat([2, 3], [4, 5, 6], [7])
#' }
list_concat <- function() {
  stop("DuckDB function list_concat() is not available in R.")
}

#' DuckDB function list_contains
#'
#' @description
#' Returns true if the list contains the element.
#'
#' @name list_contains
#' @usage list_contains(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' list_contains([1, 2, NULL], 1)
#' }
list_contains <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_contains() is not available in R.")
}

#' DuckDB function list_cosine_distance
#'
#' @description
#' Computes the cosine distance between two same-sized lists.
#'
#' @name list_cosine_distance
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' list_cosine_distance([1, 2, 3], [1, 2, 3])
#' }
list_cosine_distance <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_cosine_distance() is not available in R.")
}

#' DuckDB function list_cosine_similarity
#'
#' @description
#' Computes the cosine similarity between two same-sized lists.
#'
#' @name list_cosine_similarity
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' list_cosine_similarity([1, 2, 3], [1, 2, 3])
#' }
list_cosine_similarity <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_cosine_similarity() is not available in R.")
}

#' DuckDB function list_distance
#'
#' @description
#' Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length.
#'
#' @name list_distance
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' list_distance([1, 2, 3], [1, 2, 5])
#' }
list_distance <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_distance() is not available in R.")
}

#' DuckDB function list_distinct
#'
#' @description
#' Removes all duplicates and `NULL` values from a list. Does not preserve the original order.
#'
#' @name list_distinct
#' @usage list_distinct(list = `T[]`)
#' @param list `T[]`
#' @return `T[]`
#' @examples
#' \dontrun{
#' list_distinct([1, 1, NULL, -3, 1, 5])
#' }
list_distinct <- function(list = `T[]`) {
  stop("DuckDB function list_distinct() is not available in R.")
}

#' DuckDB function list_dot_product
#'
#' @description
#' Computes the inner product between two same-sized lists.
#'
#' @name list_dot_product
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' list_dot_product([1, 2, 3], [1, 2, 3])
#' }
list_dot_product <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_dot_product() is not available in R.")
}

#' DuckDB function list_element
#'
#' @description
#' Extract the `index`th (1-based) value from the list.
#'
#' @name list_element
#' @usage NULL
#' @param list `T[] | VARCHAR`
#' @param index `BIGINT`
#' @return `T | VARCHAR`
#' @examples
#' \dontrun{
#' list_element([4, 5, 6], 3)
#' }
list_element <- function(list = `T[] | VARCHAR`, index = BIGINT) {
  stop("DuckDB function list_element() is not available in R.")
}

#' DuckDB function list_extract
#'
#' @description
#' Extract the `index`th (1-based) value from the list.
#'
#' @name list_extract
#' @usage NULL
#' @param list `T[] | VARCHAR`
#' @param index `BIGINT`
#' @return `T | VARCHAR`
#' @examples
#' \dontrun{
#' list_extract([4, 5, 6], 3)
#' }
list_extract <- function(list = `T[] | VARCHAR`, index = BIGINT) {
  stop("DuckDB function list_extract() is not available in R.")
}

#' DuckDB function list_filter
#'
#' @description
#' Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.
#'
#' @name list_filter
#' @usage list_filter(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' list_filter([3, 4, 5], lambda x : x > 4)
#' }
list_filter <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function list_filter() is not available in R.")
}

#' DuckDB function list_grade_up
#'
#' @description
#' Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.
#'
#' @name list_grade_up
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @param col2 `VARCHAR`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' list_grade_up([3, 6, 1, 2])
#' }
list_grade_up <- function(list = `ANY[]`, col1 = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function list_grade_up() is not available in R.")
}

#' DuckDB function list_has
#'
#' @description
#' Returns true if the list contains the element.
#'
#' @name list_has
#' @usage list_has(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' list_has([1, 2, NULL], 1)
#' }
list_has <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_has() is not available in R.")
}

#' DuckDB function list_has_all
#'
#' @description
#' Returns true if all elements of list2 are in list1. NULLs are ignored.
#'
#' @name list_has_all
#' @usage list_has_all(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' list_has_all([1, 2, 3], [2, 3])
#' }
list_has_all <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function list_has_all() is not available in R.")
}

#' DuckDB function list_has_any
#'
#' @description
#' Returns true if the lists have any element in common. NULLs are ignored.
#'
#' @name list_has_any
#' @usage list_has_any(list1 = `T[]`, list2 = `T[]`)
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' list_has_any([1, 2, 3], [2, 3, 4])
#' }
list_has_any <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function list_has_any() is not available in R.")
}

#' DuckDB function list_indexof
#'
#' @description
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name list_indexof
#' @usage list_indexof(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' list_indexof([1, 2, NULL], 2)
#' }
list_indexof <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_indexof() is not available in R.")
}

#' DuckDB function list_inner_product
#'
#' @description
#' Computes the inner product between two same-sized lists.
#'
#' @name list_inner_product
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' list_inner_product([1, 2, 3], [1, 2, 3])
#' }
list_inner_product <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_inner_product() is not available in R.")
}

#' DuckDB function list_negative_dot_product
#'
#' @description
#' Computes the negative inner product between two same-sized lists.
#'
#' @name list_negative_dot_product
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' list_negative_dot_product([1, 2, 3], [1, 2, 3])
#' }
list_negative_dot_product <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_negative_dot_product() is not available in R.")
}

#' DuckDB function list_negative_inner_product
#'
#' @description
#' Computes the negative inner product between two same-sized lists.
#'
#' @name list_negative_inner_product
#' @usage NULL
#' @param list1 `FLOAT[] | DOUBLE[]`
#' @param list2 `FLOAT[] | DOUBLE[]`
#' @return `FLOAT | DOUBLE`
#' @examples
#' \dontrun{
#' list_negative_inner_product([1, 2, 3], [1, 2, 3])
#' }
list_negative_inner_product <- function(list1 = `FLOAT[] | DOUBLE[]`, list2 = `FLOAT[] | DOUBLE[]`) {
  stop("DuckDB function list_negative_inner_product() is not available in R.")
}

#' DuckDB function list_pack
#'
#' @description
#' Creates a LIST containing the argument values.
#'
#' @name list_pack
#' @usage NULL
#' @param any `T`
#' @return `"NULL"[] | T[]`
#' @examples
#' \dontrun{
#' list_pack(4, 5, 6)
#' }
list_pack <- function(any = T) {
  stop("DuckDB function list_pack() is not available in R.")
}

#' DuckDB function list_position
#'
#' @description
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name list_position
#' @usage list_position(list = `T[]`, element = T)
#' @param list `T[]`
#' @param element `T`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' list_position([1, 2, NULL], 2)
#' }
list_position <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_position() is not available in R.")
}

#' DuckDB function list_reduce
#'
#' @description
#' Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.
#'
#' @name list_reduce
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x,y) `LAMBDA`
#' @param initial_value `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' list_reduce([1, 2, 3], lambda x, y : x + y)
#' }
list_reduce <- function(list = `ANY[]`, `lambda(x,y)` = LAMBDA, initial_value = ANY) {
  stop("DuckDB function list_reduce() is not available in R.")
}

#' DuckDB function list_resize
#'
#' @description
#' Resizes the `list` to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set.
#'
#' @name list_resize
#' @usage NULL
#' @param list `ANY[]`
#' @param size[ `ANY`
#' @param value] `ANY`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' list_resize([1, 2, 3], 5, 0)
#' }
list_resize <- function(list = `ANY[]`, `size[` = ANY, `value]` = ANY) {
  stop("DuckDB function list_resize() is not available in R.")
}

#' DuckDB function list_reverse_sort
#'
#' @description
#' Sorts the elements of the list in reverse order.
#'
#' @name list_reverse_sort
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' list_reverse_sort([3, 6, 1, 2])
#' }
list_reverse_sort <- function(list = `ANY[]`, col1 = VARCHAR) {
  stop("DuckDB function list_reverse_sort() is not available in R.")
}

#' DuckDB function list_select
#'
#' @description
#' Returns a list based on the elements selected by the `index_list`.
#'
#' @name list_select
#' @usage list_select(value_list = `T[]`, index_list = `BIGINT[]`)
#' @param value_list `T[]`
#' @param index_list `BIGINT[]`
#' @return `T[]`
#' @examples
#' \dontrun{
#' list_select([10, 20, 30, 40], [1, 4])
#' }
list_select <- function(value_list = `T[]`, index_list = `BIGINT[]`) {
  stop("DuckDB function list_select() is not available in R.")
}

#' DuckDB function list_slice
#'
#' @description
#' Extracts a sublist or substring using slice conventions. Negative values are accepted.
#'
#' list_slice with added step feature.
#'
#' @name list_slice
#' @usage NULL
#' @param list `ANY`
#' @param begin `ANY`
#' @param end `ANY`
#' @param step `BIGINT`
#' @return `ANY`
#' @examples
#' \dontrun{
#' list_slice([4, 5, 6], 2, 3)
#' list_slice([4, 5, 6], 1, 3, 2)
#' }
list_slice <- function(list = ANY, begin = ANY, end = ANY, step = BIGINT) {
  stop("DuckDB function list_slice() is not available in R.")
}

#' DuckDB function list_sort
#'
#' @description
#' Sorts the elements of the list.
#'
#' @name list_sort
#' @usage NULL
#' @param list `ANY[]`
#' @param col1 `VARCHAR`
#' @param col2 `VARCHAR`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' list_sort([3, 6, 1, 2])
#' }
list_sort <- function(list = `ANY[]`, col1 = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function list_sort() is not available in R.")
}

#' DuckDB function list_transform
#'
#' @description
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name list_transform
#' @usage list_transform(list = `ANY[]`, `lambda(x)` = LAMBDA)
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @return `ANY[]`
#' @examples
#' \dontrun{
#' list_transform([1, 2, 3], lambda x : x + 1)
#' }
list_transform <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function list_transform() is not available in R.")
}

#' DuckDB function list_unique
#'
#' @description
#' Counts the unique elements of a `list`.
#'
#' @name list_unique
#' @usage list_unique(list = `ANY[]`)
#' @param list `ANY[]`
#' @return `UBIGINT`
#' @examples
#' \dontrun{
#' list_unique([1, 1, NULL, -3, 1, 5])
#' }
list_unique <- function(list = `ANY[]`) {
  stop("DuckDB function list_unique() is not available in R.")
}

#' DuckDB function list_value
#'
#' @description
#' Creates a LIST containing the argument values.
#'
#' @name list_value
#' @usage NULL
#' @param any `T`
#' @return `"NULL"[] | T[]`
#' @examples
#' \dontrun{
#' list_value(4, 5, 6)
#' }
list_value <- function(any = T) {
  stop("DuckDB function list_value() is not available in R.")
}

#' DuckDB function list_where
#'
#' @description
#' Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.
#'
#' @name list_where
#' @usage list_where(value_list = `T[]`, mask_list = `BOOLEAN[]`)
#' @param value_list `T[]`
#' @param mask_list `BOOLEAN[]`
#' @return `T[]`
#' @examples
#' \dontrun{
#' list_where([10, 20, 30, 40], [true, false, false, true])
#' }
list_where <- function(value_list = `T[]`, mask_list = `BOOLEAN[]`) {
  stop("DuckDB function list_where() is not available in R.")
}

#' DuckDB function list_zip
#'
#' @description
#' Zips n `LIST`s to a new `LIST` whose length will be that of the longest list. Its elements are structs of n elements from each list `list_1`, …, `list_n`, missing elements are replaced with `NULL`. If `truncate` is set, all lists are truncated to the smallest list length.
#'
#' @name list_zip
#' @usage list_zip()

#' @return `STRUCT[]`
#' @examples
#' \dontrun{
#' c("list_zip([1, 2], [3, 4], [5, 6])", "list_zip([1, 2], [3, 4], [5, 6, 7])", "list_zip([1, 2], [3, 4], [5, 6, 7], true)")
#' }
list_zip <- function() {
  stop("DuckDB function list_zip() is not available in R.")
}

#' DuckDB function listagg
#'
#' @description
#' Concatenates the column string values with an optional separator.
#'
#' @name listagg
#' @usage NULL
#' @param str `ANY`
#' @param arg `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' listagg(A, '-')
#' }
listagg <- function(str = ANY, arg = VARCHAR) {
  stop("DuckDB function listagg() is not available in R.")
}

#' DuckDB function ln
#'
#' @description
#' Computes the natural logarithm of x.
#'
#' @name ln
#' @usage ln(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' ln(2)
#' }
ln <- function(x = DOUBLE) {
  stop("DuckDB function ln() is not available in R.")
}

#' DuckDB function log
#'
#' @description
#' Computes the logarithm of x to base b. b may be omitted, in which case the default 10.
#'
#' @name log
#' @usage NULL
#' @param b `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' log(2, 64)
#' }
log <- function(b = DOUBLE, x = DOUBLE) {
  stop("DuckDB function log() is not available in R.")
}

#' DuckDB function log10
#'
#' @description
#' Computes the 10-log of x.
#'
#' @name log10
#' @usage log10(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' log10(1000)
#' }
log10 <- function(x = DOUBLE) {
  stop("DuckDB function log10() is not available in R.")
}

#' DuckDB function log2
#'
#' @description
#' Computes the 2-log of x.
#'
#' @name log2
#' @usage log2(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' log2(8)
#' }
log2 <- function(x = DOUBLE) {
  stop("DuckDB function log2() is not available in R.")
}

#' DuckDB function lower
#'
#' @description
#' Converts `string` to lower case.
#'
#' @name lower
#' @usage lower(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' lower('Hello')
#' }
lower <- function(string = VARCHAR) {
  stop("DuckDB function lower() is not available in R.")
}

#' DuckDB function lpad
#'
#' @description
#' Pads the `string` with the `character` on the left until it has `count` characters. Truncates the `string` on the right if it has more than `count` characters.
#'
#' @name lpad
#' @usage lpad(string = VARCHAR, count = INTEGER, character = VARCHAR)
#' @param string `VARCHAR`
#' @param count `INTEGER`
#' @param character `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' lpad('hello', 8, '>')
#' }
lpad <- function(string = VARCHAR, count = INTEGER, character = VARCHAR) {
  stop("DuckDB function lpad() is not available in R.")
}

#' DuckDB function ltrim
#'
#' @description
#' Removes any occurrences of any of the `characters` from the left side of the `string`. `characters` defaults to `space`.
#'
#' @name ltrim
#' @usage NULL
#' @param string `VARCHAR`
#' @param characters `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' c("ltrim('    test  ')", "ltrim('>>>>test<<', '><')")
#' }
ltrim <- function(string = VARCHAR, characters = VARCHAR) {
  stop("DuckDB function ltrim() is not available in R.")
}

#' DuckDB function mad
#'
#' @description
#' Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.	.
#'
#' @name mad
#' @usage NULL
#' @param x `DECIMAL | FLOAT | DOUBLE | DATE | TIMESTAMP | TIME | TIMESTAMP WITH TIME ZONE | TIME WITH TIME ZONE`
#' @return `DECIMAL | FLOAT | DOUBLE | INTERVAL`
#' @examples
#' \dontrun{
#' mad(x)
#' }
mad <- function(x = `DECIMAL | FLOAT | DOUBLE | DATE | TIMESTAMP | TIME | TIMESTAMP WITH TIME ZONE | TIME WITH TIME ZONE`) {
  stop("DuckDB function mad() is not available in R.")
}

#' DuckDB function make_date
#'
#' @description
#' The date for the given parts.
#'
#' The date for the given struct.
#'
#' @name make_date
#' @usage NULL
#' @param col0 `INTEGER`
#' @param year `BIGINT`
#' @param month `BIGINT`
#' @param day `BIGINT`
#' @param date-struct `STRUCT("year" BIGINT, "month" BIGINT, "day" BIGINT)`
#' @return `DATE`
#' @examples
#' \dontrun{
#' character(0)
#' make_date(1992, 9, 20)
#' make_date({'year': 2024, 'month': 11, 'day': 14})
#' }
make_date <- function(col0 = INTEGER, year = BIGINT, month = BIGINT, day = BIGINT, `date-struct` = `STRUCT("year" BIGINT, "month" BIGINT, "day" BIGINT)`) {
  stop("DuckDB function make_date() is not available in R.")
}

#' DuckDB function make_time
#'
#' @description
#' The time for the given parts.
#'
#' @name make_time
#' @usage make_time(hour = BIGINT, minute = BIGINT, seconds = DOUBLE)
#' @param hour `BIGINT`
#' @param minute `BIGINT`
#' @param seconds `DOUBLE`
#' @return `TIME`
#' @examples
#' \dontrun{
#' make_time(13, 34, 27.123456)
#' }
make_time <- function(hour = BIGINT, minute = BIGINT, seconds = DOUBLE) {
  stop("DuckDB function make_time() is not available in R.")
}

#' DuckDB function make_timestamp
#'
#' @description
#' The timestamp for the given parts.
#'
#' @name make_timestamp
#' @usage NULL
#' @param year `BIGINT`
#' @param month `BIGINT`
#' @param day `BIGINT`
#' @param hour `BIGINT`
#' @param minute `BIGINT`
#' @param seconds `DOUBLE`
#' @return `TIMESTAMP`
#' @examples
#' \dontrun{
#' make_timestamp(1992, 9, 20, 13, 34, 27.123456)
#' }
make_timestamp <- function(year = BIGINT, month = BIGINT, day = BIGINT, hour = BIGINT, minute = BIGINT, seconds = DOUBLE) {
  stop("DuckDB function make_timestamp() is not available in R.")
}

#' DuckDB function make_timestamp_ms
#'
#' @description
#' The timestamp for the given microseconds since the epoch.
#'
#' @name make_timestamp_ms
#' @usage make_timestamp_ms(nanos = BIGINT)
#' @param nanos `BIGINT`
#' @return `TIMESTAMP`
#' @examples
#' \dontrun{
#' make_timestamp_ms(1732117793000000)
#' }
make_timestamp_ms <- function(nanos = BIGINT) {
  stop("DuckDB function make_timestamp_ms() is not available in R.")
}

#' DuckDB function make_timestamp_ns
#'
#' @description
#' The timestamp for the given nanoseconds since epoch.
#'
#' @name make_timestamp_ns
#' @usage make_timestamp_ns(nanos = BIGINT)
#' @param nanos `BIGINT`
#' @return `TIMESTAMP_NS`
#' @examples
#' \dontrun{
#' make_timestamp_ns(1732117793000000000)
#' }
make_timestamp_ns <- function(nanos = BIGINT) {
  stop("DuckDB function make_timestamp_ns() is not available in R.")
}

#' DuckDB function map
#'
#' @description
#' Creates a map from a set of keys and values.
#'
#' @name map
#' @usage NULL
#' @param keys `K[]`
#' @param values `V[]`
#' @return `MAP("NULL", "NULL") | MAP(K, V)`
#' @examples
#' \dontrun{
#' map(['key1', 'key2'], ['val1', 'val2'])
#' }
map <- function(keys = `K[]`, values = `V[]`) {
  stop("DuckDB function map() is not available in R.")
}

#' DuckDB function map_concat
#'
#' @description
#' Returns a map created from merging the input maps, on key collision the value is taken from the last map with that key.
#'
#' @name map_concat
#' @usage map_concat()

#' @return `LIST`
#' @examples
#' \dontrun{
#' map_concat(map([1, 2], ['a', 'b']), map([2, 3], ['c', 'd']));
#' }
map_concat <- function() {
  stop("DuckDB function map_concat() is not available in R.")
}

#' DuckDB function map_contains
#'
#' @description
#' Checks if a map contains a given key.
#'
#' @name map_contains
#' @usage map_contains(map = `MAP(K, V)`, key = K)
#' @param map `MAP(K, V)`
#' @param key `K`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' map_contains(MAP {'key1': 10, 'key2': 20, 'key3': 30}, 'key2')
#' }
map_contains <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function map_contains() is not available in R.")
}

#' DuckDB function map_entries
#'
#' @description
#' Returns the map entries as a list of keys/values.
#'
#' @name map_entries
#' @usage map_entries(map = `MAP(K, V)`)
#' @param map `MAP(K, V)`
#' @return `STRUCT("key" K, "value" V)[]`
#' @examples
#' \dontrun{
#' map_entries(map(['key'], ['val']))
#' }
map_entries <- function(map = `MAP(K, V)`) {
  stop("DuckDB function map_entries() is not available in R.")
}

#' DuckDB function map_extract
#'
#' @description
#' Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the map’s keys else an error is returned.
#'
#' @name map_extract
#' @usage map_extract(map = `MAP(K, V)`, key = K)
#' @param map `MAP(K, V)`
#' @param key `K`
#' @return `V[]`
#' @examples
#' \dontrun{
#' map_extract(map(['key'], ['val']), 'key')
#' }
map_extract <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function map_extract() is not available in R.")
}

#' DuckDB function map_extract_value
#'
#' @description
#' Returns the value for a given key or NULL if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the map’s keys else an error is returned.
#'
#' @name map_extract_value
#' @usage map_extract_value(map = `MAP(K, V)`, key = K)
#' @param map `MAP(K, V)`
#' @param key `K`
#' @return `V`
#' @examples
#' \dontrun{
#' map_extract_value(map(['key'], ['val']), 'key')
#' }
map_extract_value <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function map_extract_value() is not available in R.")
}

#' DuckDB function map_from_entries
#'
#' @description
#' Returns a map created from the entries of the array.
#'
#' @name map_from_entries
#' @usage map_from_entries(map = `STRUCT(K, V)[]`)
#' @param map `STRUCT(K, V)[]`
#' @return `MAP(K, V)`
#' @examples
#' \dontrun{
#' map_from_entries([{k: 5, v: 'val1'}, {k: 3, v: 'val2'}]);
#' }
map_from_entries <- function(map = `STRUCT(K, V)[]`) {
  stop("DuckDB function map_from_entries() is not available in R.")
}

#' DuckDB function map_keys
#'
#' @description
#' Returns the keys of a map as a list.
#'
#' @name map_keys
#' @usage map_keys(map = `MAP(K, V)`)
#' @param map `MAP(K, V)`
#' @return `K[]`
#' @examples
#' \dontrun{
#' map_keys(map(['key'], ['val']))
#' }
map_keys <- function(map = `MAP(K, V)`) {
  stop("DuckDB function map_keys() is not available in R.")
}

#' DuckDB function map_values
#'
#' @description
#' Returns the values of a map as a list.
#'
#' @name map_values
#' @usage map_values(map = `MAP(K, V)`)
#' @param map `MAP(K, V)`
#' @return `V[]`
#' @examples
#' \dontrun{
#' map_values(map(['key'], ['val']))
#' }
map_values <- function(map = `MAP(K, V)`) {
  stop("DuckDB function map_values() is not available in R.")
}

#' DuckDB function max
#'
#' @description
#' Returns the maximum value present in arg.
#'
#' @name max
#' @usage NULL
#' @param arg `ANY`
#' @param col1 `BIGINT`
#' @return `ANY | ANY[]`
#' @examples
#' \dontrun{
#' max(A)
#' }
max <- function(arg = ANY, col1 = BIGINT) {
  stop("DuckDB function max() is not available in R.")
}

#' DuckDB function max_by
#'
#' @description
#' Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.
#'
#' @name max_by
#' @usage NULL
#' @param arg `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`
#' @param val `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`
#' @param col2 `BIGINT`
#' @return `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY | ANY[]`
#' @examples
#' \dontrun{
#' max_by(A, B)
#' }
max_by <- function(arg = `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`, val = `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`, col2 = BIGINT) {
  stop("DuckDB function max_by() is not available in R.")
}

#' DuckDB function md5
#'
#' @description
#' Returns the MD5 hash of the `string` as a `VARCHAR`.
#'
#' Returns the MD5 hash of the `blob` as a `VARCHAR`.
#'
#' @name md5
#' @usage NULL
#' @param string `VARCHAR`
#' @param blob `BLOB`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' md5('abc')
#' md5('\xAA\xBB'::BLOB)
#' }
md5 <- function(string = VARCHAR, blob = BLOB) {
  stop("DuckDB function md5() is not available in R.")
}

#' DuckDB function md5_number
#'
#' @description
#' Returns the MD5 hash of the `string` as a `HUGEINT`.
#'
#' Returns the MD5 hash of the `blob` as a `HUGEINT`.
#'
#' @name md5_number
#' @usage NULL
#' @param string `VARCHAR`
#' @param blob `BLOB`
#' @return `UHUGEINT`
#' @examples
#' \dontrun{
#' md5_number('abc')
#' md5_number('\xAA\xBB'::BLOB)
#' }
md5_number <- function(string = VARCHAR, blob = BLOB) {
  stop("DuckDB function md5_number() is not available in R.")
}

#' DuckDB function mean
#'
#' @description
#' Calculates the average value for all tuples in x.
#'
#' @name mean
#' @usage NULL
#' @param x `DECIMAL | SMALLINT | INTEGER | BIGINT | HUGEINT | INTERVAL | DOUBLE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME | TIME WITH TIME ZONE`
#' @return `DECIMAL | DOUBLE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME | TIME WITH TIME ZONE`
#' @examples
#' \dontrun{
#' SUM(x) / COUNT(*)
#' }
mean <- function(x = `DECIMAL | SMALLINT | INTEGER | BIGINT | HUGEINT | INTERVAL | DOUBLE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME | TIME WITH TIME ZONE`) {
  stop("DuckDB function mean() is not available in R.")
}

#' DuckDB function median
#'
#' @description
#' Returns the middle value of the set. NULL values are ignored. For even value counts, interpolate-able types (numeric, date/time) return the average of the two middle values. Non-interpolate-able types (everything else) return the lower of the two middle values.
#'
#' @name median
#' @usage median(x = ANY)
#' @param x `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' median(x)
#' }
median <- function(x = ANY) {
  stop("DuckDB function median() is not available in R.")
}

#' DuckDB function microsecond
#'
#' @description
#' Extract the microsecond component from a date or timestamp.
#'
#' @name microsecond
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' microsecond(timestamp '2021-08-03 11:59:44.123456')
#' }
microsecond <- function(ts = `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function microsecond() is not available in R.")
}

#' DuckDB function millennium
#'
#' @description
#' Extract the millennium component from a date or timestamp.
#'
#' @name millennium
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' millennium(timestamp '2021-08-03 11:59:44.123456')
#' }
millennium <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function millennium() is not available in R.")
}

#' DuckDB function millisecond
#'
#' @description
#' Extract the millisecond component from a date or timestamp.
#'
#' @name millisecond
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' millisecond(timestamp '2021-08-03 11:59:44.123456')
#' }
millisecond <- function(ts = `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function millisecond() is not available in R.")
}

#' DuckDB function min
#'
#' @description
#' Returns the minimum value present in arg.
#'
#' @name min
#' @usage NULL
#' @param arg `ANY`
#' @param col1 `BIGINT`
#' @return `ANY | ANY[]`
#' @examples
#' \dontrun{
#' min(A)
#' }
min <- function(arg = ANY, col1 = BIGINT) {
  stop("DuckDB function min() is not available in R.")
}

#' DuckDB function min_by
#'
#' @description
#' Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.
#'
#' @name min_by
#' @usage NULL
#' @param arg `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`
#' @param val `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`
#' @param col2 `BIGINT`
#' @return `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY | ANY[]`
#' @examples
#' \dontrun{
#' min_by(A, B)
#' }
min_by <- function(arg = `INTEGER | BIGINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | DECIMAL | ANY`, val = `INTEGER | BIGINT | HUGEINT | DOUBLE | VARCHAR | DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | BLOB | ANY`, col2 = BIGINT) {
  stop("DuckDB function min_by() is not available in R.")
}

#' DuckDB function minute
#'
#' @description
#' Extract the minute component from a date or timestamp.
#'
#' @name minute
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' minute(timestamp '2021-08-03 11:59:44.123456')
#' }
minute <- function(ts = `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function minute() is not available in R.")
}

#' DuckDB function mismatches
#'
#' @description
#' The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length. Strings must be of equal length. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name mismatches
#' @usage mismatches(s1 = VARCHAR, s2 = VARCHAR)
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' mismatches('duck', 'luck')
#' }
mismatches <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function mismatches() is not available in R.")
}

#' DuckDB function mod
#'
#' @description
#' DuckDB function `mod()`.
#'
#' @name mod
#' @usage NULL
#' @param col0 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @examples
#' \dontrun{
#' character(0)
#' }
mod <- function(col0 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function mod() is not available in R.")
}

#' DuckDB function mode
#'
#' @description
#' Returns the most frequent value for the values within x. NULL values are ignored.
#'
#' @name mode
#' @usage mode(x = ANY)
#' @param x `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' character(0)
#' }
mode <- function(x = ANY) {
  stop("DuckDB function mode() is not available in R.")
}

#' DuckDB function month
#'
#' @description
#' Extract the month component from a date or timestamp.
#'
#' @name month
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' month(timestamp '2021-08-03 11:59:44.123456')
#' }
month <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function month() is not available in R.")
}

#' DuckDB function monthname
#'
#' @description
#' The (English) name of the month.
#'
#' @name monthname
#' @usage NULL
#' @param ts `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' monthname(TIMESTAMP '1992-09-20')
#' }
monthname <- function(ts = `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function monthname() is not available in R.")
}

#' DuckDB function multiply
#'
#' @description
#' DuckDB function `multiply()`.
#'
#' @name multiply
#' @usage NULL
#' @param col0 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | INTERVAL`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | INTERVAL`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | INTERVAL`
#' @examples
#' \dontrun{
#' character(0)
#' }
multiply <- function(col0 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | INTERVAL`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | INTERVAL`) {
  stop("DuckDB function multiply() is not available in R.")
}

#' DuckDB function nanosecond
#'
#' @description
#' Extract the nanosecond component from a date or timestamp.
#'
#' @name nanosecond
#' @usage NULL
#' @param tsns `DATE | TIMESTAMP | INTERVAL | TIME | TIME_NS | TIME WITH TIME ZONE | TIMESTAMP_NS | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' nanosecond(timestamp_ns '2021-08-03 11:59:44.123456789')
#' }
nanosecond <- function(tsns = `DATE | TIMESTAMP | INTERVAL | TIME | TIME_NS | TIME WITH TIME ZONE | TIMESTAMP_NS | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function nanosecond() is not available in R.")
}

#' DuckDB function nextafter
#'
#' @description
#' Returns the next floating point value after x in the direction of y.
#'
#' @name nextafter
#' @usage NULL
#' @param x `DOUBLE | FLOAT`
#' @param y `DOUBLE | FLOAT`
#' @return `DOUBLE | FLOAT`
#' @examples
#' \dontrun{
#' nextafter(1::float, 2::float)
#' }
nextafter <- function(x = `DOUBLE | FLOAT`, y = `DOUBLE | FLOAT`) {
  stop("DuckDB function nextafter() is not available in R.")
}

#' DuckDB function nfc_normalize
#'
#' @description
#' Converts `string` to Unicode NFC normalized string. Useful for comparisons and ordering if text data is mixed between NFC normalized and not.
#'
#' @name nfc_normalize
#' @usage nfc_normalize(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' nfc_normalize('ardèch')
#' }
nfc_normalize <- function(string = VARCHAR) {
  stop("DuckDB function nfc_normalize() is not available in R.")
}

#' DuckDB function normalized_interval
#'
#' @description
#' Normalizes an INTERVAL to an equivalent interval.
#'
#' @name normalized_interval
#' @usage normalized_interval(interval = INTERVAL)
#' @param interval `INTERVAL`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' normalized_interval(INTERVAL '30 days')
#' }
normalized_interval <- function(interval = INTERVAL) {
  stop("DuckDB function normalized_interval() is not available in R.")
}

#' DuckDB function not_ilike_escape
#'
#' @description
#' Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name not_ilike_escape
#' @usage not_ilike_escape(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR)
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' not_ilike_escape('A%c', 'a$%C', '$')
#' }
not_ilike_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function not_ilike_escape() is not available in R.")
}

#' DuckDB function not_like_escape
#'
#' @description
#' Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name not_like_escape
#' @usage not_like_escape(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR)
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' not_like_escape('a%c', 'a$%c', '$')
#' }
not_like_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function not_like_escape() is not available in R.")
}

#' DuckDB function octet_length
#'
#' @description
#' Number of bytes in `blob`.
#'
#' Returns the number of bytes in the `bitstring`.
#'
#' @name octet_length
#' @usage NULL
#' @param blob `BLOB`
#' @param bitstring `BIT`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' octet_length('\xAA\xBB'::BLOB)
#' octet_length('1101011'::BITSTRING)
#' }
octet_length <- function(blob = BLOB, bitstring = BIT) {
  stop("DuckDB function octet_length() is not available in R.")
}

#' DuckDB function ord
#'
#' @description
#' Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.
#'
#' @name ord
#' @usage ord(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' [unicode('âbcd'), unicode('â'), unicode(''), unicode(NULL)]
#' }
ord <- function(string = VARCHAR) {
  stop("DuckDB function ord() is not available in R.")
}

#' DuckDB function parse_dirname
#'
#' @description
#' Returns the top-level directory name from the given `path`. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.
#'
#' @name parse_dirname
#' @usage NULL
#' @param path `VARCHAR`
#' @param separator `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' parse_dirname('path/to/file.csv', 'system')
#' }
parse_dirname <- function(path = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function parse_dirname() is not available in R.")
}

#' DuckDB function parse_dirpath
#'
#' @description
#' Returns the head of the `path` (the pathname until the last slash) similarly to Python's `os.path.dirname`. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.
#'
#' @name parse_dirpath
#' @usage NULL
#' @param path `VARCHAR`
#' @param separator `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' parse_dirpath('path/to/file.csv', 'forward_slash')
#' }
parse_dirpath <- function(path = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function parse_dirpath() is not available in R.")
}

#' DuckDB function parse_duckdb_log_message
#'
#' @description
#' Parse the message into the expected logical type.
#'
#' @name parse_duckdb_log_message
#' @usage parse_duckdb_log_message(type = VARCHAR, message = VARCHAR)
#' @param type `VARCHAR`
#' @param message `VARCHAR`
#' @return `ANY`
#' @examples
#' \dontrun{
#' parse_duckdb_log_message('FileSystem', log_message)
#' }
parse_duckdb_log_message <- function(type = VARCHAR, message = VARCHAR) {
  stop("DuckDB function parse_duckdb_log_message() is not available in R.")
}

#' DuckDB function parse_filename
#'
#' @description
#' Returns the last component of the `path` similarly to Python's `os.path.basename` function. If `trim_extension` is `true`, the file extension will be removed (defaults to `false`). `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.
#'
#' @name parse_filename
#' @usage NULL
#' @param string `VARCHAR`
#' @param trim_extension `VARCHAR | BOOLEAN`
#' @param separator `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' parse_filename('path/to/file.csv', true, 'forward_slash')
#' }
parse_filename <- function(string = VARCHAR, trim_extension = `VARCHAR | BOOLEAN`, separator = VARCHAR) {
  stop("DuckDB function parse_filename() is not available in R.")
}

#' DuckDB function parse_path
#'
#' @description
#' Returns a list of the components (directories and filename) in the `path` similarly to Python's `pathlib.parts` function. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.
#'
#' @name parse_path
#' @usage NULL
#' @param path `VARCHAR`
#' @param separator `VARCHAR`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' parse_path('path/to/file.csv', 'system')
#' }
parse_path <- function(path = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function parse_path() is not available in R.")
}

#' DuckDB function pi
#'
#' @description
#' Returns the value of pi.
#'
#' @name pi
#' @usage pi()

#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' pi()
#' }
pi <- function() {
  stop("DuckDB function pi() is not available in R.")
}

#' DuckDB function position
#'
#' @description
#' Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.
#'
#' @name position
#' @usage position(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' position('b' IN 'abc')
#' }
position <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function position() is not available in R.")
}

#' DuckDB function pow
#'
#' @description
#' Computes x to the power of y.
#'
#' @name pow
#' @usage pow(x = DOUBLE, y = DOUBLE)
#' @param x `DOUBLE`
#' @param y `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' c("pow(2, 3)", "power(2, 3)")
#' }
pow <- function(x = DOUBLE, y = DOUBLE) {
  stop("DuckDB function pow() is not available in R.")
}

#' DuckDB function power
#'
#' @description
#' Computes x to the power of y.
#'
#' @name power
#' @usage power(x = DOUBLE, y = DOUBLE)
#' @param x `DOUBLE`
#' @param y `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' power(2, 3)
#' }
power <- function(x = DOUBLE, y = DOUBLE) {
  stop("DuckDB function power() is not available in R.")
}

#' DuckDB function prefix
#'
#' @description
#' Returns `true` if `string` starts with `search_string`.
#'
#' @name prefix
#' @usage prefix(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' prefix('abc', 'ab')
#' }
prefix <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function prefix() is not available in R.")
}

#' DuckDB function printf
#'
#' @description
#' Formats a `string` using printf syntax.
#'
#' @name printf
#' @usage printf(format = VARCHAR)
#' @param format `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' printf('Benchmark "%s" took %d seconds', 'CSV', 42)
#' }
printf <- function(format = VARCHAR) {
  stop("DuckDB function printf() is not available in R.")
}

#' DuckDB function product
#'
#' @description
#' Calculates the product of all tuples in arg.
#'
#' @name product
#' @usage product(arg = DOUBLE)
#' @param arg `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' product(A)
#' }
product <- function(arg = DOUBLE) {
  stop("DuckDB function product() is not available in R.")
}

#' DuckDB function quantile
#'
#' @description
#' Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.
#'
#' @name quantile
#' @usage NULL
#' @param x `ANY`
#' @param pos `DOUBLE | DOUBLE[]`
#' @return `ANY`
#' @examples
#' \dontrun{
#' quantile_disc(x, 0.5)
#' }
quantile <- function(x = ANY, pos = `DOUBLE | DOUBLE[]`) {
  stop("DuckDB function quantile() is not available in R.")
}

#' DuckDB function quantile_cont
#'
#' @description
#' Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.	.
#'
#' @name quantile_cont
#' @usage NULL
#' @param x `DECIMAL | TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DATE | TIMESTAMP | TIME | TIMESTAMP WITH TIME ZONE | TIME WITH TIME ZONE`
#' @param pos `DOUBLE | DOUBLE[]`
#' @return `DECIMAL | TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DATE | TIMESTAMP | TIME | TIMESTAMP WITH TIME ZONE | TIME WITH TIME ZONE`
#' @examples
#' \dontrun{
#' quantile_cont(x, 0.5)
#' }
quantile_cont <- function(x = `DECIMAL | TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DATE | TIMESTAMP | TIME | TIMESTAMP WITH TIME ZONE | TIME WITH TIME ZONE`, pos = `DOUBLE | DOUBLE[]`) {
  stop("DuckDB function quantile_cont() is not available in R.")
}

#' DuckDB function quantile_disc
#'
#' @description
#' Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.
#'
#' @name quantile_disc
#' @usage NULL
#' @param x `ANY`
#' @param pos `DOUBLE | DOUBLE[]`
#' @return `ANY`
#' @examples
#' \dontrun{
#' quantile_disc(x, 0.5)
#' }
quantile_disc <- function(x = ANY, pos = `DOUBLE | DOUBLE[]`) {
  stop("DuckDB function quantile_disc() is not available in R.")
}

#' DuckDB function quarter
#'
#' @description
#' Extract the quarter component from a date or timestamp.
#'
#' @name quarter
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' quarter(timestamp '2021-08-03 11:59:44.123456')
#' }
quarter <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function quarter() is not available in R.")
}

#' DuckDB function radians
#'
#' @description
#' Converts degrees to radians.
#'
#' @name radians
#' @usage radians(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' radians(90)
#' }
radians <- function(x = DOUBLE) {
  stop("DuckDB function radians() is not available in R.")
}

#' DuckDB function range
#'
#' @description
#' Creates a list of values between `start` and `stop` - the stop parameter is exclusive.
#'
#' @name range
#' @usage NULL
#' @param start `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @param stop `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @param step `BIGINT | INTERVAL`
#' @return `BIGINT[] | TIMESTAMP[] | TIMESTAMP WITH TIME ZONE[]`
#' @examples
#' \dontrun{
#' range(2, 5, 3)
#' }
range <- function(start = `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE`, stop = `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE`, step = `BIGINT | INTERVAL`) {
  stop("DuckDB function range() is not available in R.")
}

#' DuckDB function reduce
#'
#' @description
#' Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.
#'
#' @name reduce
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x,y) `LAMBDA`
#' @param initial_value `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' reduce([1, 2, 3], lambda x, y : x + y)
#' }
reduce <- function(list = `ANY[]`, `lambda(x,y)` = LAMBDA, initial_value = ANY) {
  stop("DuckDB function reduce() is not available in R.")
}

#' DuckDB function regexp_escape
#'
#' @description
#' Escapes special patterns to turn `string` into a regular expression similarly to Python's `re.escape` function.
#'
#' @name regexp_escape
#' @usage regexp_escape(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_escape('https://duckdb.org')
#' }
regexp_escape <- function(string = VARCHAR) {
  stop("DuckDB function regexp_escape() is not available in R.")
}

#' DuckDB function regexp_extract
#'
#' @description
#' If `string` contains the `regex` pattern, returns the capturing group specified by optional parameter `group`; otherwise, returns the empty string. The `group` must be a constant value. If no `group` is given, it defaults to 0. A set of optional regex `options` can be set.
#'
#' If `string` contains the `regex` pattern, returns the capturing groups as a struct with corresponding names from `name_list`; otherwise, returns a struct with the same keys and empty strings as values. A set of optional regex `options` can be set.
#'
#' @name regexp_extract
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param group `INTEGER`
#' @param options `VARCHAR`
#' @param name_list `VARCHAR[]`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_extract('abcde', '[a-z]{3}')
#' regexp_extract('abc', '([a-z])(b)', 1)
#' regexp_extract('ABC', '([a-z])(b)', 1, 'i')
#' regexp_extract('2023-04-15', '(\d+)-(\d+)-(\d+)', ['y', 'm', 'd'])
#' regexp_extract('John Doe', '([a-z]+) ([a-z]+)', ['first_name', 'last_name'], 'i')
#' }
regexp_extract <- function(string = VARCHAR, regex = VARCHAR, group = INTEGER, options = VARCHAR, name_list = `VARCHAR[]`) {
  stop("DuckDB function regexp_extract() is not available in R.")
}

#' DuckDB function regexp_extract_all
#'
#' @description
#' Finds non-overlapping occurrences of the `regex` in the `string` and returns the corresponding values of the capturing `group`. A set of optional regex `options` can be set.
#'
#' @name regexp_extract_all
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param group `INTEGER`
#' @param options `VARCHAR`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' regexp_extract_all('Peter: 33, Paul:14', '(\w+):\s*(\d+)', 2)
#' }
regexp_extract_all <- function(string = VARCHAR, regex = VARCHAR, group = INTEGER, options = VARCHAR) {
  stop("DuckDB function regexp_extract_all() is not available in R.")
}

#' DuckDB function regexp_full_match
#'
#' @description
#' Returns `true` if the entire `string` matches the `regex`. A set of optional regex `options` can be set.
#'
#' @name regexp_full_match
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param col2 `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' regexp_full_match('anabanana', '(an)*')
#' }
regexp_full_match <- function(string = VARCHAR, regex = VARCHAR, col2 = VARCHAR) {
  stop("DuckDB function regexp_full_match() is not available in R.")
}

#' DuckDB function regexp_matches
#'
#' @description
#' Returns `true` if `string` contains the `regex`, `false` otherwise. A set of optional regex `options` can be set.
#'
#' @name regexp_matches
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param options `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' regexp_matches('anabanana', '(an)*')
#' }
regexp_matches <- function(string = VARCHAR, regex = VARCHAR, options = VARCHAR) {
  stop("DuckDB function regexp_matches() is not available in R.")
}

#' DuckDB function regexp_replace
#'
#' @description
#' If `string` contains the `regex`, replaces the matching part with `replacement`. A set of optional regex `options` can be set.
#'
#' @name regexp_replace
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param replacement `VARCHAR`
#' @param options `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_replace('hello', '[lo]', '-')
#' }
regexp_replace <- function(string = VARCHAR, regex = VARCHAR, replacement = VARCHAR, options = VARCHAR) {
  stop("DuckDB function regexp_replace() is not available in R.")
}

#' DuckDB function regexp_split_to_array
#'
#' @description
#' Splits the `string` along the `regex`. A set of optional regex `options` can be set.
#'
#' @name regexp_split_to_array
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param options `VARCHAR`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' regexp_split_to_array('hello world; 42', ';? ')
#' }
regexp_split_to_array <- function(string = VARCHAR, regex = VARCHAR, options = VARCHAR) {
  stop("DuckDB function regexp_split_to_array() is not available in R.")
}

#' DuckDB function regr_avgx
#'
#' @description
#' Returns the average of the independent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.
#'
#' @name regr_avgx
#' @usage regr_avgx(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' character(0)
#' }
regr_avgx <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function regr_avgx() is not available in R.")
}

#' DuckDB function regr_avgy
#'
#' @description
#' Returns the average of the dependent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.
#'
#' @name regr_avgy
#' @usage regr_avgy(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' character(0)
#' }
regr_avgy <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function regr_avgy() is not available in R.")
}

#' DuckDB function regr_count
#'
#' @description
#' Returns the number of non-NULL number pairs in a group.
#'
#' @name regr_count
#' @usage regr_count(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `UINTEGER`
#' @examples
#' \dontrun{
#' (SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / COUNT(*)
#' }
regr_count <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function regr_count() is not available in R.")
}

#' DuckDB function regr_intercept
#'
#' @description
#' Returns the intercept of the univariate linear regression line for non-NULL pairs in a group.
#'
#' @name regr_intercept
#' @usage regr_intercept(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' AVG(y)-REGR_SLOPE(y, x)*AVG(x)
#' }
regr_intercept <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function regr_intercept() is not available in R.")
}

#' DuckDB function regr_r2
#'
#' @description
#' Returns the coefficient of determination for non-NULL pairs in a group.
#'
#' @name regr_r2
#' @usage regr_r2(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' character(0)
#' }
regr_r2 <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function regr_r2() is not available in R.")
}

#' DuckDB function regr_slope
#'
#' @description
#' Returns the slope of the linear regression line for non-NULL pairs in a group.
#'
#' @name regr_slope
#' @usage regr_slope(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' COVAR_POP(x, y) / VAR_POP(x)
#' }
regr_slope <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function regr_slope() is not available in R.")
}

#' DuckDB function regr_sxx
#'
#' @description
#' DuckDB function `regr_sxx()`.
#'
#' @name regr_sxx
#' @usage regr_sxx(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' REGR_COUNT(y, x) * VAR_POP(x)
#' }
regr_sxx <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function regr_sxx() is not available in R.")
}

#' DuckDB function regr_sxy
#'
#' @description
#' Returns the population covariance of input values.
#'
#' @name regr_sxy
#' @usage regr_sxy(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' REGR_COUNT(y, x) * COVAR_POP(y, x)
#' }
regr_sxy <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function regr_sxy() is not available in R.")
}

#' DuckDB function regr_syy
#'
#' @description
#' DuckDB function `regr_syy()`.
#'
#' @name regr_syy
#' @usage regr_syy(y = DOUBLE, x = DOUBLE)
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' REGR_COUNT(y, x) * VAR_POP(y)
#' }
regr_syy <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function regr_syy() is not available in R.")
}

#' DuckDB function repeat
#'
#' @description
#' Repeats the `string` `count` number of times.
#'
#' Repeats the `blob` `count` number of times.
#'
#' @name repeat
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @param blob `BLOB`
#' @param col0 `T[]`
#' @param col1 `BIGINT`
#' @return `VARCHAR | BLOB | T[]`
#' @examples
#' \dontrun{
#' repeat('A', 5)
#' repeat('\xAA\xBB'::BLOB, 5)
#' character(0)
#' }
`repeat` <- function(string = VARCHAR, count = BIGINT, blob = BLOB, col0 = `T[]`, col1 = BIGINT) {
  stop("DuckDB function repeat() is not available in R.")
}

#' DuckDB function replace
#'
#' @description
#' Replaces any occurrences of the `source` with `target` in `string`.
#'
#' @name replace
#' @usage replace(string = VARCHAR, source = VARCHAR, target = VARCHAR)
#' @param string `VARCHAR`
#' @param source `VARCHAR`
#' @param target `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' replace('hello', 'l', '-')
#' }
replace <- function(string = VARCHAR, source = VARCHAR, target = VARCHAR) {
  stop("DuckDB function replace() is not available in R.")
}

#' DuckDB function replace_type
#'
#' @description
#' Casts all fields of type1 to type2.
#'
#' @name replace_type
#' @usage replace_type(param = ANY, type1 = ANY, type2 = ANY)
#' @param param `ANY`
#' @param type1 `ANY`
#' @param type2 `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' replace_type({duck: 3.141592653589793::DOUBLE}, NULL::DOUBLE, NULL::DECIMAL(15,2))
#' }
replace_type <- function(param = ANY, type1 = ANY, type2 = ANY) {
  stop("DuckDB function replace_type() is not available in R.")
}

#' DuckDB function reservoir_quantile
#'
#' @description
#' Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.
#'
#' @name reservoir_quantile
#' @usage NULL
#' @param x `DECIMAL | TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE`
#' @param quantile `DOUBLE | DOUBLE[]`
#' @param sample_size `INTEGER`
#' @return `DECIMAL | DECIMAL[] | TINYINT | TINYINT[] | SMALLINT | SMALLINT[] | INTEGER | INTEGER[] | BIGINT | BIGINT[] | HUGEINT | HUGEINT[] | FLOAT | FLOAT[] | DOUBLE | DOUBLE[]`
#' @examples
#' \dontrun{
#' reservoir_quantile(A, 0.5, 1024)
#' }
reservoir_quantile <- function(x = `DECIMAL | TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE`, quantile = `DOUBLE | DOUBLE[]`, sample_size = INTEGER) {
  stop("DuckDB function reservoir_quantile() is not available in R.")
}

#' DuckDB function reverse
#'
#' @description
#' Reverses the `string`.
#'
#' @name reverse
#' @usage reverse(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' reverse('hello')
#' }
reverse <- function(string = VARCHAR) {
  stop("DuckDB function reverse() is not available in R.")
}

#' DuckDB function right
#'
#' @description
#' Extract the right-most `count` characters.
#'
#' @name right
#' @usage right(string = VARCHAR, count = BIGINT)
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' right('Hello🦆', 3)
#' }
right <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function right() is not available in R.")
}

#' DuckDB function right_grapheme
#'
#' @description
#' Extracts the right-most `count` grapheme clusters.
#'
#' @name right_grapheme
#' @usage right_grapheme(string = VARCHAR, count = BIGINT)
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' right_grapheme('🤦🏼‍♂️🤦🏽‍♀️', 1)
#' }
right_grapheme <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function right_grapheme() is not available in R.")
}

#' DuckDB function round
#'
#' @description
#' Rounds x to s decimal places.
#'
#' @name round
#' @usage NULL
#' @param x `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL`
#' @param precision `INTEGER`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL`
#' @examples
#' \dontrun{
#' round(42.4332, 2)
#' }
round <- function(x = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL`, precision = INTEGER) {
  stop("DuckDB function round() is not available in R.")
}

#' DuckDB function row
#'
#' @description
#' Create an unnamed STRUCT (tuple) containing the argument values.
#'
#' @name row
#' @usage row()

#' @return `STRUCT`
#' @examples
#' \dontrun{
#' row(i, i % 4, i / 4)
#' }
row <- function() {
  stop("DuckDB function row() is not available in R.")
}

#' DuckDB function rpad
#'
#' @description
#' Pads the `string` with the `character` on the right until it has `count` characters. Truncates the `string` on the right if it has more than `count` characters.
#'
#' @name rpad
#' @usage rpad(string = VARCHAR, count = INTEGER, character = VARCHAR)
#' @param string `VARCHAR`
#' @param count `INTEGER`
#' @param character `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' rpad('hello', 10, '<')
#' }
rpad <- function(string = VARCHAR, count = INTEGER, character = VARCHAR) {
  stop("DuckDB function rpad() is not available in R.")
}

#' DuckDB function rtrim
#'
#' @description
#' Removes any occurrences of any of the `characters` from the right side of the `string`. `characters` defaults to `space`.
#'
#' @name rtrim
#' @usage NULL
#' @param string `VARCHAR`
#' @param characters `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' c("rtrim('    test  ')", "rtrim('>>>>test<<', '><')")
#' }
rtrim <- function(string = VARCHAR, characters = VARCHAR) {
  stop("DuckDB function rtrim() is not available in R.")
}

#' DuckDB function second
#'
#' @description
#' Extract the second component from a date or timestamp.
#'
#' @name second
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' second(timestamp '2021-08-03 11:59:44.123456')
#' }
second <- function(ts = `DATE | INTERVAL | TIME | TIMESTAMP | TIME WITH TIME ZONE | TIME_NS | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function second() is not available in R.")
}

#' DuckDB function sem
#'
#' @description
#' Returns the standard error of the mean.
#'
#' @name sem
#' @usage sem(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' character(0)
#' }
sem <- function(x = DOUBLE) {
  stop("DuckDB function sem() is not available in R.")
}

#' DuckDB function set_bit
#'
#' @description
#' Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0. Returns a new bitstring.
#'
#' @name set_bit
#' @usage set_bit(bitstring = BIT, index = INTEGER, new_value = INTEGER)
#' @param bitstring `BIT`
#' @param index `INTEGER`
#' @param new_value `INTEGER`
#' @return `BIT`
#' @examples
#' \dontrun{
#' set_bit('0110010'::BIT, 2, 0)
#' }
set_bit <- function(bitstring = BIT, index = INTEGER, new_value = INTEGER) {
  stop("DuckDB function set_bit() is not available in R.")
}

#' DuckDB function sha1
#'
#' @description
#' Returns a `VARCHAR` with the SHA-1 hash of the `value`.
#'
#' Returns a `VARCHAR` with the SHA-1 hash of the `blob`.
#'
#' @name sha1
#' @usage NULL
#' @param value `VARCHAR`
#' @param blob `BLOB`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' sha1('🦆')
#' sha1('\xAA\xBB'::BLOB)
#' }
sha1 <- function(value = VARCHAR, blob = BLOB) {
  stop("DuckDB function sha1() is not available in R.")
}

#' DuckDB function sha256
#'
#' @description
#' Returns a `VARCHAR` with the SHA-256 hash of the `value`.
#'
#' Returns a `VARCHAR` with the SHA-256 hash of the `blob`.
#'
#' @name sha256
#' @usage NULL
#' @param value `VARCHAR`
#' @param blob `BLOB`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' sha256('🦆')
#' sha256('\xAA\xBB'::BLOB)
#' }
sha256 <- function(value = VARCHAR, blob = BLOB) {
  stop("DuckDB function sha256() is not available in R.")
}

#' DuckDB function sign
#'
#' @description
#' Returns the sign of x as -1, 0 or 1.
#'
#' @name sign
#' @usage NULL
#' @param x `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @return `TINYINT`
#' @examples
#' \dontrun{
#' sign(-349)
#' }
sign <- function(x = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`) {
  stop("DuckDB function sign() is not available in R.")
}

#' DuckDB function signbit
#'
#' @description
#' Returns whether the signbit is set or not.
#'
#' @name signbit
#' @usage NULL
#' @param x `FLOAT | DOUBLE`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' signbit(-0.0)
#' }
signbit <- function(x = `FLOAT | DOUBLE`) {
  stop("DuckDB function signbit() is not available in R.")
}

#' DuckDB function sin
#'
#' @description
#' Computes the sin of x.
#'
#' @name sin
#' @usage sin(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' sin(90)
#' }
sin <- function(x = DOUBLE) {
  stop("DuckDB function sin() is not available in R.")
}

#' DuckDB function sinh
#'
#' @description
#' Computes the hyperbolic sin of x.
#'
#' @name sinh
#' @usage sinh(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' sinh(1)
#' }
sinh <- function(x = DOUBLE) {
  stop("DuckDB function sinh() is not available in R.")
}

#' DuckDB function skewness
#'
#' @description
#' Returns the skewness of all input values.
#'
#' @name skewness
#' @usage skewness(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' skewness(A)
#' }
skewness <- function(x = DOUBLE) {
  stop("DuckDB function skewness() is not available in R.")
}

#' DuckDB function split
#'
#' @description
#' Splits the `string` along the `separator`.
#'
#' @name split
#' @usage split(string = VARCHAR, separator = VARCHAR)
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' split('hello-world', '-')
#' }
split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function split() is not available in R.")
}

#' DuckDB function sqrt
#'
#' @description
#' Returns the square root of x.
#'
#' @name sqrt
#' @usage sqrt(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' sqrt(4)
#' }
sqrt <- function(x = DOUBLE) {
  stop("DuckDB function sqrt() is not available in R.")
}

#' DuckDB function starts_with
#'
#' @description
#' Returns `true` if `string` begins with `search_string`.
#'
#' @name starts_with
#' @usage starts_with(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' starts_with('abc', 'a')
#' }
starts_with <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function starts_with() is not available in R.")
}

#' DuckDB function stddev
#'
#' @description
#' Returns the sample standard deviation.
#'
#' @name stddev
#' @usage stddev(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' sqrt(var_samp(x))
#' }
stddev <- function(x = DOUBLE) {
  stop("DuckDB function stddev() is not available in R.")
}

#' DuckDB function stddev_pop
#'
#' @description
#' Returns the population standard deviation.
#'
#' @name stddev_pop
#' @usage stddev_pop(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' sqrt(var_pop(x))
#' }
stddev_pop <- function(x = DOUBLE) {
  stop("DuckDB function stddev_pop() is not available in R.")
}

#' DuckDB function stddev_samp
#'
#' @description
#' Returns the sample standard deviation.
#'
#' @name stddev_samp
#' @usage stddev_samp(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' sqrt(var_samp(x))
#' }
stddev_samp <- function(x = DOUBLE) {
  stop("DuckDB function stddev_samp() is not available in R.")
}

#' DuckDB function str_split
#'
#' @description
#' Splits the `string` along the `separator`.
#'
#' @name str_split
#' @usage str_split(string = VARCHAR, separator = VARCHAR)
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' str_split('hello-world', '-')
#' }
str_split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function str_split() is not available in R.")
}

#' DuckDB function str_split_regex
#'
#' @description
#' Splits the `string` along the `regex`. A set of optional regex `options` can be set.
#'
#' @name str_split_regex
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param options `VARCHAR`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' str_split_regex('hello world; 42', ';? ')
#' }
str_split_regex <- function(string = VARCHAR, regex = VARCHAR, options = VARCHAR) {
  stop("DuckDB function str_split_regex() is not available in R.")
}

#' DuckDB function strftime
#'
#' @description
#' Converts a `date` to a string according to the format string.
#'
#' @name strftime
#' @usage NULL
#' @param data `DATE | TIMESTAMP | TIMESTAMP_NS | VARCHAR`
#' @param format `VARCHAR | DATE | TIMESTAMP | TIMESTAMP_NS`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' strftime(date '1992-01-01', '%a, %-d %B %Y')
#' }
strftime <- function(data = `DATE | TIMESTAMP | TIMESTAMP_NS | VARCHAR`, format = `VARCHAR | DATE | TIMESTAMP | TIMESTAMP_NS`) {
  stop("DuckDB function strftime() is not available in R.")
}

#' DuckDB function string_agg
#'
#' @description
#' Concatenates the column string values with an optional separator.
#'
#' @name string_agg
#' @usage NULL
#' @param str `ANY`
#' @param arg `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' string_agg(A, '-')
#' }
string_agg <- function(str = ANY, arg = VARCHAR) {
  stop("DuckDB function string_agg() is not available in R.")
}

#' DuckDB function string_split
#'
#' @description
#' Splits the `string` along the `separator`.
#'
#' @name string_split
#' @usage string_split(string = VARCHAR, separator = VARCHAR)
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' string_split('hello-world', '-')
#' }
string_split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function string_split() is not available in R.")
}

#' DuckDB function string_split_regex
#'
#' @description
#' Splits the `string` along the `regex`. A set of optional regex `options` can be set.
#'
#' @name string_split_regex
#' @usage NULL
#' @param string `VARCHAR`
#' @param regex `VARCHAR`
#' @param options `VARCHAR`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' string_split_regex('hello world; 42', ';? ')
#' }
string_split_regex <- function(string = VARCHAR, regex = VARCHAR, options = VARCHAR) {
  stop("DuckDB function string_split_regex() is not available in R.")
}

#' DuckDB function string_to_array
#'
#' @description
#' Splits the `string` along the `separator`.
#'
#' @name string_to_array
#' @usage string_to_array(string = VARCHAR, separator = VARCHAR)
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @return `VARCHAR[]`
#' @examples
#' \dontrun{
#' string_to_array('hello-world', '-')
#' }
string_to_array <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function string_to_array() is not available in R.")
}

#' DuckDB function strip_accents
#'
#' @description
#' Strips accents from `string`.
#'
#' @name strip_accents
#' @usage strip_accents(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' strip_accents('mühleisen')
#' }
strip_accents <- function(string = VARCHAR) {
  stop("DuckDB function strip_accents() is not available in R.")
}

#' DuckDB function strlen
#'
#' @description
#' Number of bytes in `string`.
#'
#' @name strlen
#' @usage strlen(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' strlen('🦆')
#' }
strlen <- function(string = VARCHAR) {
  stop("DuckDB function strlen() is not available in R.")
}

#' DuckDB function strpos
#'
#' @description
#' Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.
#'
#' @name strpos
#' @usage strpos(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' strpos('test test', 'es')
#' }
strpos <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function strpos() is not available in R.")
}

#' DuckDB function strptime
#'
#' @description
#' Converts the `string` text to timestamp according to the format string. Throws an error on failure. To return `NULL` on failure, use try_strptime.
#'
#' Converts the `string` text to timestamp applying the format strings in the list until one succeeds. Throws an error on failure. To return `NULL` on failure, use try_strptime.
#'
#' @name strptime
#' @usage NULL
#' @param text `VARCHAR`
#' @param format `VARCHAR`
#' @param format-list `VARCHAR[]`
#' @return `TIMESTAMP`
#' @examples
#' \dontrun{
#' strptime('Wed, 1 January 1992 - 08:38:40 PM', '%a, %-d %B %Y - %I:%M:%S %p')
#' strptime('4/15/2023 10:56:00', ['%d/%m/%Y %H:%M:%S', '%m/%d/%Y %H:%M:%S'])
#' }
strptime <- function(text = VARCHAR, format = VARCHAR, `format-list` = `VARCHAR[]`) {
  stop("DuckDB function strptime() is not available in R.")
}

#' DuckDB function struct_concat
#'
#' @description
#' Merge the multiple STRUCTs into a single STRUCT.
#'
#' @name struct_concat
#' @usage struct_concat()

#' @return `STRUCT`
#' @examples
#' \dontrun{
#' struct_concat(struct_pack(i := 4), struct_pack(s := 'string'))
#' }
struct_concat <- function() {
  stop("DuckDB function struct_concat() is not available in R.")
}

#' DuckDB function struct_contains
#'
#' @description
#' Check if an unnamed STRUCT contains the value.
#'
#' @name struct_contains
#' @usage struct_contains(struct = STRUCT, `'entry'` = ANY)
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' struct_contains(ROW(3, 3, 0), 3)
#' }
struct_contains <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_contains() is not available in R.")
}

#' DuckDB function struct_extract
#'
#' @description
#' Extract the named entry from the STRUCT.
#'
#' @name struct_extract
#' @usage NULL
#' @param struct `STRUCT`
#' @param 'entry' `VARCHAR | BIGINT`
#' @return `ANY`
#' @examples
#' \dontrun{
#' struct_extract({'i': 3, 'v2': 3, 'v3': 0}, 'i')
#' }
struct_extract <- function(struct = STRUCT, `'entry'` = `VARCHAR | BIGINT`) {
  stop("DuckDB function struct_extract() is not available in R.")
}

#' DuckDB function struct_has
#'
#' @description
#' Check if an unnamed STRUCT contains the value.
#'
#' @name struct_has
#' @usage struct_has(struct = STRUCT, `'entry'` = ANY)
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' struct_has(ROW(3, 3, 0), 3)
#' }
struct_has <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_has() is not available in R.")
}

#' DuckDB function struct_indexof
#'
#' @description
#' Get the position of the entry in an unnamed STRUCT, starting at 1.
#'
#' @name struct_indexof
#' @usage struct_indexof(struct = STRUCT, `'entry'` = ANY)
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' struct_indexof(ROW(3, 3, 0), 3)
#' }
struct_indexof <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_indexof() is not available in R.")
}

#' DuckDB function struct_insert
#'
#' @description
#' Adds field(s)/value(s) to an existing STRUCT with the argument values. The entry name(s) will be the bound variable name(s).
#'
#' @name struct_insert
#' @usage struct_insert()

#' @return `STRUCT`
#' @examples
#' \dontrun{
#' struct_insert({'a': 1}, b := 2)
#' }
struct_insert <- function() {
  stop("DuckDB function struct_insert() is not available in R.")
}

#' DuckDB function struct_pack
#'
#' @description
#' Create a STRUCT containing the argument values. The entry name will be the bound variable name.
#'
#' @name struct_pack
#' @usage struct_pack()

#' @return `STRUCT`
#' @examples
#' \dontrun{
#' struct_pack(i := 4, s := 'string')
#' }
struct_pack <- function() {
  stop("DuckDB function struct_pack() is not available in R.")
}

#' DuckDB function struct_position
#'
#' @description
#' Get the position of the entry in an unnamed STRUCT, starting at 1.
#'
#' @name struct_position
#' @usage struct_position(struct = STRUCT, `'entry'` = ANY)
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' struct_position(ROW(3, 3, 0), 3)
#' }
struct_position <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_position() is not available in R.")
}

#' DuckDB function struct_update
#'
#' @description
#' Changes field(s)/value(s) to an existing STRUCT with the argument values. The entry name(s) will be the bound variable name(s).
#'
#' @name struct_update
#' @usage struct_update()

#' @return `STRUCT`
#' @examples
#' \dontrun{
#' struct_update({'a': 1}, a := 2)
#' }
struct_update <- function() {
  stop("DuckDB function struct_update() is not available in R.")
}

#' DuckDB function substr
#'
#' @description
#' Extracts substring starting from character `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` characters instead. Note that a `start` value of `1` refers to the first character of the `string`.
#'
#' @name substr
#' @usage NULL
#' @param string `VARCHAR`
#' @param start `BIGINT`
#' @param length `BIGINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' c("substring('Hello', 2)", "substring('Hello', 2, 2)")
#' }
substr <- function(string = VARCHAR, start = BIGINT, length = BIGINT) {
  stop("DuckDB function substr() is not available in R.")
}

#' DuckDB function substring
#'
#' @description
#' Extracts substring starting from character `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` characters instead. Note that a `start` value of `1` refers to the first character of the `string`.
#'
#' @name substring
#' @usage NULL
#' @param string `VARCHAR`
#' @param start `BIGINT`
#' @param length `BIGINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' c("substring('Hello', 2)", "substring('Hello', 2, 2)")
#' }
substring <- function(string = VARCHAR, start = BIGINT, length = BIGINT) {
  stop("DuckDB function substring() is not available in R.")
}

#' DuckDB function substring_grapheme
#'
#' @description
#' Extracts substring starting from grapheme clusters `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` grapheme clusters instead. Note that a `start` value of `1` refers to the `first` character of the `string`.
#'
#' @name substring_grapheme
#' @usage NULL
#' @param string `VARCHAR`
#' @param start `BIGINT`
#' @param length `BIGINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' c("substring_grapheme('🦆🤦🏼‍♂️🤦🏽‍♀️🦆', 3)", "substring_grapheme('🦆🤦🏼‍♂️🤦🏽‍♀️🦆', 3, 2)")
#' }
substring_grapheme <- function(string = VARCHAR, start = BIGINT, length = BIGINT) {
  stop("DuckDB function substring_grapheme() is not available in R.")
}

#' DuckDB function subtract
#'
#' @description
#' DuckDB function `subtract()`.
#'
#' @name subtract
#' @usage NULL
#' @param col0 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIGNUM | DATE | TIMESTAMP | INTERVAL | TIME | TIME WITH TIME ZONE`
#' @param col1 `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIGNUM | DATE | TIMESTAMP | INTERVAL`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIGNUM | DATE | INTERVAL | TIMESTAMP | TIME | TIME WITH TIME ZONE`
#' @examples
#' \dontrun{
#' character(0)
#' }
subtract <- function(col0 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIGNUM | DATE | TIMESTAMP | INTERVAL | TIME | TIME WITH TIME ZONE`, col1 = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIGNUM | DATE | TIMESTAMP | INTERVAL`) {
  stop("DuckDB function subtract() is not available in R.")
}

#' DuckDB function suffix
#'
#' @description
#' Returns `true` if `string` ends with `search_string`.
#'
#' @name suffix
#' @usage suffix(string = VARCHAR, search_string = VARCHAR)
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' suffix('abc', 'bc')
#' }
suffix <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function suffix() is not available in R.")
}

#' DuckDB function sum
#'
#' @description
#' Calculates the sum value for all tuples in arg.
#'
#' @name sum
#' @usage NULL
#' @param arg `DECIMAL | BOOLEAN | SMALLINT | INTEGER | BIGINT | HUGEINT | DOUBLE | BIGNUM`
#' @return `DECIMAL | HUGEINT | DOUBLE | BIGNUM`
#' @examples
#' \dontrun{
#' sum(A)
#' }
sum <- function(arg = `DECIMAL | BOOLEAN | SMALLINT | INTEGER | BIGINT | HUGEINT | DOUBLE | BIGNUM`) {
  stop("DuckDB function sum() is not available in R.")
}

#' DuckDB function sum_no_overflow
#'
#' @description
#' Internal only. Calculates the sum value for all tuples in arg without overflow checks.
#'
#' @name sum_no_overflow
#' @usage NULL
#' @param arg `INTEGER | BIGINT | DECIMAL`
#' @return `HUGEINT | DECIMAL`
#' @examples
#' \dontrun{
#' sum_no_overflow(A)
#' }
sum_no_overflow <- function(arg = `INTEGER | BIGINT | DECIMAL`) {
  stop("DuckDB function sum_no_overflow() is not available in R.")
}

#' DuckDB function sumkahan
#'
#' @description
#' Calculates the sum using a more accurate floating point summation (Kahan Sum).
#'
#' @name sumkahan
#' @usage sumkahan(arg = DOUBLE)
#' @param arg `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' sumkahan(A)
#' }
sumkahan <- function(arg = DOUBLE) {
  stop("DuckDB function sumkahan() is not available in R.")
}

#' DuckDB function tan
#'
#' @description
#' Computes the tan of x.
#'
#' @name tan
#' @usage tan(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' tan(90)
#' }
tan <- function(x = DOUBLE) {
  stop("DuckDB function tan() is not available in R.")
}

#' DuckDB function tanh
#'
#' @description
#' Computes the hyperbolic tan of x.
#'
#' @name tanh
#' @usage tanh(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' tanh(1)
#' }
tanh <- function(x = DOUBLE) {
  stop("DuckDB function tanh() is not available in R.")
}

#' DuckDB function time_bucket
#'
#' @description
#' Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets.
#'
#' @name time_bucket
#' @usage NULL
#' @param bucket_width `INTERVAL`
#' @param timestamp `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @param origin `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR`
#' @return `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @examples
#' \dontrun{
#' time_bucket(INTERVAL '2 weeks', TIMESTAMP '1992-04-20 15:26:00-07', TIMESTAMP '1992-04-01 00:00:00-07')
#' }
time_bucket <- function(bucket_width = INTERVAL, timestamp = `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`, origin = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR`) {
  stop("DuckDB function time_bucket() is not available in R.")
}

#' DuckDB function timetz_byte_comparable
#'
#' @description
#' Converts a TIME WITH TIME ZONE to an integer sort key.
#'
#' @name timetz_byte_comparable
#' @usage timetz_byte_comparable(time_tz = `TIME WITH TIME ZONE`)
#' @param time_tz `TIME WITH TIME ZONE`
#' @return `UBIGINT`
#' @examples
#' \dontrun{
#' timetz_byte_comparable('18:18:16.21-07:00'::TIMETZ)
#' }
timetz_byte_comparable <- function(time_tz = `TIME WITH TIME ZONE`) {
  stop("DuckDB function timetz_byte_comparable() is not available in R.")
}

#' DuckDB function timezone
#'
#' @description
#' Extract the timezone component from a date or timestamp.
#'
#' @name timezone
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR`
#' @param col1 `TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT | TIME WITH TIME ZONE | TIMESTAMP WITH TIME ZONE | TIMESTAMP`
#' @examples
#' \dontrun{
#' timezone(timestamp '2021-08-03 11:59:44.123456')
#' }
timezone <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR`, col1 = `TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function timezone() is not available in R.")
}

#' DuckDB function timezone_hour
#'
#' @description
#' Extract the timezone_hour component from a date or timestamp.
#'
#' @name timezone_hour
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' timezone_hour(timestamp '2021-08-03 11:59:44.123456')
#' }
timezone_hour <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function timezone_hour() is not available in R.")
}

#' DuckDB function timezone_minute
#'
#' @description
#' Extract the timezone_minute component from a date or timestamp.
#'
#' @name timezone_minute
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' timezone_minute(timestamp '2021-08-03 11:59:44.123456')
#' }
timezone_minute <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function timezone_minute() is not available in R.")
}

#' DuckDB function to_base
#'
#' @description
#' Converts `number` to a string in the given base `radix`, optionally padding with leading zeros to `min_length`.
#'
#' @name to_base
#' @usage NULL
#' @param number `BIGINT`
#' @param radix `INTEGER`
#' @param min_length `INTEGER`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' to_base(42, 16, 5)
#' }
to_base <- function(number = BIGINT, radix = INTEGER, min_length = INTEGER) {
  stop("DuckDB function to_base() is not available in R.")
}

#' DuckDB function to_base64
#'
#' @description
#' Converts a `blob` to a base64 encoded string.
#'
#' @name to_base64
#' @usage to_base64(blob = BLOB)
#' @param blob `BLOB`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' to_base64('A'::BLOB)
#' }
to_base64 <- function(blob = BLOB) {
  stop("DuckDB function to_base64() is not available in R.")
}

#' DuckDB function to_binary
#'
#' @description
#' Converts the `string` to binary representation.
#'
#' Converts the `value` to binary representation.
#'
#' @name to_binary
#' @usage NULL
#' @param string `VARCHAR`
#' @param value `BIGNUM | UBIGINT | BIGINT | HUGEINT | UHUGEINT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' to_binary('Aa')
#' to_binary(42)
#' }
to_binary <- function(string = VARCHAR, value = `BIGNUM | UBIGINT | BIGINT | HUGEINT | UHUGEINT`) {
  stop("DuckDB function to_binary() is not available in R.")
}

#' DuckDB function to_centuries
#'
#' @description
#' Construct a century interval.
#'
#' @name to_centuries
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_centuries(5)
#' }
to_centuries <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_centuries() is not available in R.")
}

#' DuckDB function to_days
#'
#' @description
#' Construct a day interval.
#'
#' @name to_days
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_days(5)
#' }
to_days <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_days() is not available in R.")
}

#' DuckDB function to_decades
#'
#' @description
#' Construct a decade interval.
#'
#' @name to_decades
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_decades(5)
#' }
to_decades <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_decades() is not available in R.")
}

#' DuckDB function to_hex
#'
#' @description
#' Converts the `string` to hexadecimal representation.
#'
#' Converts the `value` to `VARCHAR` using hexadecimal representation.
#'
#' Converts `blob` to `VARCHAR` using hexadecimal encoding.
#'
#' @name to_hex
#' @usage NULL
#' @param string `VARCHAR`
#' @param value `BIGNUM | BIGINT | UBIGINT | HUGEINT | UHUGEINT`
#' @param blob `BLOB`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' to_hex('Hello')
#' to_hex(42)
#' to_hex('\xAA\xBB'::BLOB)
#' }
to_hex <- function(string = VARCHAR, value = `BIGNUM | BIGINT | UBIGINT | HUGEINT | UHUGEINT`, blob = BLOB) {
  stop("DuckDB function to_hex() is not available in R.")
}

#' DuckDB function to_hours
#'
#' @description
#' Construct a hour interval.
#'
#' @name to_hours
#' @usage to_hours(integer = BIGINT)
#' @param integer `BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_hours(5)
#' }
to_hours <- function(integer = BIGINT) {
  stop("DuckDB function to_hours() is not available in R.")
}

#' DuckDB function to_microseconds
#'
#' @description
#' Construct a microsecond interval.
#'
#' @name to_microseconds
#' @usage to_microseconds(integer = BIGINT)
#' @param integer `BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_microseconds(5)
#' }
to_microseconds <- function(integer = BIGINT) {
  stop("DuckDB function to_microseconds() is not available in R.")
}

#' DuckDB function to_millennia
#'
#' @description
#' Construct a millenium interval.
#'
#' @name to_millennia
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_millennia(1)
#' }
to_millennia <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_millennia() is not available in R.")
}

#' DuckDB function to_milliseconds
#'
#' @description
#' Construct a millisecond interval.
#'
#' @name to_milliseconds
#' @usage to_milliseconds(double = DOUBLE)
#' @param double `DOUBLE`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_milliseconds(5.5)
#' }
to_milliseconds <- function(double = DOUBLE) {
  stop("DuckDB function to_milliseconds() is not available in R.")
}

#' DuckDB function to_minutes
#'
#' @description
#' Construct a minute interval.
#'
#' @name to_minutes
#' @usage to_minutes(integer = BIGINT)
#' @param integer `BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_minutes(5)
#' }
to_minutes <- function(integer = BIGINT) {
  stop("DuckDB function to_minutes() is not available in R.")
}

#' DuckDB function to_months
#'
#' @description
#' Construct a month interval.
#'
#' @name to_months
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_months(5)
#' }
to_months <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_months() is not available in R.")
}

#' DuckDB function to_quarters
#'
#' @description
#' Construct a quarter interval.
#'
#' @name to_quarters
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_quarters(5)
#' }
to_quarters <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_quarters() is not available in R.")
}

#' DuckDB function to_seconds
#'
#' @description
#' Construct a second interval.
#'
#' @name to_seconds
#' @usage to_seconds(double = DOUBLE)
#' @param double `DOUBLE`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_seconds(5.5)
#' }
to_seconds <- function(double = DOUBLE) {
  stop("DuckDB function to_seconds() is not available in R.")
}

#' DuckDB function to_timestamp
#'
#' @description
#' Converts secs since epoch to a timestamp with time zone.
#'
#' @name to_timestamp
#' @usage to_timestamp(sec = DOUBLE)
#' @param sec `DOUBLE`
#' @return `TIMESTAMP WITH TIME ZONE`
#' @examples
#' \dontrun{
#' to_timestamp(1284352323.5)
#' }
to_timestamp <- function(sec = DOUBLE) {
  stop("DuckDB function to_timestamp() is not available in R.")
}

#' DuckDB function to_weeks
#'
#' @description
#' Construct a week interval.
#'
#' @name to_weeks
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_weeks(5)
#' }
to_weeks <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_weeks() is not available in R.")
}

#' DuckDB function to_years
#'
#' @description
#' Construct a year interval.
#'
#' @name to_years
#' @usage NULL
#' @param integer `INTEGER | BIGINT`
#' @return `INTERVAL`
#' @examples
#' \dontrun{
#' to_years(5)
#' }
to_years <- function(integer = `INTEGER | BIGINT`) {
  stop("DuckDB function to_years() is not available in R.")
}

#' DuckDB function translate
#'
#' @description
#' Replaces each character in `string` that matches a character in the `from` set with the corresponding character in the `to` set. If `from` is longer than `to`, occurrences of the extra characters in `from` are deleted.
#'
#' @name translate
#' @usage translate(string = VARCHAR, from = VARCHAR, to = VARCHAR)
#' @param string `VARCHAR`
#' @param from `VARCHAR`
#' @param to `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' translate('12345', '143', 'ax')
#' }
translate <- function(string = VARCHAR, from = VARCHAR, to = VARCHAR) {
  stop("DuckDB function translate() is not available in R.")
}

#' DuckDB function trim
#'
#' @description
#' Removes any occurrences of any of the `characters` from either side of the `string`. `characters` defaults to `space`.
#'
#' @name trim
#' @usage NULL
#' @param string `VARCHAR`
#' @param characters `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' c("trim('    test  ')", "trim('>>>>test<<', '><')")
#' }
trim <- function(string = VARCHAR, characters = VARCHAR) {
  stop("DuckDB function trim() is not available in R.")
}

#' DuckDB function trunc
#'
#' @description
#' Truncates the number.
#'
#' @name trunc
#' @usage NULL
#' @param x `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @param col1 `INTEGER`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`
#' @examples
#' \dontrun{
#' trunc(17.4)
#' }
trunc <- function(x = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | FLOAT | DOUBLE | DECIMAL | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT`, col1 = INTEGER) {
  stop("DuckDB function trunc() is not available in R.")
}

#' DuckDB function try_strptime
#'
#' @description
#' Converts the `string` text to timestamp according to the format string. Returns `NULL` on failure.
#'
#' @name try_strptime
#' @usage NULL
#' @param text `VARCHAR`
#' @param format `VARCHAR | VARCHAR[]`
#' @return `TIMESTAMP`
#' @examples
#' \dontrun{
#' try_strptime('Wed, 1 January 1992 - 08:38:40 PM', '%a, %-d %B %Y - %I:%M:%S %p')
#' }
try_strptime <- function(text = VARCHAR, format = `VARCHAR | VARCHAR[]`) {
  stop("DuckDB function try_strptime() is not available in R.")
}

#' DuckDB function typeof
#'
#' @description
#' Returns the name of the data type of the result of the expression.
#'
#' @name typeof
#' @usage typeof(expression = ANY)
#' @param expression `ANY`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' typeof('abc')
#' }
typeof <- function(expression = ANY) {
  stop("DuckDB function typeof() is not available in R.")
}

#' DuckDB function ucase
#'
#' @description
#' Converts `string` to upper case.
#'
#' @name ucase
#' @usage ucase(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' ucase('Hello')
#' }
ucase <- function(string = VARCHAR) {
  stop("DuckDB function ucase() is not available in R.")
}

#' DuckDB function unbin
#'
#' @description
#' Converts a `value` from binary representation to a blob.
#'
#' @name unbin
#' @usage unbin(value = VARCHAR)
#' @param value `VARCHAR`
#' @return `BLOB`
#' @examples
#' \dontrun{
#' unbin('0110')
#' }
unbin <- function(value = VARCHAR) {
  stop("DuckDB function unbin() is not available in R.")
}

#' DuckDB function unhex
#'
#' @description
#' Converts a `value` from hexadecimal representation to a blob.
#'
#' @name unhex
#' @usage unhex(value = VARCHAR)
#' @param value `VARCHAR`
#' @return `BLOB`
#' @examples
#' \dontrun{
#' unhex('2A')
#' }
unhex <- function(value = VARCHAR) {
  stop("DuckDB function unhex() is not available in R.")
}

#' DuckDB function unicode
#'
#' @description
#' Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.
#'
#' @name unicode
#' @usage unicode(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `INTEGER`
#' @examples
#' \dontrun{
#' [unicode('âbcd'), unicode('â'), unicode(''), unicode(NULL)]
#' }
unicode <- function(string = VARCHAR) {
  stop("DuckDB function unicode() is not available in R.")
}

#' DuckDB function union_extract
#'
#' @description
#' Extract the value with the named tags from the union. NULL if the tag is not currently selected.
#'
#' @name union_extract
#' @usage union_extract(union = UNION, tag = VARCHAR)
#' @param union `UNION`
#' @param tag `VARCHAR`
#' @return `ANY`
#' @examples
#' \dontrun{
#' union_extract(s, 'k')
#' }
union_extract <- function(union = UNION, tag = VARCHAR) {
  stop("DuckDB function union_extract() is not available in R.")
}

#' DuckDB function union_tag
#'
#' @description
#' Retrieve the currently selected tag of the union as an ENUM.
#'
#' @name union_tag
#' @usage union_tag(union = UNION)
#' @param union `UNION`
#' @return `ANY`
#' @examples
#' \dontrun{
#' union_tag(union_value(k := 'foo'))
#' }
union_tag <- function(union = UNION) {
  stop("DuckDB function union_tag() is not available in R.")
}

#' DuckDB function union_value
#'
#' @description
#' Create a single member UNION containing the argument value. The tag of the value will be the bound variable name.
#'
#' @name union_value
#' @usage union_value()

#' @return `UNION`
#' @examples
#' \dontrun{
#' union_value(k := 'hello')
#' }
union_value <- function() {
  stop("DuckDB function union_value() is not available in R.")
}

#' DuckDB function unpivot_list
#'
#' @description
#' Identical to list_value, but generated as part of unpivot for better error messages.
#'
#' @name unpivot_list
#' @usage unpivot_list()

#' @return `LIST`
#' @examples
#' \dontrun{
#' unpivot_list(4, 5, 6)
#' }
unpivot_list <- function() {
  stop("DuckDB function unpivot_list() is not available in R.")
}

#' DuckDB function upper
#'
#' @description
#' Converts `string` to upper case.
#'
#' @name upper
#' @usage upper(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' upper('Hello')
#' }
upper <- function(string = VARCHAR) {
  stop("DuckDB function upper() is not available in R.")
}

#' DuckDB function url_decode
#'
#' @description
#' Decodes a URL from a representation using Percent-Encoding.
#'
#' @name url_decode
#' @usage url_decode(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' url_decode('https%3A%2F%2Fduckdb.org%2Fwhy_duckdb%23portable')
#' }
url_decode <- function(string = VARCHAR) {
  stop("DuckDB function url_decode() is not available in R.")
}

#' DuckDB function url_encode
#'
#' @description
#' Encodes a URL to a representation using Percent-Encoding.
#'
#' @name url_encode
#' @usage url_encode(string = VARCHAR)
#' @param string `VARCHAR`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' url_encode('this string has/ special+ characters>')
#' }
url_encode <- function(string = VARCHAR) {
  stop("DuckDB function url_encode() is not available in R.")
}

#' DuckDB function uuid_extract_timestamp
#'
#' @description
#' Extract the timestamp for the given UUID v7.
#'
#' @name uuid_extract_timestamp
#' @usage uuid_extract_timestamp(uuid = UUID)
#' @param uuid `UUID`
#' @return `TIMESTAMP WITH TIME ZONE`
#' @examples
#' \dontrun{
#' uuid_extract_timestamp('019482e4-1441-7aad-8127-eec99573b0a0')
#' }
uuid_extract_timestamp <- function(uuid = UUID) {
  stop("DuckDB function uuid_extract_timestamp() is not available in R.")
}

#' DuckDB function uuid_extract_version
#'
#' @description
#' Extract a version for the given UUID.
#'
#' @name uuid_extract_version
#' @usage uuid_extract_version(uuid = UUID)
#' @param uuid `UUID`
#' @return `UINTEGER`
#' @examples
#' \dontrun{
#' uuid_extract_version('019482e4-1441-7aad-8127-eec99573b0a0')
#' }
uuid_extract_version <- function(uuid = UUID) {
  stop("DuckDB function uuid_extract_version() is not available in R.")
}

#' DuckDB function var_pop
#'
#' @description
#' Returns the population variance.
#'
#' @name var_pop
#' @usage var_pop(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' character(0)
#' }
var_pop <- function(x = DOUBLE) {
  stop("DuckDB function var_pop() is not available in R.")
}

#' DuckDB function var_samp
#'
#' @description
#' Returns the sample variance of all input values.
#'
#' @name var_samp
#' @usage var_samp(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' (SUM(x^2) - SUM(x)^2 / COUNT(x)) / (COUNT(x) - 1)
#' }
var_samp <- function(x = DOUBLE) {
  stop("DuckDB function var_samp() is not available in R.")
}

#' DuckDB function variance
#'
#' @description
#' Returns the sample variance of all input values.
#'
#' @name variance
#' @usage variance(x = DOUBLE)
#' @param x `DOUBLE`
#' @return `DOUBLE`
#' @examples
#' \dontrun{
#' (SUM(x^2) - SUM(x)^2 / COUNT(x)) / (COUNT(x) - 1)
#' }
variance <- function(x = DOUBLE) {
  stop("DuckDB function variance() is not available in R.")
}

#' DuckDB function variant_extract
#'
#' @description
#' DuckDB function `variant_extract()`.
#'
#' @name variant_extract
#' @usage NULL
#' @param col0 `VARIANT`
#' @param col1 `VARCHAR | UINTEGER`
#' @return `VARIANT`
#' @examples
#' \dontrun{
#' character(0)
#' }
variant_extract <- function(col0 = VARIANT, col1 = `VARCHAR | UINTEGER`) {
  stop("DuckDB function variant_extract() is not available in R.")
}

#' DuckDB function variant_typeof
#'
#' @description
#' Returns the internal type of the `input_variant`.
#'
#' @name variant_typeof
#' @usage variant_typeof(input_variant = VARIANT)
#' @param input_variant `VARIANT`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' variant_typeof({'a': 42, 'b': [1,2,3])::VARIANT)
#' }
variant_typeof <- function(input_variant = VARIANT) {
  stop("DuckDB function variant_typeof() is not available in R.")
}

#' DuckDB function vector_type
#'
#' @description
#' Returns the VectorType of a given column.
#'
#' @name vector_type
#' @usage vector_type(col = ANY)
#' @param col `ANY`
#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' vector_type(col)
#' }
vector_type <- function(col = ANY) {
  stop("DuckDB function vector_type() is not available in R.")
}

#' DuckDB function version
#'
#' @description
#' Returns the currently active version of DuckDB in this format: v0.3.2	.
#'
#' @name version
#' @usage version()

#' @return `VARCHAR`
#' @examples
#' \dontrun{
#' version()
#' }
version <- function() {
  stop("DuckDB function version() is not available in R.")
}

#' DuckDB function week
#'
#' @description
#' Extract the week component from a date or timestamp.
#'
#' @name week
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' week(timestamp '2021-08-03 11:59:44.123456')
#' }
week <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function week() is not available in R.")
}

#' DuckDB function weekday
#'
#' @description
#' Extract the weekday component from a date or timestamp.
#'
#' @name weekday
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' weekday(timestamp '2021-08-03 11:59:44.123456')
#' }
weekday <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function weekday() is not available in R.")
}

#' DuckDB function weekofyear
#'
#' @description
#' Extract the weekofyear component from a date or timestamp.
#'
#' @name weekofyear
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' weekofyear(timestamp '2021-08-03 11:59:44.123456')
#' }
weekofyear <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function weekofyear() is not available in R.")
}

#' DuckDB function xor
#'
#' @description
#' Bitwise XOR.
#'
#' @name xor
#' @usage NULL
#' @param left `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @param right `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @examples
#' \dontrun{
#' xor(17, 5)
#' }
xor <- function(left = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`, right = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`) {
  stop("DuckDB function xor() is not available in R.")
}

#' DuckDB function year
#'
#' @description
#' Extract the year component from a date or timestamp.
#'
#' @name year
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' year(timestamp '2021-08-03 11:59:44.123456')
#' }
year <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function year() is not available in R.")
}

#' DuckDB function yearweek
#'
#' @description
#' Extract the yearweek component from a date or timestamp.
#'
#' @name yearweek
#' @usage NULL
#' @param ts `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`
#' @return `BIGINT`
#' @examples
#' \dontrun{
#' yearweek(timestamp '2021-08-03 11:59:44.123456')
#' }
yearweek <- function(ts = `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE`) {
  stop("DuckDB function yearweek() is not available in R.")
}

#' DuckDB function |
#'
#' @description
#' Bitwise OR.
#'
#' @name or-
#' @usage NULL
#' @param left `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @param right `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @examples
#' \dontrun{
#' 32 | 3
#' }
`|` <- function(left = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`, right = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`) {
  stop("DuckDB function |() is not available in R.")
}

#' DuckDB function ||
#'
#' @description
#' Concatenates two strings, lists, or blobs. Any `NULL` input results in `NULL`. See also `concat(arg1, arg2, ...)` and `list_concat(list1, list2, ...)`.
#'
#' @name or--or
#' @usage `||`(arg1 = ANY, arg2 = ANY)
#' @param arg1 `ANY`
#' @param arg2 `ANY`
#' @return `ANY`
#' @examples
#' \dontrun{
#' c("'Duck' || 'DB'", "[1, 2, 3] || [4, 5, 6]", "'\\xAA'::BLOB || '\\xBB'::BLOB")
#' }
`||` <- function(arg1 = ANY, arg2 = ANY) {
  stop("DuckDB function ||() is not available in R.")
}

#' DuckDB function ~
#'
#' @description
#' Bitwise NOT.
#'
#' @name ~
#' @usage NULL
#' @param input `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @return `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`
#' @examples
#' \dontrun{
#' ~15
#' }
`~` <- function(input = `TINYINT | SMALLINT | INTEGER | BIGINT | HUGEINT | UTINYINT | USMALLINT | UINTEGER | UBIGINT | UHUGEINT | BIT`) {
  stop("DuckDB function ~() is not available in R.")
}

#' DuckDB function ~~
#'
#' @description
#' DuckDB function `~~()`.
#'
#' @name ~~
#' @usage `~~`(col0 = VARCHAR, col1 = VARCHAR)
#' @param col0 `VARCHAR`
#' @param col1 `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' character(0)
#' }
`~~` <- function(col0 = VARCHAR, col1 = VARCHAR) {
  stop("DuckDB function ~~() is not available in R.")
}

#' DuckDB function ~~*
#'
#' @description
#' DuckDB function `~~*()`.
#'
#' @name ~~*
#' @usage `~~*`(col0 = VARCHAR, col1 = VARCHAR)
#' @param col0 `VARCHAR`
#' @param col1 `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' character(0)
#' }
`~~*` <- function(col0 = VARCHAR, col1 = VARCHAR) {
  stop("DuckDB function ~~*() is not available in R.")
}

#' DuckDB function ~~~
#'
#' @description
#' DuckDB function `~~~()`.
#'
#' @name ~~~
#' @usage `~~~`(col0 = VARCHAR, col1 = VARCHAR)
#' @param col0 `VARCHAR`
#' @param col1 `VARCHAR`
#' @return `BOOLEAN`
#' @examples
#' \dontrun{
#' character(0)
#' }
`~~~` <- function(col0 = VARCHAR, col1 = VARCHAR) {
  stop("DuckDB function ~~~() is not available in R.")
}

