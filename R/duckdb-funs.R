# Generated by do_update_duckdb_funs(), do not edit by hand

#' DuckDB function acos
#'
#' Computes the arccosine of x.
#'
#' @name acos
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' acos(0.5)
#' }
duckdb_fun_acos <- function(x = DOUBLE) {
  stop("DuckDB function acos() is not available in R.")
}

#' DuckDB function acosh
#'
#' Computes the inverse hyperbolic cos of x.
#'
#' @name acosh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' acosh(2.3)
#' }
duckdb_fun_acosh <- function(x = DOUBLE) {
  stop("DuckDB function acosh() is not available in R.")
}

#' DuckDB function alias
#'
#' Returns the name of a given expression.
#'
#' @name alias
#' @usage NULL
#' @param expr `ANY`
#' @examples
#' \dontrun{
#' alias(42 + 1)
#' }
duckdb_fun_alias <- function(expr = ANY) {
  stop("DuckDB function alias() is not available in R.")
}

#' DuckDB function apply
#'
#' Returns a list that is the result of applying the lambda function to each element of the input list. See the Lambda Functions section for more details.
#'
#' @name apply
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_transform([1, 2, 3], x -> x + 1)
#' }
duckdb_fun_apply <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function apply() is not available in R.")
}

#' DuckDB function array_apply
#'
#' Returns a list that is the result of applying the lambda function to each element of the input list. See the Lambda Functions section for more details.
#'
#' @name array_apply
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_transform([1, 2, 3], x -> x + 1)
#' }
duckdb_fun_array_apply <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function array_apply() is not available in R.")
}

#' DuckDB function array_cat
#'
#' Concatenates two lists.
#'
#' @name array_cat
#' @usage NULL
#' @param list1 `ANY[]`
#' @param list2 `ANY[]`
#' @examples
#' \dontrun{
#' list_concat([2, 3], [4, 5, 6])
#' }
duckdb_fun_array_cat <- function(list1 = `ANY[]`, list2 = `ANY[]`) {
  stop("DuckDB function array_cat() is not available in R.")
}

#' DuckDB function array_concat
#'
#' Concatenates two lists.
#'
#' @name array_concat
#' @usage NULL
#' @param list1 `ANY[]`
#' @param list2 `ANY[]`
#' @examples
#' \dontrun{
#' list_concat([2, 3], [4, 5, 6])
#' }
duckdb_fun_array_concat <- function(list1 = `ANY[]`, list2 = `ANY[]`) {
  stop("DuckDB function array_concat() is not available in R.")
}

#' DuckDB function array_contains
#'
#' Returns true if the list contains the element.
#'
#' @name array_contains
#' @usage NULL
#' @param list `ANY[]`
#' @param element `ANY`
#' @examples
#' \dontrun{
#' list_contains([1, 2, NULL], 1)
#' }
duckdb_fun_array_contains <- function(list = `ANY[]`, element = ANY) {
  stop("DuckDB function array_contains() is not available in R.")
}

#' DuckDB function array_distinct
#'
#' Removes all duplicates and NULLs from a list. Does not preserve the original order.
#'
#' @name array_distinct
#' @usage NULL
#' @param list `ANY[]`
#' @examples
#' \dontrun{
#' list_distinct([1, 1, NULL, -3, 1, 5])
#' }
duckdb_fun_array_distinct <- function(list = `ANY[]`) {
  stop("DuckDB function array_distinct() is not available in R.")
}

#' DuckDB function array_filter
#'
#' Constructs a list from those elements of the input list for which the lambda function returns true.
#'
#' @name array_filter
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_filter([3, 4, 5], x -> x > 4)
#' }
duckdb_fun_array_filter <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function array_filter() is not available in R.")
}

#' DuckDB function array_has
#'
#' Returns true if the list contains the element.
#'
#' @name array_has
#' @usage NULL
#' @param list `ANY[]`
#' @param element `ANY`
#' @examples
#' \dontrun{
#' list_contains([1, 2, NULL], 1)
#' }
duckdb_fun_array_has <- function(list = `ANY[]`, element = ANY) {
  stop("DuckDB function array_has() is not available in R.")
}

#' DuckDB function array_has_all
#'
#' Returns true if all elements of l2 are in l1. NULLs are ignored.
#'
#' @name array_has_all
#' @usage NULL
#' @param l1 `ANY[]`
#' @param l2 `ANY[]`
#' @examples
#' \dontrun{
#' list_has_all([1, 2, 3], [2, 3])
#' }
duckdb_fun_array_has_all <- function(l1 = `ANY[]`, l2 = `ANY[]`) {
  stop("DuckDB function array_has_all() is not available in R.")
}

#' DuckDB function array_has_any
#'
#' Returns true if the lists have any element in common. NULLs are ignored.
#'
#' @name array_has_any
#' @usage NULL
#' @param l1 `ANY[]`
#' @param l2 `ANY[]`
#' @examples
#' \dontrun{
#' list_has_any([1, 2, 3], [2, 3, 4])
#' }
duckdb_fun_array_has_any <- function(l1 = `ANY[]`, l2 = `ANY[]`) {
  stop("DuckDB function array_has_any() is not available in R.")
}

#' DuckDB function array_indexof
#'
#' Returns the index of the element if the list contains the element. If the element is not found, it returns NULL.
#'
#' @name array_indexof
#' @usage NULL
#' @param list `ANY[]`
#' @param element `ANY`
#' @examples
#' \dontrun{
#' list_position([1, 2, NULL], 2)
#' }
duckdb_fun_array_indexof <- function(list = `ANY[]`, element = ANY) {
  stop("DuckDB function array_indexof() is not available in R.")
}

#' DuckDB function array_position
#'
#' Returns the index of the element if the list contains the element. If the element is not found, it returns NULL.
#'
#' @name array_position
#' @usage NULL
#' @param list `ANY[]`
#' @param element `ANY`
#' @examples
#' \dontrun{
#' list_position([1, 2, NULL], 2)
#' }
duckdb_fun_array_position <- function(list = `ANY[]`, element = ANY) {
  stop("DuckDB function array_position() is not available in R.")
}

#' DuckDB function array_reduce
#'
#' Returns a single value that is the result of applying the lambda function to each element of the input list, starting with the first element and then repeatedly applying the lambda function to the result of the previous application and the next element of the list.
#'
#' @name array_reduce
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_reduce([1, 2, 3], (x, y) -> x + y)
#' }
duckdb_fun_array_reduce <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function array_reduce() is not available in R.")
}

#' DuckDB function array_select
#'
#' Returns a list based on the elements selected by the index_list.
#'
#' @name array_select
#' @usage NULL
#' @param value_list `ANY[]`
#' @param index_list `BIGINT[]`
#' @examples
#' \dontrun{
#' list_select([10, 20, 30, 40], [1, 4])
#' }
duckdb_fun_array_select <- function(value_list = `ANY[]`, index_list = `BIGINT[]`) {
  stop("DuckDB function array_select() is not available in R.")
}

#' DuckDB function array_transform
#'
#' Returns a list that is the result of applying the lambda function to each element of the input list. See the Lambda Functions section for more details.
#'
#' @name array_transform
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_transform([1, 2, 3], x -> x + 1)
#' }
duckdb_fun_array_transform <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function array_transform() is not available in R.")
}

#' DuckDB function array_unique
#'
#' Counts the unique elements of a list.
#'
#' @name array_unique
#' @usage NULL
#' @param list `ANY[]`
#' @examples
#' \dontrun{
#' list_unique([1, 1, NULL, -3, 1, 5])
#' }
duckdb_fun_array_unique <- function(list = `ANY[]`) {
  stop("DuckDB function array_unique() is not available in R.")
}

#' DuckDB function array_where
#'
#' Returns a list with the BOOLEANs in mask_list applied as a mask to the value_list.
#'
#' @name array_where
#' @usage NULL
#' @param value_list `ANY[]`
#' @param mask_list `BOOLEAN[]`
#' @examples
#' \dontrun{
#' list_where([10, 20, 30, 40], [true, false, false, true])
#' }
duckdb_fun_array_where <- function(value_list = `ANY[]`, mask_list = `BOOLEAN[]`) {
  stop("DuckDB function array_where() is not available in R.")
}

#' DuckDB function ascii
#'
#' Returns an integer that represents the Unicode code point of the first character of the string.
#'
#' @name ascii
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' ascii('Î©')
#' }
duckdb_fun_ascii <- function(string = VARCHAR) {
  stop("DuckDB function ascii() is not available in R.")
}

#' DuckDB function asin
#'
#' Computes the arcsine of x.
#'
#' @name asin
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' asin(0.5)
#' }
duckdb_fun_asin <- function(x = DOUBLE) {
  stop("DuckDB function asin() is not available in R.")
}

#' DuckDB function asinh
#'
#' Computes the inverse hyperbolic sin of x.
#'
#' @name asinh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' asinh(0.5)
#' }
duckdb_fun_asinh <- function(x = DOUBLE) {
  stop("DuckDB function asinh() is not available in R.")
}

#' DuckDB function atan
#'
#' Computes the arctangent of x.
#'
#' @name atan
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' atan(0.5)
#' }
duckdb_fun_atan <- function(x = DOUBLE) {
  stop("DuckDB function atan() is not available in R.")
}

#' DuckDB function atan2
#'
#' Computes the arctangent (y, x).
#'
#' @name atan2
#' @usage NULL
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' atan2(1.0, 0.0)
#' }
duckdb_fun_atan2 <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function atan2() is not available in R.")
}

#' DuckDB function atanh
#'
#' Computes the inverse hyperbolic tan of x.
#'
#' @name atanh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' atanh(0.5)
#' }
duckdb_fun_atanh <- function(x = DOUBLE) {
  stop("DuckDB function atanh() is not available in R.")
}

#' DuckDB function base64
#'
#' Convert a blob to a base64 encoded string.
#'
#' @name base64
#' @usage NULL
#' @param blob `BLOB`
#' @examples
#' \dontrun{
#' base64('A'::blob)
#' }
duckdb_fun_base64 <- function(blob = BLOB) {
  stop("DuckDB function base64() is not available in R.")
}

#' DuckDB function bit_position
#'
#' Returns first starting index of the specified substring within bits, or zero if it is not present. The first (leftmost) bit is indexed 1.
#'
#' @name bit_position
#' @usage NULL
#' @param substring `BIT`
#' @param bitstring `BIT`
#' @examples
#' \dontrun{
#' bit_position('010'::BIT, '1110101'::BIT)
#' }
duckdb_fun_bit_position <- function(substring = BIT, bitstring = BIT) {
  stop("DuckDB function bit_position() is not available in R.")
}

#' DuckDB function can_cast_implicitly
#'
#' Whether or not we can implicitly cast from the source type to the other type.
#'
#' @name can_cast_implicitly
#' @usage NULL
#' @param source_type `ANY`
#' @param target_type `ANY`
#' @examples
#' \dontrun{
#' can_implicitly_cast(NULL::INTEGER, NULL::BIGINT)
#' }
duckdb_fun_can_cast_implicitly <- function(source_type = ANY, target_type = ANY) {
  stop("DuckDB function can_cast_implicitly() is not available in R.")
}

#' DuckDB function cbrt
#'
#' Returns the cube root of x.
#'
#' @name cbrt
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cbrt(8)
#' }
duckdb_fun_cbrt <- function(x = DOUBLE) {
  stop("DuckDB function cbrt() is not available in R.")
}

#' DuckDB function chr
#'
#' Returns a character which is corresponding the ASCII code value or Unicode code point.
#'
#' @name chr
#' @usage NULL
#' @param code_point `INTEGER`
#' @examples
#' \dontrun{
#' chr(65)
#' }
duckdb_fun_chr <- function(code_point = INTEGER) {
  stop("DuckDB function chr() is not available in R.")
}

#' DuckDB function cos
#'
#' Computes the cos of x.
#'
#' @name cos
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cos(90)
#' }
duckdb_fun_cos <- function(x = DOUBLE) {
  stop("DuckDB function cos() is not available in R.")
}

#' DuckDB function cosh
#'
#' Computes the hyperbolic cos of x.
#'
#' @name cosh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cosh(1)
#' }
duckdb_fun_cosh <- function(x = DOUBLE) {
  stop("DuckDB function cosh() is not available in R.")
}

#' DuckDB function cot
#'
#' Computes the cotangent of x.
#'
#' @name cot
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cot(0.5)
#' }
duckdb_fun_cot <- function(x = DOUBLE) {
  stop("DuckDB function cot() is not available in R.")
}

#' DuckDB function current_setting
#'
#' Returns the current value of the configuration setting.
#'
#' @name current_setting
#' @usage NULL
#' @param setting_name `VARCHAR`
#' @examples
#' \dontrun{
#' current_setting('access_mode')
#' }
duckdb_fun_current_setting <- function(setting_name = VARCHAR) {
  stop("DuckDB function current_setting() is not available in R.")
}

#' DuckDB function damerau_levenshtein
#'
#' Extension of Levenshtein distance to also include transposition of adjacent characters as an allowed edit operation. In other words, the minimum number of edit operations (insertions, deletions, substitutions or transpositions) required to change one string to another. Different case is considered different.
#'
#' @name damerau_levenshtein
#' @usage NULL
#' @param str1 `VARCHAR`
#' @param str2 `VARCHAR`
#' @examples
#' \dontrun{
#' damerau_levenshtein('hello', 'world')
#' }
duckdb_fun_damerau_levenshtein <- function(str1 = VARCHAR, str2 = VARCHAR) {
  stop("DuckDB function damerau_levenshtein() is not available in R.")
}

#' DuckDB function decode
#'
#' Convert blob to varchar. Fails if blob is not valid utf-8.
#'
#' @name decode
#' @usage NULL
#' @param blob `BLOB`
#' @examples
#' \dontrun{
#' decode('\xC3\xBC'::BLOB)
#' }
duckdb_fun_decode <- function(blob = BLOB) {
  stop("DuckDB function decode() is not available in R.")
}

#' DuckDB function degrees
#'
#' Converts radians to degrees.
#'
#' @name degrees
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' degrees(pi())
#' }
duckdb_fun_degrees <- function(x = DOUBLE) {
  stop("DuckDB function degrees() is not available in R.")
}

#' DuckDB function editdist3
#'
#' The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Different case is considered different.
#'
#' @name editdist3
#' @usage NULL
#' @param str1 `VARCHAR`
#' @param str2 `VARCHAR`
#' @examples
#' \dontrun{
#' levenshtein('duck','db')
#' }
duckdb_fun_editdist3 <- function(str1 = VARCHAR, str2 = VARCHAR) {
  stop("DuckDB function editdist3() is not available in R.")
}

#' DuckDB function encode
#'
#' Convert varchar to blob. Converts utf-8 characters into literal encoding.
#'
#' @name encode
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' encode('my_string_with_Ã¼')
#' }
duckdb_fun_encode <- function(string = VARCHAR) {
  stop("DuckDB function encode() is not available in R.")
}

#' DuckDB function enum_code
#'
#' Returns the numeric value backing the given enum value.
#'
#' @name enum_code
#' @usage NULL
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_code('happy'::mood)
#' }
duckdb_fun_enum_code <- function(enum = ANY) {
  stop("DuckDB function enum_code() is not available in R.")
}

#' DuckDB function enum_first
#'
#' Returns the first value of the input enum type.
#'
#' @name enum_first
#' @usage NULL
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_first(NULL::mood)
#' }
duckdb_fun_enum_first <- function(enum = ANY) {
  stop("DuckDB function enum_first() is not available in R.")
}

#' DuckDB function enum_last
#'
#' Returns the last value of the input enum type.
#'
#' @name enum_last
#' @usage NULL
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_last(NULL::mood)
#' }
duckdb_fun_enum_last <- function(enum = ANY) {
  stop("DuckDB function enum_last() is not available in R.")
}

#' DuckDB function enum_range
#'
#' Returns all values of the input enum type as an array.
#'
#' @name enum_range
#' @usage NULL
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_range(NULL::mood)
#' }
duckdb_fun_enum_range <- function(enum = ANY) {
  stop("DuckDB function enum_range() is not available in R.")
}

#' DuckDB function enum_range_boundary
#'
#' Returns the range between the two given enum values as an array. The values must be of the same enum type. When the first parameter is NULL, the result starts with the first value of the enum type. When the second parameter is NULL, the result ends with the last value of the enum type.
#'
#' @name enum_range_boundary
#' @usage NULL
#' @param start `ANY`
#' @param end `ANY`
#' @examples
#' \dontrun{
#' enum_range_boundary(NULL, 'happy'::mood)
#' }
duckdb_fun_enum_range_boundary <- function(start = ANY, end = ANY) {
  stop("DuckDB function enum_range_boundary() is not available in R.")
}

#' DuckDB function even
#'
#' Rounds x to next even number by rounding away from zero.
#'
#' @name even
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' even(2.9)
#' }
duckdb_fun_even <- function(x = DOUBLE) {
  stop("DuckDB function even() is not available in R.")
}

#' DuckDB function exp
#'
#' Computes e to the power of x.
#'
#' @name exp
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' exp(1)
#' }
duckdb_fun_exp <- function(x = DOUBLE) {
  stop("DuckDB function exp() is not available in R.")
}

#' DuckDB function factorial
#'
#' Factorial of x. Computes the product of the current integer and all integers below it.
#'
#' @name factorial
#' @usage NULL
#' @param x `INTEGER`
#' @examples
#' \dontrun{
#' 4!
#' }
duckdb_fun_factorial <- function(x = INTEGER) {
  stop("DuckDB function factorial() is not available in R.")
}

#' DuckDB function filter
#'
#' Constructs a list from those elements of the input list for which the lambda function returns true.
#'
#' @name filter
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_filter([3, 4, 5], x -> x > 4)
#' }
duckdb_fun_filter <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function filter() is not available in R.")
}

#' DuckDB function flatten
#'
#' Flatten a nested list by one level.
#'
#' @name flatten
#' @usage NULL
#' @param nested_list `ANY[][]`
#' @examples
#' \dontrun{
#' flatten([[1, 2, 3], [4, 5]])
#' }
duckdb_fun_flatten <- function(nested_list = `ANY[][]`) {
  stop("DuckDB function flatten() is not available in R.")
}

#' DuckDB function formatReadableDecimalSize
#'
#' Converts bytes to a human-readable presentation (e.g. 16000 -> 16.0 KB).
#'
#' @name formatReadableDecimalSize
#' @usage NULL
#' @param bytes `BIGINT`
#' @examples
#' \dontrun{
#' format_bytes(1000 * 16)
#' }
duckdb_fun_formatReadableDecimalSize <- function(bytes = BIGINT) {
  stop("DuckDB function formatReadableDecimalSize() is not available in R.")
}

#' DuckDB function formatReadableSize
#'
#' Converts bytes to a human-readable presentation (e.g. 16000 -> 15.6 KiB).
#'
#' @name formatReadableSize
#' @usage NULL
#' @param bytes `BIGINT`
#' @examples
#' \dontrun{
#' format_bytes(1000 * 16)
#' }
duckdb_fun_formatReadableSize <- function(bytes = BIGINT) {
  stop("DuckDB function formatReadableSize() is not available in R.")
}

#' DuckDB function format_bytes
#'
#' Converts bytes to a human-readable presentation (e.g. 16000 -> 15.6 KiB).
#'
#' @name format_bytes
#' @usage NULL
#' @param bytes `BIGINT`
#' @examples
#' \dontrun{
#' format_bytes(1000 * 16)
#' }
duckdb_fun_format_bytes <- function(bytes = BIGINT) {
  stop("DuckDB function format_bytes() is not available in R.")
}

#' DuckDB function from_base64
#'
#' Convert a base64 encoded string to a character string.
#'
#' @name from_base64
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' from_base64('QQ==')
#' }
duckdb_fun_from_base64 <- function(string = VARCHAR) {
  stop("DuckDB function from_base64() is not available in R.")
}

#' DuckDB function from_binary
#'
#' Converts a value from binary representation to a blob.
#'
#' @name from_binary
#' @usage NULL
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' unbin('0110')
#' }
duckdb_fun_from_binary <- function(value = VARCHAR) {
  stop("DuckDB function from_binary() is not available in R.")
}

#' DuckDB function from_hex
#'
#' Converts a value from hexadecimal representation to a blob.
#'
#' @name from_hex
#' @usage NULL
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' unhex('2A')
#' }
duckdb_fun_from_hex <- function(value = VARCHAR) {
  stop("DuckDB function from_hex() is not available in R.")
}

#' DuckDB function gamma
#'
#' Interpolation of (x-1) factorial (so decimal inputs are allowed).
#'
#' @name gamma
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' gamma(5.5)
#' }
duckdb_fun_gamma <- function(x = DOUBLE) {
  stop("DuckDB function gamma() is not available in R.")
}

#' DuckDB function get_bit
#'
#' Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0.
#'
#' @name get_bit
#' @usage NULL
#' @param bitstring `BIT`
#' @param index `INTEGER`
#' @examples
#' \dontrun{
#' get_bit('0110010'::BIT, 2)
#' }
duckdb_fun_get_bit <- function(bitstring = BIT, index = INTEGER) {
  stop("DuckDB function get_bit() is not available in R.")
}

#' DuckDB function hamming
#'
#' The number of positions with different characters for 2 strings of equal length. Different case is considered different.
#'
#' @name hamming
#' @usage NULL
#' @param str1 `VARCHAR`
#' @param str2 `VARCHAR`
#' @examples
#' \dontrun{
#' hamming('duck','luck')
#' }
duckdb_fun_hamming <- function(str1 = VARCHAR, str2 = VARCHAR) {
  stop("DuckDB function hamming() is not available in R.")
}

#' DuckDB function ilike_escape
#'
#' Returns true if the string matches the like_specifier (see Pattern Matching) using case-insensitive matching. escape_character is used to search for wildcard characters in the string.
#'
#' @name ilike_escape
#' @usage NULL
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' ilike_escape('A%c', 'a$%C', '$')
#' }
duckdb_fun_ilike_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function ilike_escape() is not available in R.")
}

#' DuckDB function instr
#'
#' Returns location of first occurrence of needle in haystack, counting from 1. Returns 0 if no match found.
#'
#' @name instr
#' @usage NULL
#' @param haystack `VARCHAR`
#' @param needle `VARCHAR`
#' @examples
#' \dontrun{
#' instr('test test','es')
#' }
duckdb_fun_instr <- function(haystack = VARCHAR, needle = VARCHAR) {
  stop("DuckDB function instr() is not available in R.")
}

#' DuckDB function is_histogram_other_bin
#'
#' Whether or not the provided value is the histogram "other" bin (used for values not belonging to any provided bin).
#'
#' @name is_histogram_other_bin
#' @usage NULL
#' @param val `ANY`
#' @examples
#' \dontrun{
#' is_histogram_other_bin(v)
#' }
duckdb_fun_is_histogram_other_bin <- function(val = ANY) {
  stop("DuckDB function is_histogram_other_bin() is not available in R.")
}

#' DuckDB function jaccard
#'
#' The Jaccard similarity between two strings. Different case is considered different. Returns a number between 0 and 1.
#'
#' @name jaccard
#' @usage NULL
#' @param str1 `VARCHAR`
#' @param str2 `VARCHAR`
#' @examples
#' \dontrun{
#' jaccard('duck','luck')
#' }
duckdb_fun_jaccard <- function(str1 = VARCHAR, str2 = VARCHAR) {
  stop("DuckDB function jaccard() is not available in R.")
}

#' DuckDB function lcase
#'
#' Convert string to lower case.
#'
#' @name lcase
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' lower('Hello')
#' }
duckdb_fun_lcase <- function(string = VARCHAR) {
  stop("DuckDB function lcase() is not available in R.")
}

#' DuckDB function left
#'
#' Extract the left-most count characters.
#'
#' @name left
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' left('HelloðŸ¦†', 2)
#' }
duckdb_fun_left <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function left() is not available in R.")
}

#' DuckDB function left_grapheme
#'
#' Extract the left-most count grapheme clusters.
#'
#' @name left_grapheme
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' left_grapheme('ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸', 1)
#' }
duckdb_fun_left_grapheme <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function left_grapheme() is not available in R.")
}

#' DuckDB function length_grapheme
#'
#' Number of grapheme clusters in string.
#'
#' @name length_grapheme
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' length_grapheme('ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸')
#' }
duckdb_fun_length_grapheme <- function(string = VARCHAR) {
  stop("DuckDB function length_grapheme() is not available in R.")
}

#' DuckDB function levenshtein
#'
#' The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Different case is considered different.
#'
#' @name levenshtein
#' @usage NULL
#' @param str1 `VARCHAR`
#' @param str2 `VARCHAR`
#' @examples
#' \dontrun{
#' levenshtein('duck','db')
#' }
duckdb_fun_levenshtein <- function(str1 = VARCHAR, str2 = VARCHAR) {
  stop("DuckDB function levenshtein() is not available in R.")
}

#' DuckDB function lgamma
#'
#' Computes the log of the gamma function.
#'
#' @name lgamma
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' lgamma(2)
#' }
duckdb_fun_lgamma <- function(x = DOUBLE) {
  stop("DuckDB function lgamma() is not available in R.")
}

#' DuckDB function like_escape
#'
#' Returns true if the string matches the like_specifier (see Pattern Matching) using case-sensitive matching. escape_character is used to search for wildcard characters in the string.
#'
#' @name like_escape
#' @usage NULL
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' like_escape('a%c', 'a$%c', '$')
#' }
duckdb_fun_like_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function like_escape() is not available in R.")
}

#' DuckDB function list_apply
#'
#' Returns a list that is the result of applying the lambda function to each element of the input list. See the Lambda Functions section for more details.
#'
#' @name list_apply
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_transform([1, 2, 3], x -> x + 1)
#' }
duckdb_fun_list_apply <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function list_apply() is not available in R.")
}

#' DuckDB function list_cat
#'
#' Concatenates two lists.
#'
#' @name list_cat
#' @usage NULL
#' @param list1 `ANY[]`
#' @param list2 `ANY[]`
#' @examples
#' \dontrun{
#' list_concat([2, 3], [4, 5, 6])
#' }
duckdb_fun_list_cat <- function(list1 = `ANY[]`, list2 = `ANY[]`) {
  stop("DuckDB function list_cat() is not available in R.")
}

#' DuckDB function list_concat
#'
#' Concatenates two lists.
#'
#' @name list_concat
#' @usage NULL
#' @param list1 `ANY[]`
#' @param list2 `ANY[]`
#' @examples
#' \dontrun{
#' list_concat([2, 3], [4, 5, 6])
#' }
duckdb_fun_list_concat <- function(list1 = `ANY[]`, list2 = `ANY[]`) {
  stop("DuckDB function list_concat() is not available in R.")
}

#' DuckDB function list_contains
#'
#' Returns true if the list contains the element.
#'
#' @name list_contains
#' @usage NULL
#' @param list `ANY[]`
#' @param element `ANY`
#' @examples
#' \dontrun{
#' list_contains([1, 2, NULL], 1)
#' }
duckdb_fun_list_contains <- function(list = `ANY[]`, element = ANY) {
  stop("DuckDB function list_contains() is not available in R.")
}

#' DuckDB function list_distinct
#'
#' Removes all duplicates and NULLs from a list. Does not preserve the original order.
#'
#' @name list_distinct
#' @usage NULL
#' @param list `ANY[]`
#' @examples
#' \dontrun{
#' list_distinct([1, 1, NULL, -3, 1, 5])
#' }
duckdb_fun_list_distinct <- function(list = `ANY[]`) {
  stop("DuckDB function list_distinct() is not available in R.")
}

#' DuckDB function list_filter
#'
#' Constructs a list from those elements of the input list for which the lambda function returns true.
#'
#' @name list_filter
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_filter([3, 4, 5], x -> x > 4)
#' }
duckdb_fun_list_filter <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function list_filter() is not available in R.")
}

#' DuckDB function list_has
#'
#' Returns true if the list contains the element.
#'
#' @name list_has
#' @usage NULL
#' @param list `ANY[]`
#' @param element `ANY`
#' @examples
#' \dontrun{
#' list_contains([1, 2, NULL], 1)
#' }
duckdb_fun_list_has <- function(list = `ANY[]`, element = ANY) {
  stop("DuckDB function list_has() is not available in R.")
}

#' DuckDB function list_has_all
#'
#' Returns true if all elements of l2 are in l1. NULLs are ignored.
#'
#' @name list_has_all
#' @usage NULL
#' @param l1 `ANY[]`
#' @param l2 `ANY[]`
#' @examples
#' \dontrun{
#' list_has_all([1, 2, 3], [2, 3])
#' }
duckdb_fun_list_has_all <- function(l1 = `ANY[]`, l2 = `ANY[]`) {
  stop("DuckDB function list_has_all() is not available in R.")
}

#' DuckDB function list_has_any
#'
#' Returns true if the lists have any element in common. NULLs are ignored.
#'
#' @name list_has_any
#' @usage NULL
#' @param l1 `ANY[]`
#' @param l2 `ANY[]`
#' @examples
#' \dontrun{
#' list_has_any([1, 2, 3], [2, 3, 4])
#' }
duckdb_fun_list_has_any <- function(l1 = `ANY[]`, l2 = `ANY[]`) {
  stop("DuckDB function list_has_any() is not available in R.")
}

#' DuckDB function list_indexof
#'
#' Returns the index of the element if the list contains the element. If the element is not found, it returns NULL.
#'
#' @name list_indexof
#' @usage NULL
#' @param list `ANY[]`
#' @param element `ANY`
#' @examples
#' \dontrun{
#' list_position([1, 2, NULL], 2)
#' }
duckdb_fun_list_indexof <- function(list = `ANY[]`, element = ANY) {
  stop("DuckDB function list_indexof() is not available in R.")
}

#' DuckDB function list_position
#'
#' Returns the index of the element if the list contains the element. If the element is not found, it returns NULL.
#'
#' @name list_position
#' @usage NULL
#' @param list `ANY[]`
#' @param element `ANY`
#' @examples
#' \dontrun{
#' list_position([1, 2, NULL], 2)
#' }
duckdb_fun_list_position <- function(list = `ANY[]`, element = ANY) {
  stop("DuckDB function list_position() is not available in R.")
}

#' DuckDB function list_reduce
#'
#' Returns a single value that is the result of applying the lambda function to each element of the input list, starting with the first element and then repeatedly applying the lambda function to the result of the previous application and the next element of the list.
#'
#' @name list_reduce
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_reduce([1, 2, 3], (x, y) -> x + y)
#' }
duckdb_fun_list_reduce <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function list_reduce() is not available in R.")
}

#' DuckDB function list_select
#'
#' Returns a list based on the elements selected by the index_list.
#'
#' @name list_select
#' @usage NULL
#' @param value_list `ANY[]`
#' @param index_list `BIGINT[]`
#' @examples
#' \dontrun{
#' list_select([10, 20, 30, 40], [1, 4])
#' }
duckdb_fun_list_select <- function(value_list = `ANY[]`, index_list = `BIGINT[]`) {
  stop("DuckDB function list_select() is not available in R.")
}

#' DuckDB function list_transform
#'
#' Returns a list that is the result of applying the lambda function to each element of the input list. See the Lambda Functions section for more details.
#'
#' @name list_transform
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_transform([1, 2, 3], x -> x + 1)
#' }
duckdb_fun_list_transform <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function list_transform() is not available in R.")
}

#' DuckDB function list_unique
#'
#' Counts the unique elements of a list.
#'
#' @name list_unique
#' @usage NULL
#' @param list `ANY[]`
#' @examples
#' \dontrun{
#' list_unique([1, 1, NULL, -3, 1, 5])
#' }
duckdb_fun_list_unique <- function(list = `ANY[]`) {
  stop("DuckDB function list_unique() is not available in R.")
}

#' DuckDB function list_where
#'
#' Returns a list with the BOOLEANs in mask_list applied as a mask to the value_list.
#'
#' @name list_where
#' @usage NULL
#' @param value_list `ANY[]`
#' @param mask_list `BOOLEAN[]`
#' @examples
#' \dontrun{
#' list_where([10, 20, 30, 40], [true, false, false, true])
#' }
duckdb_fun_list_where <- function(value_list = `ANY[]`, mask_list = `BOOLEAN[]`) {
  stop("DuckDB function list_where() is not available in R.")
}

#' DuckDB function ln
#'
#' Computes the natural logarithm of x.
#'
#' @name ln
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' ln(2)
#' }
duckdb_fun_ln <- function(x = DOUBLE) {
  stop("DuckDB function ln() is not available in R.")
}

#' DuckDB function log10
#'
#' Computes the 10-log of x.
#'
#' @name log10
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' log10(1000)
#' }
duckdb_fun_log10 <- function(x = DOUBLE) {
  stop("DuckDB function log10() is not available in R.")
}

#' DuckDB function log2
#'
#' Computes the 2-log of x.
#'
#' @name log2
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' log2(8)
#' }
duckdb_fun_log2 <- function(x = DOUBLE) {
  stop("DuckDB function log2() is not available in R.")
}

#' DuckDB function lower
#'
#' Convert string to lower case.
#'
#' @name lower
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' lower('Hello')
#' }
duckdb_fun_lower <- function(string = VARCHAR) {
  stop("DuckDB function lower() is not available in R.")
}

#' DuckDB function lpad
#'
#' Pads the string with the character from the left until it has count characters.
#'
#' @name lpad
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `INTEGER`
#' @param character `VARCHAR`
#' @examples
#' \dontrun{
#' lpad('hello', 10, '>')
#' }
duckdb_fun_lpad <- function(string = VARCHAR, count = INTEGER, character = VARCHAR) {
  stop("DuckDB function lpad() is not available in R.")
}

#' DuckDB function make_time
#'
#' The time for the given parts.
#'
#' @name make_time
#' @usage NULL
#' @param hour `BIGINT`
#' @param minute `BIGINT`
#' @param seconds `DOUBLE`
#' @examples
#' \dontrun{
#' make_time(13, 34, 27.123456)
#' }
duckdb_fun_make_time <- function(hour = BIGINT, minute = BIGINT, seconds = DOUBLE) {
  stop("DuckDB function make_time() is not available in R.")
}

#' DuckDB function make_timestamp_ns
#'
#' The timestamp for the given nanoseconds since epoch.
#'
#' @name make_timestamp_ns
#' @usage NULL
#' @param nanos `BIGINT`
#' @examples
#' \dontrun{
#' make_timestamp(1732117793000000000)
#' }
duckdb_fun_make_timestamp_ns <- function(nanos = BIGINT) {
  stop("DuckDB function make_timestamp_ns() is not available in R.")
}

#' DuckDB function map_contains
#'
#' Checks if a map contains a given key.
#'
#' @name map_contains
#' @usage NULL
#' @param map `MAP(ANY, ANY)`
#' @param key `ANY`
#' @examples
#' \dontrun{
#' map_contains(MAP {'key1': 10, 'key2': 20, 'key3': 30}, 'key2')
#' }
duckdb_fun_map_contains <- function(map = `MAP(ANY, ANY)`, key = ANY) {
  stop("DuckDB function map_contains() is not available in R.")
}

#' DuckDB function mismatches
#'
#' The number of positions with different characters for 2 strings of equal length. Different case is considered different.
#'
#' @name mismatches
#' @usage NULL
#' @param str1 `VARCHAR`
#' @param str2 `VARCHAR`
#' @examples
#' \dontrun{
#' hamming('duck','luck')
#' }
duckdb_fun_mismatches <- function(str1 = VARCHAR, str2 = VARCHAR) {
  stop("DuckDB function mismatches() is not available in R.")
}

#' DuckDB function nfc_normalize
#'
#' Convert string to Unicode NFC normalized string. Useful for comparisons and ordering if text data is mixed between NFC normalized and not.
#'
#' @name nfc_normalize
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' nfc_normalize('ardÃ¨ch')
#' }
duckdb_fun_nfc_normalize <- function(string = VARCHAR) {
  stop("DuckDB function nfc_normalize() is not available in R.")
}

#' DuckDB function normalized_interval
#'
#' Normalizes an INTERVAL to an equivalent interval.
#'
#' @name normalized_interval
#' @usage NULL
#' @param interval `INTERVAL`
#' @examples
#' \dontrun{
#' normalized_interval(INTERVAL '30 days')
#' }
duckdb_fun_normalized_interval <- function(interval = INTERVAL) {
  stop("DuckDB function normalized_interval() is not available in R.")
}

#' DuckDB function not_ilike_escape
#'
#' Returns false if the string matches the like_specifier (see Pattern Matching) using case-insensitive matching. escape_character is used to search for wildcard characters in the string.
#'
#' @name not_ilike_escape
#' @usage NULL
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' not_ilike_escape('A%c', 'a$%C', '$')
#' }
duckdb_fun_not_ilike_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function not_ilike_escape() is not available in R.")
}

#' DuckDB function not_like_escape
#'
#' Returns false if the string matches the like_specifier (see Pattern Matching) using case-sensitive matching. escape_character is used to search for wildcard characters in the string.
#'
#' @name not_like_escape
#' @usage NULL
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' not_like_escape('a%c', 'a$%c', '$')
#' }
duckdb_fun_not_like_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function not_like_escape() is not available in R.")
}

#' DuckDB function ord
#'
#' Returns the unicode codepoint of the first character of the string.
#'
#' @name ord
#' @usage NULL
#' @param str `VARCHAR`
#' @examples
#' \dontrun{
#' unicode('Ã¼')
#' }
duckdb_fun_ord <- function(str = VARCHAR) {
  stop("DuckDB function ord() is not available in R.")
}

#' DuckDB function pi
#'
#' Returns the value of pi.
#'
#' @name pi
#' @usage NULL

#' @examples
#' \dontrun{
#' pi()
#' }
duckdb_fun_pi <- function() {
  stop("DuckDB function pi() is not available in R.")
}

#' DuckDB function position
#'
#' Returns location of first occurrence of needle in haystack, counting from 1. Returns 0 if no match found.
#'
#' @name position
#' @usage NULL
#' @param haystack `VARCHAR`
#' @param needle `VARCHAR`
#' @examples
#' \dontrun{
#' instr('test test','es')
#' }
duckdb_fun_position <- function(haystack = VARCHAR, needle = VARCHAR) {
  stop("DuckDB function position() is not available in R.")
}

#' DuckDB function pow
#'
#' Computes x to the power of y.
#'
#' @name pow
#' @usage NULL
#' @param x `DOUBLE`
#' @param y `DOUBLE`
#' @examples
#' \dontrun{
#' pow(2, 3)
#' }
duckdb_fun_pow <- function(x = DOUBLE, y = DOUBLE) {
  stop("DuckDB function pow() is not available in R.")
}

#' DuckDB function power
#'
#' Computes x to the power of y.
#'
#' @name power
#' @usage NULL
#' @param x `DOUBLE`
#' @param y `DOUBLE`
#' @examples
#' \dontrun{
#' pow(2, 3)
#' }
duckdb_fun_power <- function(x = DOUBLE, y = DOUBLE) {
  stop("DuckDB function power() is not available in R.")
}

#' DuckDB function radians
#'
#' Converts degrees to radians.
#'
#' @name radians
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' radians(90)
#' }
duckdb_fun_radians <- function(x = DOUBLE) {
  stop("DuckDB function radians() is not available in R.")
}

#' DuckDB function reduce
#'
#' Returns a single value that is the result of applying the lambda function to each element of the input list, starting with the first element and then repeatedly applying the lambda function to the result of the previous application and the next element of the list.
#'
#' @name reduce
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda `LAMBDA`
#' @examples
#' \dontrun{
#' list_reduce([1, 2, 3], (x, y) -> x + y)
#' }
duckdb_fun_reduce <- function(list = `ANY[]`, lambda = LAMBDA) {
  stop("DuckDB function reduce() is not available in R.")
}

#' DuckDB function regexp_escape
#'
#' Escapes all potentially meaningful regexp characters in the input string.
#'
#' @name regexp_escape
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_escape('https://duckdb.org')
#' }
duckdb_fun_regexp_escape <- function(string = VARCHAR) {
  stop("DuckDB function regexp_escape() is not available in R.")
}

#' DuckDB function replace
#'
#' Replaces any occurrences of the source with target in string.
#'
#' @name replace
#' @usage NULL
#' @param string `VARCHAR`
#' @param source `VARCHAR`
#' @param target `VARCHAR`
#' @examples
#' \dontrun{
#' replace('hello', 'l', '-')
#' }
duckdb_fun_replace <- function(string = VARCHAR, source = VARCHAR, target = VARCHAR) {
  stop("DuckDB function replace() is not available in R.")
}

#' DuckDB function reverse
#'
#' Reverses the string.
#'
#' @name reverse
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' reverse('hello')
#' }
duckdb_fun_reverse <- function(string = VARCHAR) {
  stop("DuckDB function reverse() is not available in R.")
}

#' DuckDB function right
#'
#' Extract the right-most count characters.
#'
#' @name right
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' right('HelloðŸ¦†', 3)
#' }
duckdb_fun_right <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function right() is not available in R.")
}

#' DuckDB function right_grapheme
#'
#' Extract the right-most count grapheme clusters.
#'
#' @name right_grapheme
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' right_grapheme('ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸', 1)
#' }
duckdb_fun_right_grapheme <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function right_grapheme() is not available in R.")
}

#' DuckDB function rpad
#'
#' Pads the string with the character from the right until it has count characters.
#'
#' @name rpad
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `INTEGER`
#' @param character `VARCHAR`
#' @examples
#' \dontrun{
#' rpad('hello', 10, '<')
#' }
duckdb_fun_rpad <- function(string = VARCHAR, count = INTEGER, character = VARCHAR) {
  stop("DuckDB function rpad() is not available in R.")
}

#' DuckDB function set_bit
#'
#' Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0. Returns a new bitstring.
#'
#' @name set_bit
#' @usage NULL
#' @param bitstring `BIT`
#' @param index `INTEGER`
#' @param new_value `INTEGER`
#' @examples
#' \dontrun{
#' set_bit('0110010'::BIT, 2, 0)
#' }
duckdb_fun_set_bit <- function(bitstring = BIT, index = INTEGER, new_value = INTEGER) {
  stop("DuckDB function set_bit() is not available in R.")
}

#' DuckDB function sin
#'
#' Computes the sin of x.
#'
#' @name sin
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' sin(90)
#' }
duckdb_fun_sin <- function(x = DOUBLE) {
  stop("DuckDB function sin() is not available in R.")
}

#' DuckDB function sinh
#'
#' Computes the hyperbolic sin of x.
#'
#' @name sinh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' sinh(1)
#' }
duckdb_fun_sinh <- function(x = DOUBLE) {
  stop("DuckDB function sinh() is not available in R.")
}

#' DuckDB function split
#'
#' Splits the string along the separator.
#'
#' @name split
#' @usage NULL
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' string_split('hello-world', '-')
#' }
duckdb_fun_split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function split() is not available in R.")
}

#' DuckDB function sqrt
#'
#' Returns the square root of x.
#'
#' @name sqrt
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' sqrt(4)
#' }
duckdb_fun_sqrt <- function(x = DOUBLE) {
  stop("DuckDB function sqrt() is not available in R.")
}

#' DuckDB function starts_with
#'
#' Returns true if string begins with search_string.
#'
#' @name starts_with
#' @usage NULL
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' starts_with('abc','a')
#' }
duckdb_fun_starts_with <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function starts_with() is not available in R.")
}

#' DuckDB function str_split
#'
#' Splits the string along the separator.
#'
#' @name str_split
#' @usage NULL
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' string_split('hello-world', '-')
#' }
duckdb_fun_str_split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function str_split() is not available in R.")
}

#' DuckDB function string_split
#'
#' Splits the string along the separator.
#'
#' @name string_split
#' @usage NULL
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' string_split('hello-world', '-')
#' }
duckdb_fun_string_split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function string_split() is not available in R.")
}

#' DuckDB function string_to_array
#'
#' Splits the string along the separator.
#'
#' @name string_to_array
#' @usage NULL
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' string_split('hello-world', '-')
#' }
duckdb_fun_string_to_array <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function string_to_array() is not available in R.")
}

#' DuckDB function strip_accents
#'
#' Strips accents from string.
#'
#' @name strip_accents
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' strip_accents('mÃ¼hleisen')
#' }
duckdb_fun_strip_accents <- function(string = VARCHAR) {
  stop("DuckDB function strip_accents() is not available in R.")
}

#' DuckDB function strlen
#'
#' Number of bytes in string.
#'
#' @name strlen
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' strlen('ðŸ¦†')
#' }
duckdb_fun_strlen <- function(string = VARCHAR) {
  stop("DuckDB function strlen() is not available in R.")
}

#' DuckDB function strpos
#'
#' Returns location of first occurrence of needle in haystack, counting from 1. Returns 0 if no match found.
#'
#' @name strpos
#' @usage NULL
#' @param haystack `VARCHAR`
#' @param needle `VARCHAR`
#' @examples
#' \dontrun{
#' instr('test test','es')
#' }
duckdb_fun_strpos <- function(haystack = VARCHAR, needle = VARCHAR) {
  stop("DuckDB function strpos() is not available in R.")
}

#' DuckDB function tan
#'
#' Computes the tan of x.
#'
#' @name tan
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' tan(90)
#' }
duckdb_fun_tan <- function(x = DOUBLE) {
  stop("DuckDB function tan() is not available in R.")
}

#' DuckDB function tanh
#'
#' Computes the hyperbolic tan of x.
#'
#' @name tanh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' tanh(1)
#' }
duckdb_fun_tanh <- function(x = DOUBLE) {
  stop("DuckDB function tanh() is not available in R.")
}

#' DuckDB function timetz_byte_comparable
#'
#' Converts a TIME WITH TIME ZONE to an integer sort key.
#'
#' @name timetz_byte_comparable
#' @usage NULL
#' @param time_tz `TIME WITH TIME ZONE`
#' @examples
#' \dontrun{
#' timetz_byte_comparable('18:18:16.21-07:00'::TIME_TZ)
#' }
duckdb_fun_timetz_byte_comparable <- function(time_tz = `TIME WITH TIME ZONE`) {
  stop("DuckDB function timetz_byte_comparable() is not available in R.")
}

#' DuckDB function to_base64
#'
#' Convert a blob to a base64 encoded string.
#'
#' @name to_base64
#' @usage NULL
#' @param blob `BLOB`
#' @examples
#' \dontrun{
#' base64('A'::blob)
#' }
duckdb_fun_to_base64 <- function(blob = BLOB) {
  stop("DuckDB function to_base64() is not available in R.")
}

#' DuckDB function to_centuries
#'
#' Construct a century interval.
#'
#' @name to_centuries
#' @usage NULL
#' @param integer `INTEGER`
#' @examples
#' \dontrun{
#' to_centuries(5)
#' }
duckdb_fun_to_centuries <- function(integer = INTEGER) {
  stop("DuckDB function to_centuries() is not available in R.")
}

#' DuckDB function to_days
#'
#' Construct a day interval.
#'
#' @name to_days
#' @usage NULL
#' @param integer `INTEGER`
#' @examples
#' \dontrun{
#' to_days(5)
#' }
duckdb_fun_to_days <- function(integer = INTEGER) {
  stop("DuckDB function to_days() is not available in R.")
}

#' DuckDB function to_decades
#'
#' Construct a decade interval.
#'
#' @name to_decades
#' @usage NULL
#' @param integer `INTEGER`
#' @examples
#' \dontrun{
#' to_decades(5)
#' }
duckdb_fun_to_decades <- function(integer = INTEGER) {
  stop("DuckDB function to_decades() is not available in R.")
}

#' DuckDB function to_hours
#'
#' Construct a hour interval.
#'
#' @name to_hours
#' @usage NULL
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' to_hours(5)
#' }
duckdb_fun_to_hours <- function(integer = BIGINT) {
  stop("DuckDB function to_hours() is not available in R.")
}

#' DuckDB function to_microseconds
#'
#' Construct a microsecond interval.
#'
#' @name to_microseconds
#' @usage NULL
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' to_microseconds(5)
#' }
duckdb_fun_to_microseconds <- function(integer = BIGINT) {
  stop("DuckDB function to_microseconds() is not available in R.")
}

#' DuckDB function to_millennia
#'
#' Construct a millenium interval.
#'
#' @name to_millennia
#' @usage NULL
#' @param integer `INTEGER`
#' @examples
#' \dontrun{
#' to_millennia(1)
#' }
duckdb_fun_to_millennia <- function(integer = INTEGER) {
  stop("DuckDB function to_millennia() is not available in R.")
}

#' DuckDB function to_milliseconds
#'
#' Construct a millisecond interval.
#'
#' @name to_milliseconds
#' @usage NULL
#' @param double `DOUBLE`
#' @examples
#' \dontrun{
#' to_milliseconds(5.5)
#' }
duckdb_fun_to_milliseconds <- function(double = DOUBLE) {
  stop("DuckDB function to_milliseconds() is not available in R.")
}

#' DuckDB function to_minutes
#'
#' Construct a minute interval.
#'
#' @name to_minutes
#' @usage NULL
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' to_minutes(5)
#' }
duckdb_fun_to_minutes <- function(integer = BIGINT) {
  stop("DuckDB function to_minutes() is not available in R.")
}

#' DuckDB function to_months
#'
#' Construct a month interval.
#'
#' @name to_months
#' @usage NULL
#' @param integer `INTEGER`
#' @examples
#' \dontrun{
#' to_months(5)
#' }
duckdb_fun_to_months <- function(integer = INTEGER) {
  stop("DuckDB function to_months() is not available in R.")
}

#' DuckDB function to_quarters
#'
#' Construct a quarter interval.
#'
#' @name to_quarters
#' @usage NULL
#' @param integer `INTEGER`
#' @examples
#' \dontrun{
#' to_quarters(5)
#' }
duckdb_fun_to_quarters <- function(integer = INTEGER) {
  stop("DuckDB function to_quarters() is not available in R.")
}

#' DuckDB function to_seconds
#'
#' Construct a second interval.
#'
#' @name to_seconds
#' @usage NULL
#' @param double `DOUBLE`
#' @examples
#' \dontrun{
#' to_seconds(5.5)
#' }
duckdb_fun_to_seconds <- function(double = DOUBLE) {
  stop("DuckDB function to_seconds() is not available in R.")
}

#' DuckDB function to_timestamp
#'
#' Converts secs since epoch to a timestamp with time zone.
#'
#' @name to_timestamp
#' @usage NULL
#' @param sec `DOUBLE`
#' @examples
#' \dontrun{
#' to_timestamp(1284352323.5)
#' }
duckdb_fun_to_timestamp <- function(sec = DOUBLE) {
  stop("DuckDB function to_timestamp() is not available in R.")
}

#' DuckDB function to_weeks
#'
#' Construct a week interval.
#'
#' @name to_weeks
#' @usage NULL
#' @param integer `INTEGER`
#' @examples
#' \dontrun{
#' to_weeks(5)
#' }
duckdb_fun_to_weeks <- function(integer = INTEGER) {
  stop("DuckDB function to_weeks() is not available in R.")
}

#' DuckDB function to_years
#'
#' Construct a year interval.
#'
#' @name to_years
#' @usage NULL
#' @param integer `INTEGER`
#' @examples
#' \dontrun{
#' to_years(5)
#' }
duckdb_fun_to_years <- function(integer = INTEGER) {
  stop("DuckDB function to_years() is not available in R.")
}

#' DuckDB function translate
#'
#' Replaces each character in string that matches a character in the from set with the corresponding character in the to set. If from is longer than to, occurrences of the extra characters in from are deleted.
#'
#' @name translate
#' @usage NULL
#' @param string `VARCHAR`
#' @param from `VARCHAR`
#' @param to `VARCHAR`
#' @examples
#' \dontrun{
#' translate('12345', '143', 'ax')
#' }
duckdb_fun_translate <- function(string = VARCHAR, from = VARCHAR, to = VARCHAR) {
  stop("DuckDB function translate() is not available in R.")
}

#' DuckDB function typeof
#'
#' Returns the name of the data type of the result of the expression.
#'
#' @name typeof
#' @usage NULL
#' @param expression `ANY`
#' @examples
#' \dontrun{
#' typeof('abc')
#' }
duckdb_fun_typeof <- function(expression = ANY) {
  stop("DuckDB function typeof() is not available in R.")
}

#' DuckDB function ucase
#'
#' Convert string to upper case.
#'
#' @name ucase
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' upper('Hello')
#' }
duckdb_fun_ucase <- function(string = VARCHAR) {
  stop("DuckDB function ucase() is not available in R.")
}

#' DuckDB function unbin
#'
#' Converts a value from binary representation to a blob.
#'
#' @name unbin
#' @usage NULL
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' unbin('0110')
#' }
duckdb_fun_unbin <- function(value = VARCHAR) {
  stop("DuckDB function unbin() is not available in R.")
}

#' DuckDB function unhex
#'
#' Converts a value from hexadecimal representation to a blob.
#'
#' @name unhex
#' @usage NULL
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' unhex('2A')
#' }
duckdb_fun_unhex <- function(value = VARCHAR) {
  stop("DuckDB function unhex() is not available in R.")
}

#' DuckDB function unicode
#'
#' Returns the unicode codepoint of the first character of the string.
#'
#' @name unicode
#' @usage NULL
#' @param str `VARCHAR`
#' @examples
#' \dontrun{
#' unicode('Ã¼')
#' }
duckdb_fun_unicode <- function(str = VARCHAR) {
  stop("DuckDB function unicode() is not available in R.")
}

#' DuckDB function union_extract
#'
#' Extract the value with the named tags from the union. NULL if the tag is not currently selected.
#'
#' @name union_extract
#' @usage NULL
#' @param union `UNION`
#' @param tag `VARCHAR`
#' @examples
#' \dontrun{
#' union_extract(s, 'k')
#' }
duckdb_fun_union_extract <- function(union = UNION, tag = VARCHAR) {
  stop("DuckDB function union_extract() is not available in R.")
}

#' DuckDB function union_tag
#'
#' Retrieve the currently selected tag of the union as an ENUM.
#'
#' @name union_tag
#' @usage NULL
#' @param union `UNION`
#' @examples
#' \dontrun{
#' union_tag(union_value(k := 'foo'))
#' }
duckdb_fun_union_tag <- function(union = UNION) {
  stop("DuckDB function union_tag() is not available in R.")
}

#' DuckDB function upper
#'
#' Convert string to upper case.
#'
#' @name upper
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' upper('Hello')
#' }
duckdb_fun_upper <- function(string = VARCHAR) {
  stop("DuckDB function upper() is not available in R.")
}

#' DuckDB function url_decode
#'
#' Unescapes the URL encoded input.
#'
#' @name url_decode
#' @usage NULL
#' @param input `VARCHAR`
#' @examples
#' \dontrun{
#' url_decode('this%20string%20is%2BFencoded')
#' }
duckdb_fun_url_decode <- function(input = VARCHAR) {
  stop("DuckDB function url_decode() is not available in R.")
}

#' DuckDB function url_encode
#'
#' Escapes the input string by encoding it so that it can be included in a URL query parameter.
#'
#' @name url_encode
#' @usage NULL
#' @param input `VARCHAR`
#' @examples
#' \dontrun{
#' url_encode('this string has/ special+ characters>')
#' }
duckdb_fun_url_encode <- function(input = VARCHAR) {
  stop("DuckDB function url_encode() is not available in R.")
}

#' DuckDB function vector_type
#'
#' Returns the VectorType of a given column.
#'
#' @name vector_type
#' @usage NULL
#' @param col `ANY`
#' @examples
#' \dontrun{
#' vector_type(col)
#' }
duckdb_fun_vector_type <- function(col = ANY) {
  stop("DuckDB function vector_type() is not available in R.")
}

#' DuckDB function version
#'
#' Returns the currently active version of DuckDB in this format: v0.3.2	.
#'
#' @name version
#' @usage NULL

#' @examples
#' \dontrun{
#' version()
#' }
duckdb_fun_version <- function() {
  stop("DuckDB function version() is not available in R.")
}

