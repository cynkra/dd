# Generated by do_update_duckdb_funs(), do not edit by hand

#' DuckDB function acos
#'
#' Computes the arccosine of x.
#'
#' @name acos
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' acos(0.5)
#' }
acos <- function(x = DOUBLE) {
  stop("DuckDB function acos() is not available in R.")
}

#' DuckDB function acosh
#'
#' Computes the inverse hyperbolic cos of x.
#'
#' @name acosh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' acosh(2.3)
#' }
acosh <- function(x = DOUBLE) {
  stop("DuckDB function acosh() is not available in R.")
}

#' DuckDB function alias
#'
#' Returns the name of a given expression.
#'
#' @name alias
#' @usage NULL
#' @param expr `ANY`
#' @examples
#' \dontrun{
#' alias(42 + 1)
#' }
alias <- function(expr = ANY) {
  stop("DuckDB function alias() is not available in R.")
}

#' DuckDB function apply
#'
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name apply
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' apply([1, 2, 3], lambda x : x + 1)
#' }
apply <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function apply() is not available in R.")
}

#' DuckDB function array_apply
#'
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name array_apply
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' array_apply([1, 2, 3], lambda x : x + 1)
#' }
array_apply <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function array_apply() is not available in R.")
}

#' DuckDB function array_contains
#'
#' Returns true if the list contains the element.
#'
#' @name array_contains
#' @usage NULL
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' array_contains([1, 2, NULL], 1)
#' }
array_contains <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_contains() is not available in R.")
}

#' DuckDB function array_distinct
#'
#' Removes all duplicates and `NULL` values from a list. Does not preserve the original order.
#'
#' @name array_distinct
#' @usage NULL
#' @param list `T[]`
#' @examples
#' \dontrun{
#' array_distinct([1, 1, NULL, -3, 1, 5])
#' }
array_distinct <- function(list = `T[]`) {
  stop("DuckDB function array_distinct() is not available in R.")
}

#' DuckDB function array_filter
#'
#' Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.
#'
#' @name array_filter
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' array_filter([3, 4, 5], lambda x : x > 4)
#' }
array_filter <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function array_filter() is not available in R.")
}

#' DuckDB function array_has
#'
#' Returns true if the list contains the element.
#'
#' @name array_has
#' @usage NULL
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' array_has([1, 2, NULL], 1)
#' }
array_has <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_has() is not available in R.")
}

#' DuckDB function array_has_all
#'
#' Returns true if all elements of list2 are in list1. NULLs are ignored.
#'
#' @name array_has_all
#' @usage NULL
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @examples
#' \dontrun{
#' array_has_all([1, 2, 3], [2, 3])
#' }
array_has_all <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function array_has_all() is not available in R.")
}

#' DuckDB function array_has_any
#'
#' Returns true if the lists have any element in common. NULLs are ignored.
#'
#' @name array_has_any
#' @usage NULL
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @examples
#' \dontrun{
#' array_has_any([1, 2, 3], [2, 3, 4])
#' }
array_has_any <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function array_has_any() is not available in R.")
}

#' DuckDB function array_indexof
#'
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name array_indexof
#' @usage NULL
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' array_indexof([1, 2, NULL], 2)
#' }
array_indexof <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_indexof() is not available in R.")
}

#' DuckDB function array_position
#'
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name array_position
#' @usage NULL
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' array_position([1, 2, NULL], 2)
#' }
array_position <- function(list = `T[]`, element = T) {
  stop("DuckDB function array_position() is not available in R.")
}

#' DuckDB function array_select
#'
#' Returns a list based on the elements selected by the `index_list`.
#'
#' @name array_select
#' @usage NULL
#' @param value_list `T[]`
#' @param index_list `BIGINT[]`
#' @examples
#' \dontrun{
#' array_select([10, 20, 30, 40], [1, 4])
#' }
array_select <- function(value_list = `T[]`, index_list = `BIGINT[]`) {
  stop("DuckDB function array_select() is not available in R.")
}

#' DuckDB function array_transform
#'
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name array_transform
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' array_transform([1, 2, 3], lambda x : x + 1)
#' }
array_transform <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function array_transform() is not available in R.")
}

#' DuckDB function array_unique
#'
#' Counts the unique elements of a `list`.
#'
#' @name array_unique
#' @usage NULL
#' @param list `ANY[]`
#' @examples
#' \dontrun{
#' array_unique([1, 1, NULL, -3, 1, 5])
#' }
array_unique <- function(list = `ANY[]`) {
  stop("DuckDB function array_unique() is not available in R.")
}

#' DuckDB function array_where
#'
#' Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.
#'
#' @name array_where
#' @usage NULL
#' @param value_list `T[]`
#' @param mask_list `BOOLEAN[]`
#' @examples
#' \dontrun{
#' array_where([10, 20, 30, 40], [true, false, false, true])
#' }
array_where <- function(value_list = `T[]`, mask_list = `BOOLEAN[]`) {
  stop("DuckDB function array_where() is not available in R.")
}

#' DuckDB function ascii
#'
#' Returns an integer that represents the Unicode code point of the first character of the `string`.
#'
#' @name ascii
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' ascii('Î©')
#' }
ascii <- function(string = VARCHAR) {
  stop("DuckDB function ascii() is not available in R.")
}

#' DuckDB function asin
#'
#' Computes the arcsine of x.
#'
#' @name asin
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' asin(0.5)
#' }
asin <- function(x = DOUBLE) {
  stop("DuckDB function asin() is not available in R.")
}

#' DuckDB function asinh
#'
#' Computes the inverse hyperbolic sin of x.
#'
#' @name asinh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' asinh(0.5)
#' }
asinh <- function(x = DOUBLE) {
  stop("DuckDB function asinh() is not available in R.")
}

#' DuckDB function atan
#'
#' Computes the arctangent of x.
#'
#' @name atan
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' atan(0.5)
#' }
atan <- function(x = DOUBLE) {
  stop("DuckDB function atan() is not available in R.")
}

#' DuckDB function atan2
#'
#' Computes the arctangent (y, x).
#'
#' @name atan2
#' @usage NULL
#' @param y `DOUBLE`
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' atan2(1.0, 0.0)
#' }
atan2 <- function(y = DOUBLE, x = DOUBLE) {
  stop("DuckDB function atan2() is not available in R.")
}

#' DuckDB function atanh
#'
#' Computes the inverse hyperbolic tan of x.
#'
#' @name atanh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' atanh(0.5)
#' }
atanh <- function(x = DOUBLE) {
  stop("DuckDB function atanh() is not available in R.")
}

#' DuckDB function base64
#'
#' Converts a `blob` to a base64 encoded string.
#'
#' @name base64
#' @usage NULL
#' @param blob `BLOB`
#' @examples
#' \dontrun{
#' base64('A'::BLOB)
#' }
base64 <- function(blob = BLOB) {
  stop("DuckDB function base64() is not available in R.")
}

#' DuckDB function bit_position
#'
#' Returns first starting index of the specified substring within bits, or zero if it is not present. The first (leftmost) bit is indexed 1.
#'
#' @name bit_position
#' @usage NULL
#' @param substring `BIT`
#' @param bitstring `BIT`
#' @examples
#' \dontrun{
#' bit_position('010'::BIT, '1110101'::BIT)
#' }
bit_position <- function(substring = BIT, bitstring = BIT) {
  stop("DuckDB function bit_position() is not available in R.")
}

#' DuckDB function can_cast_implicitly
#'
#' Whether or not we can implicitly cast from the source type to the other type.
#'
#' @name can_cast_implicitly
#' @usage NULL
#' @param source_type `ANY`
#' @param target_type `ANY`
#' @examples
#' \dontrun{
#' can_cast_implicitly(NULL::INTEGER, NULL::BIGINT)
#' }
can_cast_implicitly <- function(source_type = ANY, target_type = ANY) {
  stop("DuckDB function can_cast_implicitly() is not available in R.")
}

#' DuckDB function cast_to_type
#'
#' Casts the first argument to the type of the second argument.
#'
#' @name cast_to_type
#' @usage NULL
#' @param param `ANY`
#' @param type `ANY`
#' @examples
#' \dontrun{
#' cast_to_type('42', NULL::INTEGER)
#' }
cast_to_type <- function(param = ANY, type = ANY) {
  stop("DuckDB function cast_to_type() is not available in R.")
}

#' DuckDB function cbrt
#'
#' Returns the cube root of x.
#'
#' @name cbrt
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cbrt(8)
#' }
cbrt <- function(x = DOUBLE) {
  stop("DuckDB function cbrt() is not available in R.")
}

#' DuckDB function chr
#'
#' Returns a character which is corresponding the ASCII code value or Unicode code point.
#'
#' @name chr
#' @usage NULL
#' @param code_point `INTEGER`
#' @examples
#' \dontrun{
#' chr(65)
#' }
chr <- function(code_point = INTEGER) {
  stop("DuckDB function chr() is not available in R.")
}

#' DuckDB function contains
#'
#' Returns `true` if `search_string` is found within `string`.
#'
#' @name contains
#' @usage NULL
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' contains('abc', 'a')
#' }
contains <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function contains() is not available in R.")
}

#' DuckDB function cos
#'
#' Computes the cos of x.
#'
#' @name cos
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cos(90)
#' }
cos <- function(x = DOUBLE) {
  stop("DuckDB function cos() is not available in R.")
}

#' DuckDB function cosh
#'
#' Computes the hyperbolic cos of x.
#'
#' @name cosh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cosh(1)
#' }
cosh <- function(x = DOUBLE) {
  stop("DuckDB function cosh() is not available in R.")
}

#' DuckDB function cot
#'
#' Computes the cotangent of x.
#'
#' @name cot
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' cot(0.5)
#' }
cot <- function(x = DOUBLE) {
  stop("DuckDB function cot() is not available in R.")
}

#' DuckDB function current_setting
#'
#' Returns the current value of the configuration setting.
#'
#' @name current_setting
#' @usage NULL
#' @param setting_name `VARCHAR`
#' @examples
#' \dontrun{
#' current_setting('access_mode')
#' }
current_setting <- function(setting_name = VARCHAR) {
  stop("DuckDB function current_setting() is not available in R.")
}

#' DuckDB function damerau_levenshtein
#'
#' Extension of Levenshtein distance to also include transposition of adjacent characters as an allowed edit operation. In other words, the minimum number of edit operations (insertions, deletions, substitutions or transpositions) required to change one string to another. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name damerau_levenshtein
#' @usage NULL
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' damerau_levenshtein('duckdb', 'udckbd')
#' }
damerau_levenshtein <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function damerau_levenshtein() is not available in R.")
}

#' DuckDB function decode
#'
#' Converts `blob` to `VARCHAR`. Fails if `blob` is not valid UTF-8.
#'
#' @name decode
#' @usage NULL
#' @param blob `BLOB`
#' @examples
#' \dontrun{
#' decode('\xC3\xBC'::BLOB)
#' }
decode <- function(blob = BLOB) {
  stop("DuckDB function decode() is not available in R.")
}

#' DuckDB function degrees
#'
#' Converts radians to degrees.
#'
#' @name degrees
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' degrees(pi())
#' }
degrees <- function(x = DOUBLE) {
  stop("DuckDB function degrees() is not available in R.")
}

#' DuckDB function editdist3
#'
#' The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name editdist3
#' @usage NULL
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' editdist3('duck', 'db')
#' }
editdist3 <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function editdist3() is not available in R.")
}

#' DuckDB function element_at
#'
#' Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the mapâ€™s keys else an error is returned.
#'
#' @name element_at
#' @usage NULL
#' @param map `MAP(K, V)`
#' @param key `K`
#' @examples
#' \dontrun{
#' element_at(map(['key'], ['val']), 'key')
#' }
element_at <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function element_at() is not available in R.")
}

#' DuckDB function encode
#'
#' Converts the `string` to `BLOB`. Converts UTF-8 characters into literal encoding.
#'
#' @name encode
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' encode('my_string_with_Ã¼')
#' }
encode <- function(string = VARCHAR) {
  stop("DuckDB function encode() is not available in R.")
}

#' DuckDB function ends_with
#'
#' Returns `true` if `string` ends with `search_string`.
#'
#' @name ends_with
#' @usage NULL
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' ends_with('abc', 'bc')
#' }
ends_with <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function ends_with() is not available in R.")
}

#' DuckDB function enum_code
#'
#' Returns the numeric value backing the given enum value.
#'
#' @name enum_code
#' @usage NULL
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_code('happy'::mood)
#' }
enum_code <- function(enum = ANY) {
  stop("DuckDB function enum_code() is not available in R.")
}

#' DuckDB function enum_first
#'
#' Returns the first value of the input enum type.
#'
#' @name enum_first
#' @usage NULL
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_first(NULL::mood)
#' }
enum_first <- function(enum = ANY) {
  stop("DuckDB function enum_first() is not available in R.")
}

#' DuckDB function enum_last
#'
#' Returns the last value of the input enum type.
#'
#' @name enum_last
#' @usage NULL
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_last(NULL::mood)
#' }
enum_last <- function(enum = ANY) {
  stop("DuckDB function enum_last() is not available in R.")
}

#' DuckDB function enum_range
#'
#' Returns all values of the input enum type as an array.
#'
#' @name enum_range
#' @usage NULL
#' @param enum `ANY`
#' @examples
#' \dontrun{
#' enum_range(NULL::mood)
#' }
enum_range <- function(enum = ANY) {
  stop("DuckDB function enum_range() is not available in R.")
}

#' DuckDB function enum_range_boundary
#'
#' Returns the range between the two given enum values as an array. The values must be of the same enum type. When the first parameter is NULL, the result starts with the first value of the enum type. When the second parameter is NULL, the result ends with the last value of the enum type.
#'
#' @name enum_range_boundary
#' @usage NULL
#' @param start `ANY`
#' @param end `ANY`
#' @examples
#' \dontrun{
#' enum_range_boundary(NULL, 'happy'::mood)
#' }
enum_range_boundary <- function(start = ANY, end = ANY) {
  stop("DuckDB function enum_range_boundary() is not available in R.")
}

#' DuckDB function even
#'
#' Rounds x to next even number by rounding away from zero.
#'
#' @name even
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' even(2.9)
#' }
even <- function(x = DOUBLE) {
  stop("DuckDB function even() is not available in R.")
}

#' DuckDB function exp
#'
#' Computes e to the power of x.
#'
#' @name exp
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' exp(1)
#' }
exp <- function(x = DOUBLE) {
  stop("DuckDB function exp() is not available in R.")
}

#' DuckDB function factorial
#'
#' Factorial of x. Computes the product of the current integer and all integers below it.
#'
#' @name factorial
#' @usage NULL
#' @param x `INTEGER`
#' @examples
#' \dontrun{
#' 4!
#' }
factorial <- function(x = INTEGER) {
  stop("DuckDB function factorial() is not available in R.")
}

#' DuckDB function filter
#'
#' Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.
#'
#' @name filter
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' filter([3, 4, 5], lambda x : x > 4)
#' }
filter <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function filter() is not available in R.")
}

#' DuckDB function flatten
#'
#' Flattens a nested list by one level.
#'
#' @name flatten
#' @usage NULL
#' @param nested_list `T[][]`
#' @examples
#' \dontrun{
#' flatten([[1, 2, 3], [4, 5]])
#' }
flatten <- function(nested_list = `T[][]`) {
  stop("DuckDB function flatten() is not available in R.")
}

#' DuckDB function formatReadableDecimalSize
#'
#' Converts `integer` to a human-readable representation using units based on powers of 10 (KB, MB, GB, etc.).
#'
#' @name formatReadableDecimalSize
#' @usage NULL
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' formatReadableDecimalSize(16_000)
#' }
formatReadableDecimalSize <- function(integer = BIGINT) {
  stop("DuckDB function formatReadableDecimalSize() is not available in R.")
}

#' DuckDB function formatReadableSize
#'
#' Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).
#'
#' @name formatReadableSize
#' @usage NULL
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' formatReadableSize(16_000)
#' }
formatReadableSize <- function(integer = BIGINT) {
  stop("DuckDB function formatReadableSize() is not available in R.")
}

#' DuckDB function format_bytes
#'
#' Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).
#'
#' @name format_bytes
#' @usage NULL
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' format_bytes(16_000)
#' }
format_bytes <- function(integer = BIGINT) {
  stop("DuckDB function format_bytes() is not available in R.")
}

#' DuckDB function from_base64
#'
#' Converts a base64 encoded `string` to a character string (`BLOB`).
#'
#' @name from_base64
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' from_base64('QQ==')
#' }
from_base64 <- function(string = VARCHAR) {
  stop("DuckDB function from_base64() is not available in R.")
}

#' DuckDB function from_binary
#'
#' Converts a `value` from binary representation to a blob.
#'
#' @name from_binary
#' @usage NULL
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' from_binary('0110')
#' }
from_binary <- function(value = VARCHAR) {
  stop("DuckDB function from_binary() is not available in R.")
}

#' DuckDB function from_hex
#'
#' Converts a `value` from hexadecimal representation to a blob.
#'
#' @name from_hex
#' @usage NULL
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' from_hex('2A')
#' }
from_hex <- function(value = VARCHAR) {
  stop("DuckDB function from_hex() is not available in R.")
}

#' DuckDB function gamma
#'
#' Interpolation of (x-1) factorial (so decimal inputs are allowed).
#'
#' @name gamma
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' gamma(5.5)
#' }
gamma <- function(x = DOUBLE) {
  stop("DuckDB function gamma() is not available in R.")
}

#' DuckDB function get_bit
#'
#' Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0.
#'
#' @name get_bit
#' @usage NULL
#' @param bitstring `BIT`
#' @param index `INTEGER`
#' @examples
#' \dontrun{
#' get_bit('0110010'::BIT, 2)
#' }
get_bit <- function(bitstring = BIT, index = INTEGER) {
  stop("DuckDB function get_bit() is not available in R.")
}

#' DuckDB function hamming
#'
#' The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length. Strings must be of equal length. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name hamming
#' @usage NULL
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' hamming('duck', 'luck')
#' }
hamming <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function hamming() is not available in R.")
}

#' DuckDB function ilike_escape
#'
#' Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name ilike_escape
#' @usage NULL
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' ilike_escape('A%c', 'a$%C', '$')
#' }
ilike_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function ilike_escape() is not available in R.")
}

#' DuckDB function instr
#'
#' Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.
#'
#' @name instr
#' @usage NULL
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' instr('test test', 'es')
#' }
instr <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function instr() is not available in R.")
}

#' DuckDB function is_histogram_other_bin
#'
#' Whether or not the provided value is the histogram "other" bin (used for values not belonging to any provided bin).
#'
#' @name is_histogram_other_bin
#' @usage NULL
#' @param val `ANY`
#' @examples
#' \dontrun{
#' is_histogram_other_bin(v)
#' }
is_histogram_other_bin <- function(val = ANY) {
  stop("DuckDB function is_histogram_other_bin() is not available in R.")
}

#' DuckDB function jaccard
#'
#' The Jaccard similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1.
#'
#' @name jaccard
#' @usage NULL
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' jaccard('duck', 'luck')
#' }
jaccard <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function jaccard() is not available in R.")
}

#' DuckDB function lcase
#'
#' Converts `string` to lower case.
#'
#' @name lcase
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' lcase('Hello')
#' }
lcase <- function(string = VARCHAR) {
  stop("DuckDB function lcase() is not available in R.")
}

#' DuckDB function left
#'
#' Extracts the left-most count characters.
#'
#' @name left
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' left('HelloðŸ¦†', 2)
#' }
left <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function left() is not available in R.")
}

#' DuckDB function left_grapheme
#'
#' Extracts the left-most count grapheme clusters.
#'
#' @name left_grapheme
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' left_grapheme('ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸', 1)
#' }
left_grapheme <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function left_grapheme() is not available in R.")
}

#' DuckDB function length_grapheme
#'
#' Number of grapheme clusters in `string`.
#'
#' @name length_grapheme
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' length_grapheme('ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸')
#' }
length_grapheme <- function(string = VARCHAR) {
  stop("DuckDB function length_grapheme() is not available in R.")
}

#' DuckDB function levenshtein
#'
#' The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name levenshtein
#' @usage NULL
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' levenshtein('duck', 'db')
#' }
levenshtein <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function levenshtein() is not available in R.")
}

#' DuckDB function lgamma
#'
#' Computes the log of the gamma function.
#'
#' @name lgamma
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' lgamma(2)
#' }
lgamma <- function(x = DOUBLE) {
  stop("DuckDB function lgamma() is not available in R.")
}

#' DuckDB function like_escape
#'
#' Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name like_escape
#' @usage NULL
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' like_escape('a%c', 'a$%c', '$')
#' }
like_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function like_escape() is not available in R.")
}

#' DuckDB function list_apply
#'
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name list_apply
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' list_apply([1, 2, 3], lambda x : x + 1)
#' }
list_apply <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function list_apply() is not available in R.")
}

#' DuckDB function list_contains
#'
#' Returns true if the list contains the element.
#'
#' @name list_contains
#' @usage NULL
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' list_contains([1, 2, NULL], 1)
#' }
list_contains <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_contains() is not available in R.")
}

#' DuckDB function list_distinct
#'
#' Removes all duplicates and `NULL` values from a list. Does not preserve the original order.
#'
#' @name list_distinct
#' @usage NULL
#' @param list `T[]`
#' @examples
#' \dontrun{
#' list_distinct([1, 1, NULL, -3, 1, 5])
#' }
list_distinct <- function(list = `T[]`) {
  stop("DuckDB function list_distinct() is not available in R.")
}

#' DuckDB function list_filter
#'
#' Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.
#'
#' @name list_filter
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' list_filter([3, 4, 5], lambda x : x > 4)
#' }
list_filter <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function list_filter() is not available in R.")
}

#' DuckDB function list_has
#'
#' Returns true if the list contains the element.
#'
#' @name list_has
#' @usage NULL
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' list_has([1, 2, NULL], 1)
#' }
list_has <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_has() is not available in R.")
}

#' DuckDB function list_has_all
#'
#' Returns true if all elements of list2 are in list1. NULLs are ignored.
#'
#' @name list_has_all
#' @usage NULL
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @examples
#' \dontrun{
#' list_has_all([1, 2, 3], [2, 3])
#' }
list_has_all <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function list_has_all() is not available in R.")
}

#' DuckDB function list_has_any
#'
#' Returns true if the lists have any element in common. NULLs are ignored.
#'
#' @name list_has_any
#' @usage NULL
#' @param list1 `T[]`
#' @param list2 `T[]`
#' @examples
#' \dontrun{
#' list_has_any([1, 2, 3], [2, 3, 4])
#' }
list_has_any <- function(list1 = `T[]`, list2 = `T[]`) {
  stop("DuckDB function list_has_any() is not available in R.")
}

#' DuckDB function list_indexof
#'
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name list_indexof
#' @usage NULL
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' list_indexof([1, 2, NULL], 2)
#' }
list_indexof <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_indexof() is not available in R.")
}

#' DuckDB function list_pack
#'
#' Creates a LIST containing the argument values.
#'
#' @name list_pack
#' @usage NULL

#' @examples
#' \dontrun{
#' list_pack(4, 5, 6)
#' }
list_pack <- function() {
  stop("DuckDB function list_pack() is not available in R.")
}

#' DuckDB function list_position
#'
#' Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.
#'
#' @name list_position
#' @usage NULL
#' @param list `T[]`
#' @param element `T`
#' @examples
#' \dontrun{
#' list_position([1, 2, NULL], 2)
#' }
list_position <- function(list = `T[]`, element = T) {
  stop("DuckDB function list_position() is not available in R.")
}

#' DuckDB function list_select
#'
#' Returns a list based on the elements selected by the `index_list`.
#'
#' @name list_select
#' @usage NULL
#' @param value_list `T[]`
#' @param index_list `BIGINT[]`
#' @examples
#' \dontrun{
#' list_select([10, 20, 30, 40], [1, 4])
#' }
list_select <- function(value_list = `T[]`, index_list = `BIGINT[]`) {
  stop("DuckDB function list_select() is not available in R.")
}

#' DuckDB function list_transform
#'
#' Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.
#'
#' @name list_transform
#' @usage NULL
#' @param list `ANY[]`
#' @param lambda(x) `LAMBDA`
#' @examples
#' \dontrun{
#' list_transform([1, 2, 3], lambda x : x + 1)
#' }
list_transform <- function(list = `ANY[]`, `lambda(x)` = LAMBDA) {
  stop("DuckDB function list_transform() is not available in R.")
}

#' DuckDB function list_unique
#'
#' Counts the unique elements of a `list`.
#'
#' @name list_unique
#' @usage NULL
#' @param list `ANY[]`
#' @examples
#' \dontrun{
#' list_unique([1, 1, NULL, -3, 1, 5])
#' }
list_unique <- function(list = `ANY[]`) {
  stop("DuckDB function list_unique() is not available in R.")
}

#' DuckDB function list_value
#'
#' Creates a LIST containing the argument values.
#'
#' @name list_value
#' @usage NULL

#' @examples
#' \dontrun{
#' list_value(4, 5, 6)
#' }
list_value <- function() {
  stop("DuckDB function list_value() is not available in R.")
}

#' DuckDB function list_where
#'
#' Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.
#'
#' @name list_where
#' @usage NULL
#' @param value_list `T[]`
#' @param mask_list `BOOLEAN[]`
#' @examples
#' \dontrun{
#' list_where([10, 20, 30, 40], [true, false, false, true])
#' }
list_where <- function(value_list = `T[]`, mask_list = `BOOLEAN[]`) {
  stop("DuckDB function list_where() is not available in R.")
}

#' DuckDB function ln
#'
#' Computes the natural logarithm of x.
#'
#' @name ln
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' ln(2)
#' }
ln <- function(x = DOUBLE) {
  stop("DuckDB function ln() is not available in R.")
}

#' DuckDB function log10
#'
#' Computes the 10-log of x.
#'
#' @name log10
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' log10(1000)
#' }
log10 <- function(x = DOUBLE) {
  stop("DuckDB function log10() is not available in R.")
}

#' DuckDB function log2
#'
#' Computes the 2-log of x.
#'
#' @name log2
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' log2(8)
#' }
log2 <- function(x = DOUBLE) {
  stop("DuckDB function log2() is not available in R.")
}

#' DuckDB function lower
#'
#' Converts `string` to lower case.
#'
#' @name lower
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' lower('Hello')
#' }
lower <- function(string = VARCHAR) {
  stop("DuckDB function lower() is not available in R.")
}

#' DuckDB function lpad
#'
#' Pads the `string` with the `character` on the left until it has `count` characters. Truncates the `string` on the right if it has more than `count` characters.
#'
#' @name lpad
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `INTEGER`
#' @param character `VARCHAR`
#' @examples
#' \dontrun{
#' lpad('hello', 8, '>')
#' }
lpad <- function(string = VARCHAR, count = INTEGER, character = VARCHAR) {
  stop("DuckDB function lpad() is not available in R.")
}

#' DuckDB function make_time
#'
#' The time for the given parts.
#'
#' @name make_time
#' @usage NULL
#' @param hour `BIGINT`
#' @param minute `BIGINT`
#' @param seconds `DOUBLE`
#' @examples
#' \dontrun{
#' make_time(13, 34, 27.123456)
#' }
make_time <- function(hour = BIGINT, minute = BIGINT, seconds = DOUBLE) {
  stop("DuckDB function make_time() is not available in R.")
}

#' DuckDB function make_timestamp_ms
#'
#' The timestamp for the given microseconds since the epoch.
#'
#' @name make_timestamp_ms
#' @usage NULL
#' @param nanos `BIGINT`
#' @examples
#' \dontrun{
#' make_timestamp_ms(1732117793000000)
#' }
make_timestamp_ms <- function(nanos = BIGINT) {
  stop("DuckDB function make_timestamp_ms() is not available in R.")
}

#' DuckDB function make_timestamp_ns
#'
#' The timestamp for the given nanoseconds since epoch.
#'
#' @name make_timestamp_ns
#' @usage NULL
#' @param nanos `BIGINT`
#' @examples
#' \dontrun{
#' make_timestamp_ns(1732117793000000000)
#' }
make_timestamp_ns <- function(nanos = BIGINT) {
  stop("DuckDB function make_timestamp_ns() is not available in R.")
}

#' DuckDB function map_contains
#'
#' Checks if a map contains a given key.
#'
#' @name map_contains
#' @usage NULL
#' @param map `MAP(K, V)`
#' @param key `K`
#' @examples
#' \dontrun{
#' map_contains(MAP {'key1': 10, 'key2': 20, 'key3': 30}, 'key2')
#' }
map_contains <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function map_contains() is not available in R.")
}

#' DuckDB function map_entries
#'
#' Returns the map entries as a list of keys/values.
#'
#' @name map_entries
#' @usage NULL
#' @param map `MAP(K, V)`
#' @examples
#' \dontrun{
#' map_entries(map(['key'], ['val']))
#' }
map_entries <- function(map = `MAP(K, V)`) {
  stop("DuckDB function map_entries() is not available in R.")
}

#' DuckDB function map_extract
#'
#' Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the mapâ€™s keys else an error is returned.
#'
#' @name map_extract
#' @usage NULL
#' @param map `MAP(K, V)`
#' @param key `K`
#' @examples
#' \dontrun{
#' map_extract(map(['key'], ['val']), 'key')
#' }
map_extract <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function map_extract() is not available in R.")
}

#' DuckDB function map_extract_value
#'
#' Returns the value for a given key or NULL if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the mapâ€™s keys else an error is returned.
#'
#' @name map_extract_value
#' @usage NULL
#' @param map `MAP(K, V)`
#' @param key `K`
#' @examples
#' \dontrun{
#' map_extract_value(map(['key'], ['val']), 'key')
#' }
map_extract_value <- function(map = `MAP(K, V)`, key = K) {
  stop("DuckDB function map_extract_value() is not available in R.")
}

#' DuckDB function map_from_entries
#'
#' Returns a map created from the entries of the array.
#'
#' @name map_from_entries
#' @usage NULL
#' @param map `STRUCT(K, V)[]`
#' @examples
#' \dontrun{
#' map_from_entries([{k: 5, v: 'val1'}, {k: 3, v: 'val2'}]);
#' }
map_from_entries <- function(map = `STRUCT(K, V)[]`) {
  stop("DuckDB function map_from_entries() is not available in R.")
}

#' DuckDB function map_keys
#'
#' Returns the keys of a map as a list.
#'
#' @name map_keys
#' @usage NULL
#' @param map `MAP(K, V)`
#' @examples
#' \dontrun{
#' map_keys(map(['key'], ['val']))
#' }
map_keys <- function(map = `MAP(K, V)`) {
  stop("DuckDB function map_keys() is not available in R.")
}

#' DuckDB function map_values
#'
#' Returns the values of a map as a list.
#'
#' @name map_values
#' @usage NULL
#' @param map `MAP(K, V)`
#' @examples
#' \dontrun{
#' map_values(map(['key'], ['val']))
#' }
map_values <- function(map = `MAP(K, V)`) {
  stop("DuckDB function map_values() is not available in R.")
}

#' DuckDB function mismatches
#'
#' The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length. Strings must be of equal length. Characters of different cases (e.g., `a` and `A`) are considered different.
#'
#' @name mismatches
#' @usage NULL
#' @param s1 `VARCHAR`
#' @param s2 `VARCHAR`
#' @examples
#' \dontrun{
#' mismatches('duck', 'luck')
#' }
mismatches <- function(s1 = VARCHAR, s2 = VARCHAR) {
  stop("DuckDB function mismatches() is not available in R.")
}

#' DuckDB function nfc_normalize
#'
#' Converts `string` to Unicode NFC normalized string. Useful for comparisons and ordering if text data is mixed between NFC normalized and not.
#'
#' @name nfc_normalize
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' nfc_normalize('ardeÌ€ch')
#' }
nfc_normalize <- function(string = VARCHAR) {
  stop("DuckDB function nfc_normalize() is not available in R.")
}

#' DuckDB function normalized_interval
#'
#' Normalizes an INTERVAL to an equivalent interval.
#'
#' @name normalized_interval
#' @usage NULL
#' @param interval `INTERVAL`
#' @examples
#' \dontrun{
#' normalized_interval(INTERVAL '30 days')
#' }
normalized_interval <- function(interval = INTERVAL) {
  stop("DuckDB function normalized_interval() is not available in R.")
}

#' DuckDB function not_ilike_escape
#'
#' Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name not_ilike_escape
#' @usage NULL
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' not_ilike_escape('A%c', 'a$%C', '$')
#' }
not_ilike_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function not_ilike_escape() is not available in R.")
}

#' DuckDB function not_like_escape
#'
#' Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching. `escape_character` is used to search for wildcard characters in the `string`.
#'
#' @name not_like_escape
#' @usage NULL
#' @param string `VARCHAR`
#' @param like_specifier `VARCHAR`
#' @param escape_character `VARCHAR`
#' @examples
#' \dontrun{
#' not_like_escape('a%c', 'a$%c', '$')
#' }
not_like_escape <- function(string = VARCHAR, like_specifier = VARCHAR, escape_character = VARCHAR) {
  stop("DuckDB function not_like_escape() is not available in R.")
}

#' DuckDB function ord
#'
#' Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.
#'
#' @name ord
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' [unicode('Ã¢bcd'), unicode('Ã¢'), unicode(''), unicode(NULL)]
#' }
ord <- function(string = VARCHAR) {
  stop("DuckDB function ord() is not available in R.")
}

#' DuckDB function parse_duckdb_log_message
#'
#' Parse the message into the expected logical type.
#'
#' @name parse_duckdb_log_message
#' @usage NULL
#' @param type `VARCHAR`
#' @param message `VARCHAR`
#' @examples
#' \dontrun{
#' parse_duckdb_log_message('FileSystem', log_message)
#' }
parse_duckdb_log_message <- function(type = VARCHAR, message = VARCHAR) {
  stop("DuckDB function parse_duckdb_log_message() is not available in R.")
}

#' DuckDB function pi
#'
#' Returns the value of pi.
#'
#' @name pi
#' @usage NULL

#' @examples
#' \dontrun{
#' pi()
#' }
pi <- function() {
  stop("DuckDB function pi() is not available in R.")
}

#' DuckDB function position
#'
#' Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.
#'
#' @name position
#' @usage NULL
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' position('b' IN 'abc')
#' }
position <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function position() is not available in R.")
}

#' DuckDB function pow
#'
#' Computes x to the power of y.
#'
#' @name pow
#' @usage NULL
#' @param x `DOUBLE`
#' @param y `DOUBLE`
#' @examples
#' \dontrun{
#' c("pow(2, 3)", "power(2, 3)")
#' }
pow <- function(x = DOUBLE, y = DOUBLE) {
  stop("DuckDB function pow() is not available in R.")
}

#' DuckDB function power
#'
#' Computes x to the power of y.
#'
#' @name power
#' @usage NULL
#' @param x `DOUBLE`
#' @param y `DOUBLE`
#' @examples
#' \dontrun{
#' power(2, 3)
#' }
power <- function(x = DOUBLE, y = DOUBLE) {
  stop("DuckDB function power() is not available in R.")
}

#' DuckDB function prefix
#'
#' Returns `true` if `string` starts with `search_string`.
#'
#' @name prefix
#' @usage NULL
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' prefix('abc', 'ab')
#' }
prefix <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function prefix() is not available in R.")
}

#' DuckDB function radians
#'
#' Converts degrees to radians.
#'
#' @name radians
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' radians(90)
#' }
radians <- function(x = DOUBLE) {
  stop("DuckDB function radians() is not available in R.")
}

#' DuckDB function regexp_escape
#'
#' Escapes special patterns to turn `string` into a regular expression similarly to Python's `re.escape` function.
#'
#' @name regexp_escape
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' regexp_escape('https://duckdb.org')
#' }
regexp_escape <- function(string = VARCHAR) {
  stop("DuckDB function regexp_escape() is not available in R.")
}

#' DuckDB function remap_struct
#'
#' Map a struct to another struct type, potentially re-ordering, renaming and casting members and filling in defaults for missing values.
#'
#' @name remap_struct
#' @usage NULL
#' @param input `ANY`
#' @param target_type `ANY`
#' @param mapping `ANY`
#' @param defaults `ANY`
#' @examples
#' \dontrun{
#' remap_struct({'i': 1, 'j': 2}, NULL::ROW(v1 INT, v2 INT, v3 INT), {'v1': 'j', 'v3': 'i'}, {'v2': NULL::INTEGER})
#' }
remap_struct <- function(input = ANY, target_type = ANY, mapping = ANY, defaults = ANY) {
  stop("DuckDB function remap_struct() is not available in R.")
}

#' DuckDB function replace
#'
#' Replaces any occurrences of the `source` with `target` in `string`.
#'
#' @name replace
#' @usage NULL
#' @param string `VARCHAR`
#' @param source `VARCHAR`
#' @param target `VARCHAR`
#' @examples
#' \dontrun{
#' replace('hello', 'l', '-')
#' }
replace <- function(string = VARCHAR, source = VARCHAR, target = VARCHAR) {
  stop("DuckDB function replace() is not available in R.")
}

#' DuckDB function replace_type
#'
#' Casts all fields of type1 to type2.
#'
#' @name replace_type
#' @usage NULL
#' @param param `ANY`
#' @param type1 `ANY`
#' @param type2 `ANY`
#' @examples
#' \dontrun{
#' replace_type({duck: 3.141592653589793::DOUBLE}, NULL::DOUBLE, NULL::DECIMAL(15,2))
#' }
replace_type <- function(param = ANY, type1 = ANY, type2 = ANY) {
  stop("DuckDB function replace_type() is not available in R.")
}

#' DuckDB function reverse
#'
#' Reverses the `string`.
#'
#' @name reverse
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' reverse('hello')
#' }
reverse <- function(string = VARCHAR) {
  stop("DuckDB function reverse() is not available in R.")
}

#' DuckDB function right
#'
#' Extract the right-most `count` characters.
#'
#' @name right
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' right('HelloðŸ¦†', 3)
#' }
right <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function right() is not available in R.")
}

#' DuckDB function right_grapheme
#'
#' Extracts the right-most `count` grapheme clusters.
#'
#' @name right_grapheme
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `BIGINT`
#' @examples
#' \dontrun{
#' right_grapheme('ðŸ¤¦ðŸ¼â€â™‚ï¸ðŸ¤¦ðŸ½â€â™€ï¸', 1)
#' }
right_grapheme <- function(string = VARCHAR, count = BIGINT) {
  stop("DuckDB function right_grapheme() is not available in R.")
}

#' DuckDB function rpad
#'
#' Pads the `string` with the `character` on the right until it has `count` characters. Truncates the `string` on the right if it has more than `count` characters.
#'
#' @name rpad
#' @usage NULL
#' @param string `VARCHAR`
#' @param count `INTEGER`
#' @param character `VARCHAR`
#' @examples
#' \dontrun{
#' rpad('hello', 10, '<')
#' }
rpad <- function(string = VARCHAR, count = INTEGER, character = VARCHAR) {
  stop("DuckDB function rpad() is not available in R.")
}

#' DuckDB function set_bit
#'
#' Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0. Returns a new bitstring.
#'
#' @name set_bit
#' @usage NULL
#' @param bitstring `BIT`
#' @param index `INTEGER`
#' @param new_value `INTEGER`
#' @examples
#' \dontrun{
#' set_bit('0110010'::BIT, 2, 0)
#' }
set_bit <- function(bitstring = BIT, index = INTEGER, new_value = INTEGER) {
  stop("DuckDB function set_bit() is not available in R.")
}

#' DuckDB function sin
#'
#' Computes the sin of x.
#'
#' @name sin
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' sin(90)
#' }
sin <- function(x = DOUBLE) {
  stop("DuckDB function sin() is not available in R.")
}

#' DuckDB function sinh
#'
#' Computes the hyperbolic sin of x.
#'
#' @name sinh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' sinh(1)
#' }
sinh <- function(x = DOUBLE) {
  stop("DuckDB function sinh() is not available in R.")
}

#' DuckDB function split
#'
#' Splits the `string` along the `separator`.
#'
#' @name split
#' @usage NULL
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' split('hello-world', '-')
#' }
split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function split() is not available in R.")
}

#' DuckDB function sqrt
#'
#' Returns the square root of x.
#'
#' @name sqrt
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' sqrt(4)
#' }
sqrt <- function(x = DOUBLE) {
  stop("DuckDB function sqrt() is not available in R.")
}

#' DuckDB function starts_with
#'
#' Returns `true` if `string` begins with `search_string`.
#'
#' @name starts_with
#' @usage NULL
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' starts_with('abc', 'a')
#' }
starts_with <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function starts_with() is not available in R.")
}

#' DuckDB function str_split
#'
#' Splits the `string` along the `separator`.
#'
#' @name str_split
#' @usage NULL
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' str_split('hello-world', '-')
#' }
str_split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function str_split() is not available in R.")
}

#' DuckDB function string_split
#'
#' Splits the `string` along the `separator`.
#'
#' @name string_split
#' @usage NULL
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' string_split('hello-world', '-')
#' }
string_split <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function string_split() is not available in R.")
}

#' DuckDB function string_to_array
#'
#' Splits the `string` along the `separator`.
#'
#' @name string_to_array
#' @usage NULL
#' @param string `VARCHAR`
#' @param separator `VARCHAR`
#' @examples
#' \dontrun{
#' string_to_array('hello-world', '-')
#' }
string_to_array <- function(string = VARCHAR, separator = VARCHAR) {
  stop("DuckDB function string_to_array() is not available in R.")
}

#' DuckDB function strip_accents
#'
#' Strips accents from `string`.
#'
#' @name strip_accents
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' strip_accents('mÃ¼hleisen')
#' }
strip_accents <- function(string = VARCHAR) {
  stop("DuckDB function strip_accents() is not available in R.")
}

#' DuckDB function strlen
#'
#' Number of bytes in `string`.
#'
#' @name strlen
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' strlen('ðŸ¦†')
#' }
strlen <- function(string = VARCHAR) {
  stop("DuckDB function strlen() is not available in R.")
}

#' DuckDB function strpos
#'
#' Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.
#'
#' @name strpos
#' @usage NULL
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' strpos('test test', 'es')
#' }
strpos <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function strpos() is not available in R.")
}

#' DuckDB function struct_contains
#'
#' Check if an unnamed STRUCT contains the value.
#'
#' @name struct_contains
#' @usage NULL
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @examples
#' \dontrun{
#' struct_contains(ROW(3, 3, 0), 3)
#' }
struct_contains <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_contains() is not available in R.")
}

#' DuckDB function struct_has
#'
#' Check if an unnamed STRUCT contains the value.
#'
#' @name struct_has
#' @usage NULL
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @examples
#' \dontrun{
#' struct_has(ROW(3, 3, 0), 3)
#' }
struct_has <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_has() is not available in R.")
}

#' DuckDB function struct_indexof
#'
#' Get the position of the entry in an unnamed STRUCT, starting at 1.
#'
#' @name struct_indexof
#' @usage NULL
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @examples
#' \dontrun{
#' struct_indexof(ROW(3, 3, 0), 3)
#' }
struct_indexof <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_indexof() is not available in R.")
}

#' DuckDB function struct_position
#'
#' Get the position of the entry in an unnamed STRUCT, starting at 1.
#'
#' @name struct_position
#' @usage NULL
#' @param struct `STRUCT`
#' @param 'entry' `ANY`
#' @examples
#' \dontrun{
#' struct_position(ROW(3, 3, 0), 3)
#' }
struct_position <- function(struct = STRUCT, `'entry'` = ANY) {
  stop("DuckDB function struct_position() is not available in R.")
}

#' DuckDB function suffix
#'
#' Returns `true` if `string` ends with `search_string`.
#'
#' @name suffix
#' @usage NULL
#' @param string `VARCHAR`
#' @param search_string `VARCHAR`
#' @examples
#' \dontrun{
#' suffix('abc', 'bc')
#' }
suffix <- function(string = VARCHAR, search_string = VARCHAR) {
  stop("DuckDB function suffix() is not available in R.")
}

#' DuckDB function tan
#'
#' Computes the tan of x.
#'
#' @name tan
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' tan(90)
#' }
tan <- function(x = DOUBLE) {
  stop("DuckDB function tan() is not available in R.")
}

#' DuckDB function tanh
#'
#' Computes the hyperbolic tan of x.
#'
#' @name tanh
#' @usage NULL
#' @param x `DOUBLE`
#' @examples
#' \dontrun{
#' tanh(1)
#' }
tanh <- function(x = DOUBLE) {
  stop("DuckDB function tanh() is not available in R.")
}

#' DuckDB function timetz_byte_comparable
#'
#' Converts a TIME WITH TIME ZONE to an integer sort key.
#'
#' @name timetz_byte_comparable
#' @usage NULL
#' @param time_tz `TIME WITH TIME ZONE`
#' @examples
#' \dontrun{
#' timetz_byte_comparable('18:18:16.21-07:00'::TIMETZ)
#' }
timetz_byte_comparable <- function(time_tz = `TIME WITH TIME ZONE`) {
  stop("DuckDB function timetz_byte_comparable() is not available in R.")
}

#' DuckDB function to_base64
#'
#' Converts a `blob` to a base64 encoded string.
#'
#' @name to_base64
#' @usage NULL
#' @param blob `BLOB`
#' @examples
#' \dontrun{
#' to_base64('A'::BLOB)
#' }
to_base64 <- function(blob = BLOB) {
  stop("DuckDB function to_base64() is not available in R.")
}

#' DuckDB function to_hours
#'
#' Construct a hour interval.
#'
#' @name to_hours
#' @usage NULL
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' to_hours(5)
#' }
to_hours <- function(integer = BIGINT) {
  stop("DuckDB function to_hours() is not available in R.")
}

#' DuckDB function to_microseconds
#'
#' Construct a microsecond interval.
#'
#' @name to_microseconds
#' @usage NULL
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' to_microseconds(5)
#' }
to_microseconds <- function(integer = BIGINT) {
  stop("DuckDB function to_microseconds() is not available in R.")
}

#' DuckDB function to_milliseconds
#'
#' Construct a millisecond interval.
#'
#' @name to_milliseconds
#' @usage NULL
#' @param double `DOUBLE`
#' @examples
#' \dontrun{
#' to_milliseconds(5.5)
#' }
to_milliseconds <- function(double = DOUBLE) {
  stop("DuckDB function to_milliseconds() is not available in R.")
}

#' DuckDB function to_minutes
#'
#' Construct a minute interval.
#'
#' @name to_minutes
#' @usage NULL
#' @param integer `BIGINT`
#' @examples
#' \dontrun{
#' to_minutes(5)
#' }
to_minutes <- function(integer = BIGINT) {
  stop("DuckDB function to_minutes() is not available in R.")
}

#' DuckDB function to_seconds
#'
#' Construct a second interval.
#'
#' @name to_seconds
#' @usage NULL
#' @param double `DOUBLE`
#' @examples
#' \dontrun{
#' to_seconds(5.5)
#' }
to_seconds <- function(double = DOUBLE) {
  stop("DuckDB function to_seconds() is not available in R.")
}

#' DuckDB function to_timestamp
#'
#' Converts secs since epoch to a timestamp with time zone.
#'
#' @name to_timestamp
#' @usage NULL
#' @param sec `DOUBLE`
#' @examples
#' \dontrun{
#' to_timestamp(1284352323.5)
#' }
to_timestamp <- function(sec = DOUBLE) {
  stop("DuckDB function to_timestamp() is not available in R.")
}

#' DuckDB function translate
#'
#' Replaces each character in `string` that matches a character in the `from` set with the corresponding character in the `to` set. If `from` is longer than `to`, occurrences of the extra characters in `from` are deleted.
#'
#' @name translate
#' @usage NULL
#' @param string `VARCHAR`
#' @param from `VARCHAR`
#' @param to `VARCHAR`
#' @examples
#' \dontrun{
#' translate('12345', '143', 'ax')
#' }
translate <- function(string = VARCHAR, from = VARCHAR, to = VARCHAR) {
  stop("DuckDB function translate() is not available in R.")
}

#' DuckDB function typeof
#'
#' Returns the name of the data type of the result of the expression.
#'
#' @name typeof
#' @usage NULL
#' @param expression `ANY`
#' @examples
#' \dontrun{
#' typeof('abc')
#' }
typeof <- function(expression = ANY) {
  stop("DuckDB function typeof() is not available in R.")
}

#' DuckDB function ucase
#'
#' Converts `string` to upper case.
#'
#' @name ucase
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' ucase('Hello')
#' }
ucase <- function(string = VARCHAR) {
  stop("DuckDB function ucase() is not available in R.")
}

#' DuckDB function unbin
#'
#' Converts a `value` from binary representation to a blob.
#'
#' @name unbin
#' @usage NULL
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' unbin('0110')
#' }
unbin <- function(value = VARCHAR) {
  stop("DuckDB function unbin() is not available in R.")
}

#' DuckDB function unhex
#'
#' Converts a `value` from hexadecimal representation to a blob.
#'
#' @name unhex
#' @usage NULL
#' @param value `VARCHAR`
#' @examples
#' \dontrun{
#' unhex('2A')
#' }
unhex <- function(value = VARCHAR) {
  stop("DuckDB function unhex() is not available in R.")
}

#' DuckDB function unicode
#'
#' Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.
#'
#' @name unicode
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' [unicode('Ã¢bcd'), unicode('Ã¢'), unicode(''), unicode(NULL)]
#' }
unicode <- function(string = VARCHAR) {
  stop("DuckDB function unicode() is not available in R.")
}

#' DuckDB function union_extract
#'
#' Extract the value with the named tags from the union. NULL if the tag is not currently selected.
#'
#' @name union_extract
#' @usage NULL
#' @param union `UNION`
#' @param tag `VARCHAR`
#' @examples
#' \dontrun{
#' union_extract(s, 'k')
#' }
union_extract <- function(union = UNION, tag = VARCHAR) {
  stop("DuckDB function union_extract() is not available in R.")
}

#' DuckDB function union_tag
#'
#' Retrieve the currently selected tag of the union as an ENUM.
#'
#' @name union_tag
#' @usage NULL
#' @param union `UNION`
#' @examples
#' \dontrun{
#' union_tag(union_value(k := 'foo'))
#' }
union_tag <- function(union = UNION) {
  stop("DuckDB function union_tag() is not available in R.")
}

#' DuckDB function upper
#'
#' Converts `string` to upper case.
#'
#' @name upper
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' upper('Hello')
#' }
upper <- function(string = VARCHAR) {
  stop("DuckDB function upper() is not available in R.")
}

#' DuckDB function url_decode
#'
#' Decodes a URL from a representation using Percent-Encoding.
#'
#' @name url_decode
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' url_decode('https%3A%2F%2Fduckdb.org%2Fwhy_duckdb%23portable')
#' }
url_decode <- function(string = VARCHAR) {
  stop("DuckDB function url_decode() is not available in R.")
}

#' DuckDB function url_encode
#'
#' Encodes a URL to a representation using Percent-Encoding.
#'
#' @name url_encode
#' @usage NULL
#' @param string `VARCHAR`
#' @examples
#' \dontrun{
#' url_encode('this string has/ special+ characters>')
#' }
url_encode <- function(string = VARCHAR) {
  stop("DuckDB function url_encode() is not available in R.")
}

#' DuckDB function uuid_extract_timestamp
#'
#' Extract the timestamp for the given UUID v7.
#'
#' @name uuid_extract_timestamp
#' @usage NULL
#' @param uuid `UUID`
#' @examples
#' \dontrun{
#' uuid_extract_timestamp('019482e4-1441-7aad-8127-eec99573b0a0')
#' }
uuid_extract_timestamp <- function(uuid = UUID) {
  stop("DuckDB function uuid_extract_timestamp() is not available in R.")
}

#' DuckDB function uuid_extract_version
#'
#' Extract a version for the given UUID.
#'
#' @name uuid_extract_version
#' @usage NULL
#' @param uuid `UUID`
#' @examples
#' \dontrun{
#' uuid_extract_version('019482e4-1441-7aad-8127-eec99573b0a0')
#' }
uuid_extract_version <- function(uuid = UUID) {
  stop("DuckDB function uuid_extract_version() is not available in R.")
}

#' DuckDB function variant_typeof
#'
#' Returns the internal type of the `input_variant`.
#'
#' @name variant_typeof
#' @usage NULL
#' @param input_variant `VARIANT`
#' @examples
#' \dontrun{
#' variant_typeof({'a': 42, 'b': [1,2,3])::VARIANT)
#' }
variant_typeof <- function(input_variant = VARIANT) {
  stop("DuckDB function variant_typeof() is not available in R.")
}

#' DuckDB function vector_type
#'
#' Returns the VectorType of a given column.
#'
#' @name vector_type
#' @usage NULL
#' @param col `ANY`
#' @examples
#' \dontrun{
#' vector_type(col)
#' }
vector_type <- function(col = ANY) {
  stop("DuckDB function vector_type() is not available in R.")
}

#' DuckDB function version
#'
#' Returns the currently active version of DuckDB in this format: v0.3.2	.
#'
#' @name version
#' @usage NULL

#' @examples
#' \dontrun{
#' version()
#' }
version <- function() {
  stop("DuckDB function version() is not available in R.")
}

